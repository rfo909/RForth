: Main "running_main .str cr ;

(To make a project runnable)

: save 64 0 0x50 NATIVE I2C.EE.save ;
: load 64 0 0x50 NATIVE I2C.EE.load ;

: eedump
  0 => i BEGIN
  i NATIVE Sys.EE.Read print cr
  i 1+ => i
  i 20 < AGAIN?
;

: dump (count pos) 
  => pos => count BEGIN 
  pos readb print cr
  pos 1+ => pos
  count 1 - => count
  count 0 > AGAIN? ;

: testAutorun
  NATIVE Sys.EE.GetAutorun
  &CompileBuf 1+ call cforce
;

save 

(set up autorun)

(temporary constant for compiling autorun word, as
 autorun code can not contain strings, which are compiled
 to the heap, so we use a constant, which when referred
 in code generates code for the numeric literal directly
 in the compiled output)
 
"Main ?C CONSTANT MainRef

: autorun 
  64 0 0x50 NATIVE I2C.EE.load 
  MainRef ?C
;

"autorun ?C NATIVE Sys.EE.SetAutorun 

 
#END
(
Set up code for auto run:
-------------------------
NOTE can not call dictionary words nor use strings, as those get 
compiled into heap locations unavailable when this code runs
)

save

"load ?C NATIVE Sys.EE.SetAutorun

load



#END

(Reset the device, then -automatically- run
the following - note that for uninitialized
onboard EEPROM it returns a single instruction,
"ret" - this should be followed by looking up
the word "Main", and if it exists, call it)

NATIVE Sys.EE.GetAutorun call

 
#END
Dict [input]
[input] DictUse

(
Letting #buf indicate a
static buffer that has the
length byte set to the size
of the buffer
)

: fillSpaces (#buf) 
  => buf
  buf readb 1 - => pos
  BEGIN 
    0x20 buf pos + 1+ writeb
    pos 1 - => pos
    pos AGAIN? ;

: CRLF? (ch) dup 13 == 
  swap 10 == || ;
  
: readLine (#buf)
  dup fillSpaces 
  dup readb => len
  => buf 0 => pos
  0 => c (define before loop)
  BEGIN
    readc => c
    c CRLF?
      pos buf readb >= || 
      IF ret THEN
    c buf pos + 1+ writeb
    pos 1+ => pos  
    1 AGAIN?
;

DictClear

(148 bytes)


(
Testing
=======

[input] DictUse
HERE 32 allot CONSTANT buf
31 buf writeb
buf readLine
  <enter line>
buf .str
)


#END

