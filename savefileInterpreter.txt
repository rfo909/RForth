# README
# --
<<< EOF
This test interpreter has no limits on the stacks or the heap. 
The goal is to validate the output from the Assembler.
>>> EOF
/Readme


# The interpreter
# --
	P(1) as String => code
	
	self.memory=Std.Array(code.chars) # using array, as writes will generate non-readable data 
	self.PC=0
	self.dataStack=List
	self.callStack=List  # number values or "mark" string
	
	self.nextInstruction=Lambda{
		self.memory.get(self.PC)
	}
	self.showWord=Lambda{
		P(1)=>addr
		if (addr > self.memory.length-2) println("Invalid address")
		else {
			a=self.memory.get(addr)
			b=self.memory.get(addr+1)
			if (Sys.getType(a)=="int") a="0x"+a.hex
			if (Sys.getType(b)=="int") b="0x"+b.hex
			println(a,b)
		}
	}
	self.push=Lambda{P(1)=>value self.dataStack.insert(0,value)}
	self.pop=Lambda{value=self.dataStack.nth(0) self.dataStack.remove(0) value}
	
	self.executeInstruction=Lambda{
		pc=self.PC
		name="_"+self.memory.get(self.PC)
		if (self.has(name)) {
			closure = self.get(name)
			result = tryCatch(closure.call)
			
			if (!result.ok) {
				println("*** Execution failed:",result.msg)
			} else {
				# executed ok, now update PC unless a jump has already moved it
				if (self.PC == pc) {
					self.PC=pc+1
				}
				println("ok")
			}
		} else {
			println("*** Unknown instruction member",name)
		}
	}
	self._x=Lambda{self.push(0)}
	self._0=Lambda{self.push(self.pop*16+0)}
	self._1=Lambda{self.push(self.pop*16+1)}
	self._2=Lambda{self.push(self.pop*16+2)}
	self._3=Lambda{self.push(self.pop*16+3)}
	self._4=Lambda{self.push(self.pop*16+4)}
	self._5=Lambda{self.push(self.pop*16+5)}
	self._6=Lambda{self.push(self.pop*16+6)}
	self._7=Lambda{self.push(self.pop*16+7)}
	self._8=Lambda{self.push(self.pop*16+8)}
	self._8=Lambda{self.push(self.pop*16+9)}
	self._A=Lambda{self.push(self.pop*16+10)}
	self._B=Lambda{self.push(self.pop*16+11)}
	self._C=Lambda{self.push(self.pop*16+12)}
	self._D=Lambda{self.push(self.pop*16+13)}
	self._E=Lambda{self.push(self.pop*16+14)}
	self._F=Lambda{self.push(self.pop*16+15)}

	self.set("_+", Lambda{self.push(self.pop+self.pop)})
	self.set("_-", Lambda{b=self.pop a=self.pop self.push(a-b)})
	self.set("_*", Lambda{b=self.pop a=self.pop self.push(a*b)})
	self.set("_/", Lambda{b=self.pop a=self.pop self.push((a/b).i)})
	self.set("_<", Lambda{b=self.pop a=self.pop value=if(a<b,1,0) self.push(value)})
	self.set("_=", Lambda{b=self.pop a=self.pop value=if(a==b,1,0) self.push(value)})
	self.set("_>", Lambda{b=self.pop a=self.pop value=if(a>b,1,0) self.push(value)})
	
	self._g=Lambda{self.push(self.memory.length)}   # HERE
	self._U=Lambda{self.push(self.PC)}		# PC
	
	self.set("_&", Lambda{b=self.pop a=self.pop value=if(a != 0 && b != 0, 1, 0) self.push(value)})
	self.set("_|", Lambda{b=self.pop a=self.pop value=if(a != 0 || b != 0, 1, 0) self.push(value)})
	
	self._S=Lambda{self.PC=self.pop}  # jmp
	self._T=Lambda{addr=self.pop cond=self.pop if(cond != 0) self.PC=addr}  # jmp?
	
	
/class Interpreter


# Testing eval inside class 
# --
	self.name=Lambda{"ugh"}
	self.func=Lambda{
		self.get("name").call
	}
/class etest

etest.func
/et


# Test
# --
	P(1) => code
	
	if (code==null) {
		println("Paste then . for code")
		code=readLines(".").concat
	}
	Lib:Header("Code string: " + code.length + " bytes")
	println(code)
	println
	
	x=Interpreter(code)
	loop
		# show PC
		instr=x.nextInstruction
		instrName=instr
		if (!"x0123456789ABCDEF".contains(instr)) instrName=Assembler:InstructionsLookup.get(instr)
		
		# show dataStack
		println("dataStack [ " + x.dataStack.reverse.concat(" ") + " ] TOP")
		# show callStack
		println("callStack [ " + x.callStack.reverse.concat(" ") + " ] TOP")
		
		println
		println("PC",("0000"+x.PC.hex.toUpper).last(4), instr, instrName)
		
		println
		terminate=false
		Inner{
			loop
				command=readLine("Command: 'q' to quit, 'i' to inspect, ENTER to continue").trim
				if(command=="q") {
					terminate=true
					break
				} else if (command=="i") {
					addr=Input("Enter address on hex format NNNN").get.parseInt(16)
					x.showWord(addr)
				} else if (command.trim=="") {
					x.executeInstruction
					break
				}
			|
		}
		break(terminate)
		
		 
/t		
	
