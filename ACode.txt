; This is the base system that eventually will implement some sort of a
; REPL on a microcontroller. It contains instructions, organized under
; tags at two levels, which are employed for direct jumps (jmp), conditional 
; jumps (jmp?) and calls (call), which assume a return (ret).
;
; The outer level of tags is denoted :xxx to define a tag, and &xxx to refer
; it. All tag references result in 5 bytes of code, which when run puts the
; address on the stack. Outer level tags are global.
;
; Then there are local tags. These exist only in the scope between outer 
; tags. This means common words like "again" or "exit" can be used
; in different functions, without mixing up.
;
; These are defined with :*xxx and referred via &*xxx.
;
; The assembler handles patching all forward tag references when building
; the code.
;
; ---
;
; Note that the :Init and :Main tags are never jumped to nor called, and 
; so they exist for clarity only. Also note that the remaining global tags
; before the :DATA are supposed to be call'ed, and end in 'ret' to return.
;


:Init
	&DATA SET_DATA_START  ; to catch write attempts below this limit

	;; initialize pointers to zero
	null &ConsFree !
	null &DictHead !

	;; Fall through to Main

:Main
 	cr 'HERE ': 2 show HERE print cr

	;; create a number of CONS cells in freelist
	'Creating 'CONS 'cells 3 show
	10 cpush   ; a	
	:*again
		cr a print#
		&ConsAlloc call
		a 1 sub dup a! null gt &*again jmp?

 	cr 'HERE ': 2 show 
	HERE print

	cr 'Showing 'CONS 'freelist 3 show
	&ConsFreelistShow call

	cr 'Done 1 show
	
	;; falling through to Halt

:Halt			;; endless loop
	&Halt jmp


;; The dictionary is created from CONS cells
;;	
	


;; CONS cells are created as a CAR+CDR tuple, each value a Word. They are allotted
;; as needed, but also freelisted when disposed off. To calculate the CDR address
;; from the Cons pointer: W+


:ConsAlloc  ; ( -- )
	&ConsFree cpush		;; a=&ConsFree
	HERE   cpush		;; b=Ptr to new Cons
	wordsize 2 mul allot	;; reserve space for Cons
		
	a @ b !			;; ptr.CAR=&ConsFree
	b a !			;; &ConsFree=ptr	

	cr 'CONS 'addr 2 show
	b print
	
	;; no return value
	ret


;; run through the Cons Freelist, listing the addresses
:ConsFreelistShow
	&ConsFree @ cpush  ; a=pointer to next CONS

	:*again
		a 0 eq &*done jmp?
		a @ dup print cr a!
		&*again jmp

	:*done
	'freelist 'CONS 'done 3 show
	ret
		

:ConsGet  ; ( -- ConsPtr) - get Cons cell from free list (call ConsAlloc first if empty)
	&ConsFree cpush   ;; a=&ConsFree
	
	a @ null ne &*FreelistOk jmp?

		;; freelist is empty, allocate one Cons and put it in freelist
		&ConsAlloc call
	
	:*FreelistOk
	
	;; got data in freelist, take first cons

	a @  		;; (ptr to Cons)

	dup @ a !   ;; &ConsFree = cons.car

	;; (Ptr)
	ret
	
:ConsDispose  ;; (ptr -- )
	&ConsFree cpush 	;; a=&ConsFree
	
	dup a swap 		;; (ptr &ConsFree ptr)
		!		;; ptr.car=&ConsFree
		
	;; (ptr)
	a !			;; &ConsFree=ptr
	;; no return value
	ret

;; ---------------------------------
;; Reserved tags, must be present
;; ---------------------------------	

:DATA		
	;; data is generated here, which includes symbols - the tag is used 
	;; by disassembler to show bytes correctly beyond this point (not 
	;; as instructions)

;; for pointers we reserve bytes by entering instructions that occupy 4 bytes,
;; even though we are never going to call them. Using 4 bytes instead of
;; just 2 (current wordsize) ensures compatibility with a future 4 byte word size.
;;
;; At the top of the code, these pointers are nulled with program code, before being
;; used. Note that on a 2-byte word size, listing the memory for a pointer, once
;; initialized, will look like this: 0 0 x x. The two "x" are the extra zeroes.
;;

:ConsFree 0 0 0 0	;; freelist pointer 	
	;; 0 means empty
	;; Using four instructions to generate four bytes as a placeholder.
	;; The value is nulled in the Init section before use. Using 4 bytes instead
	;; of 2 to ensure compatibility with 4 byte wordsize - any more is
	;; unthinkable for embedded devices

:DictHead 0 0 0 0   ;; pointer


