# If we let DODOES take a pointer off the stack, instead of storing stuff on the heap,
# then we can let the ptr pass through CREATE and be picked up by DODOES and push that
# on the stack (via code) before jumping to run the code after DOES>

: Adder (ptr) CREATE &CREATE-HERE ! DOES> (value) => val => ptr ptr @ val add ptr ! ;
: Subtractor (ptr) CREATE &CREATE-HERE ! DOES> (value) => val => ptr ptr @ val add ptr ! ;
: Getter (ptr) CREATE &CREATE-HERE ! DOES> (--value) @ ;

HERE 0 , 
    dup Adder OrderAdd 
    dup Subber OrderSub
    Getter OrderGet
  



(Using buffers for string ops)

(----------------------------)
Dict Str
Str DictUse

&CompileBuf CONSTANT buf
&CompileBufEnd &CompileBuf sub CONSTANT Available

(=============================
NOTE: Using the compile
buffer is safe as long as 
inside running code. Its 
content may change when using
the REPL
=============================)

: clear (--) 0 buf writeb ;

: Length (-- n) buf readb ;

: add (str --)
  => str
  str readb => strLen
  Length => bufLen

  strLen Length add Available gt IF
    "Str:_Buffer_overflow .str 
    PANIC
  THEN
  (-- copy str into buf --)
  str 1+ (source)
    buf Length add 1+ (target)
    strLen (#bytes)
      memcpy
  (-- update buf length --)
  Length strLen add
    buf writeb
;  

(-- for debug --)
: .b buf Available ShowBuffer ;

DictClear
(172 bytes)


(----------------------------)



(----------------------------)
(TEST CODE)

: SClr () IN Str clear ;
: S+ (str) IN Str add ;
: S> (--ptr) IN Str buf ;
: S. S> .str ;

: test 
  SClr 
  "test_ S+ 
  "tust_ S+ 
  S. ;




