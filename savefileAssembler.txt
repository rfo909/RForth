
# Example code
# --
	Sys.savefile.dir.file("ACode.txt").read
/ExampleCode


# Check for risky tagging such as creating tag when meaning to refer to it
# --
	num=0
	ExampleCode->line
		if (line.contains(":") || line.contains("&")) report(num,line)
		num=num+1
/ShowTagUse


# List all instructions, both actual and inline's
# --
	P(1,true) => includeInlines
	names=Instructions.keys
	if (includeInlines) names=names+Inlines.keys
	
	names.sort
/IShow

# Available printable non-space byte codes
# --
	"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+-*/><=.,;:$!#@%(){}[]\?_&|'`^~"+'"'
//AvailableByteCodes

# Check numeric value range for printable byte codes
# --
	min=999
	max=0
	AvailableByteCodes.chars->c 
		value=c.toHexString("ISO-8859-1").parseInt(16)
		if (value < min) min=value
		if (value > max) max=value
	|
	println("min",min,"max",max)
//BytecodeNumericRange


# Show instructions lookup sorted
# --
	available=Dict
	AvailableByteCodes.chars->c
		available.set(c,false)
	|
	
	data=InstructionsLookup
	data.keys.sort->key
		error(!available.has(key), "Not found in available keys: " + key)
		available.set(key,true)
		report(key,data.get(key))
	| _=>rows
	Lib:ShowRows(rows)

	available.keys->key assert(available.get(key)==false) out(key) | _.concat => unused
	println("Available keys:", unused.length, unused)
	print("Numeric range: ") 
	BytecodeNumericRange
	true
/IRShow


# Show interpreter instructions
# --
	Sys.savefile.dir.file("savefileInterpreter.txt").read->line
		
		assert( line.contains("self._") || line.contains('self.set("_') )
		out(line.after("self").after("_").chars.first)
	| _.sort.concat => x
	
	locals=Instructions
	locals.keys->key out(locals.get(key)) | _.sort.concat => y
	
	println("Interpreter: " + x)
	println("Assembler  : " + y)
	
	"ok"
/II
	
		
		
# Check what instructions remain to be implemented in the interpreter
# --
	f=Dir.file("savefileInterpreter.txt")
	data=InstructionsLookup
	
	data.keys->key
		Grep("self._"+key).fileCount(f) + Grep('self.set("_' + key).fileCount(f) => count
		reject(count>0)
		report(key,count,data.get(key))
/CheckRemaining
		

# Generate doc for instruction set
# --
	f=Sys.savefile.dir.file("savefileInterpreter.txt")
	data=InstructionsLookup
	
	data.keys.sort->key
		{
			a=Grep("self._"+key).file(f)
			b=Grep('self.set("_' + key).file(f)
			(a+b)->line
				out(line)
		}
	| _ -> line

		desc=line.after("#").trim
		name=desc.before(" ")
		desc=desc.after(" ").trim
		if (desc.startsWith("-")) desc=desc.sub(1).trim
		out(Str(name, SymDict(name,desc)))
	| _.sort->x
		dict=x.data
		report(dict.name, dict.desc)
/IDoc


# Assembly instructions mapped to "machine code"
# --
<<< EOF
	;; memory and registers
	readb		:G		;; read byte
	writeb		:H		;; write byte
	@		:I		;; read cell/word
	!		:J		;; write cell/word	

	allot		:K
	HERE		:g
	wordsize	:k
	
	W+		:n	;; wordsize add (for CONS cells and general use)

	;; data stack operations
	dcopy		:M		;; copy stack element n, where 0 is top etc, to top, so #1 dcopy is DUP
	dget		:N      ;; remove stack element n and push on top
	
	drop		:j		;; remove stack top element
	dup		:l
	swap		:m
	over		:o
	dump		:p		;; show stack content
	
	;;rot				;; inline: #2 dcopy
	;;2dup				;; inline: over over
	
	;; Both dStack and cstack must grow upwards in memory, containing words only, for
	;; predictable address calculations

	;; call stack: note that "marks" are separate (hidden) structure, not physical on the 
	;; visible call stack
	cpush		:O   ;; push 1 value from data stack to callstack
				;; up to 3 values accessible as local variables a@ a! b@ b! c@ c! (single instructions)

	call		:Q   
	ret		:R

	;; the call stack contains local variables + the return PC when calling something. 
	;; the callFrame stack contains two values; the base of the current frame on the call stack
	;;		and the number of words pushed with cpush, identifying top-of-stack for callStack

	;; local variable pointer instructions

	a		:a
	b		:b
	c		:c
	a!		:d
	b!		:e
	c!		:f
	
	;; global variables
	
	global		:x		;; read global variable ( N -- value )
	global!		:z		;; set global variable ( value N -- )
	
	;; math (note x0-9A-F are not included)
	add		:+
	sub		:-
	mul		:*
	div		:/

	;; logical operations
	eq		:=	;; 0 or 1
	ne		:h	;; 0 or 1
	gt		:>	;; 0 or 1
	lt		:<	;; 0 or 1
	not		:i	;; logical
	and		:&	;; logical 
	or		:|	;; logical
	
	;; bitwise operations
	andb		:q
	orb		:r
	inv		:s
	<<		:t
	>>		:u

	;; flow of control
		
	jmp		:S
	jmp?	:T   ;; conditional jump on true'	
	
	;; I/O
	show		:V   ;; ( ptr ptr ... N -- ) - display N STRINGS with space between them
	print		:W   ;; print any single value in hex
	cr			:X
	print#		:Y   ;; print value in decimal
	printb		:L   ;; print value in binary
	printc		:U   ;; print value as character (if single byte)
	
	halt		:Z   ;; halt automatic execution in interactive interpreter
		
	;; Strings are stored as one length byte and N characters (max 255)

	sym2s		:A		;; convert to string pointer
	.str		:C		;; print string

>>> EOF
	=>list
	
	dict=Dict
	values="" 
	
	list->rawLine
		line=rawLine.before(";")
		assert(line.trim.length>0)
		line.split(":")=>parts
		
		token=parts.first.trim
		value=parts.last.trim
		error(value.length != 1, "Invalid machine instruction, must be 1 char: " + value)
		error(values.contains(value),"Duplicate machine instruction: " + value)
		
		dict.set(token,value)
		values=values+value
	|
	dict
//Instructions


# Debug mode?
# --
	Db2:Get(Sys.scriptId,"debug",false)
//IsDebug

# Flip debug mode
# --
	Db2:Set(Sys.scriptId,"debug", !IsDebug)
	IsDebug
/Debug


# Inline defs
# --
	Dict
		.set("null",List("0"))

//Inlines



# Word generator for source, for handling inlines (via push)
# --
	self.words=List
	self.push = Lambda{
		P(1) as List => lines
		words=Inner{
			lines->line
				#println(line)
				line.trim.before(";").split->word
					out(word.trim)
		}
		self.words=words+self.words
	}
	self.getWord = Lambda{
		if(self.words.empty) {
			null
		} else {
			self.words.first => word
			self.words=self.words.keep(1)
			if (IsDebug) println("getWord",word)
			word
		}
	}
/class Words
	

# Assemble input to "machine code" format
# --
	P(1,ExampleCode) => code
	
	currentTag="<DEFAULT>"
	
	words=Words
	words.push(code)

	instructions=Instructions
	inlines=Inlines

	numberTable=NumberTable:NumberTable
		# all tags and constant numbers are added to the number table, and
		# we get a single byte back from 0 and up to 127. Adding 128 to it,
		# we add it to the output bytecode
					
	bytecode=Bytecode:Bytecode   # object
	
	loop
		word=words.getWord
		break(word==null)
		
		# inlines
		if (inlines.has(word)) {
			#println("Inline",word)
			words.push(inlines.get(word))
			continue
		}
		
	
		# specials
		
		bytecode.addMeta(word)
		
		# -- decimal format numbers
		if ("0123456789".indexOf(word.chars.first) >= 0 && word.?parseInt) { 
			n=word.parseInt
			pos=numberTable.constantValue(n)
			bytecode.addConstantLookupByte(pos)
			continue
		}
		
		# -- hex format number
		if ((word.startsWith("x") || word.startsWith("0x")) && word.after("x").?parseInt(16)) {
			n=word.after("x").parseInt(16)
			pos=numberTable.constantValue(n)
			bytecode.addConstantLookupByte(pos)
			continue
		}

		# -- binary format number
		if (word.startsWith("b") && word.sub(1).?parseInt(2)) {
			n=word.sub(1).parseInt(2)
			pos=numberTable.constantValue(n)
			bytecode.addConstantLookupByte(pos)
			continue
		}
		
		# -- symbol
		if (word.startsWith("'") || word.startsWith('"')) {
			symbol=word.sub(1)
			if (word.startsWith('"')) symbol=symbol.replace("_"," ")

			bytecode.addConstantLookupByte(numberTable.addSymbol(symbol))
			# add instruction to convert symbol to string at runtime
			words.push(List("sym2s"))
			continue
		}

		# -- local tag def
		if (word.startsWith(":*")) {
			tag=currentTag + "." + word.after(":*")
			pos=bytecode.length
			numberTable.defineTag(tag,pos)
			
			println(":"+tag,pos)
			continue
		}
		# -- global tag def
		if (word.startsWith(":")) {
			tag=word.after(":")
			pos=bytecode.length
			numberTable.defineTag(tag,pos)

			println(":"+tag, pos)
			currentTag=tag
			continue
		}

		# -- local tag reference
		if (word.startsWith("&*")) {
			tag=currentTag + "." + word.after("&*")
			bytecode.addConstantLookupByte(numberTable.tagLookup(tag))
			continue
		}
		# -- get global tag value
		if (word.startsWith("&")) {
			tag=word.after("&")
			bytecode.addConstantLookupByte(numberTable.tagLookup(tag))
			continue
		}
			
		# look up word in instructions map or fail
		if (instructions.has(word)) {
			char=instructions.get(word)
			bytecode.addChar(char)
		} else {
			error("Unknown word: '" + word + "'")
		}
	
	|
	
	# Return dict	
	SymDict(bytecode,numberTable)
/Assemble


# Create instructions lookup dictionary
# (Reverse of the Instructions dict)
# --
	dict=Dict
	instr=Instructions
	instr.keys->key
		value=instr.get(key)
		dict.set(value,key)
	|
	dict
//InstructionsLookup


# Disassembler showing what was generated
# --
	P(1) as Dict => dict
	
	bytecode=dict.bytecode
	numberTable=dict.numberTable
		
	lookup=InstructionsLookup
	
	length=bytecode.length
	Std.Data.for(0,length,1)->pos
		
		p1 = pos.hex(4).toUpper + " "
		p2 = bytecode.getMeta(pos)

		instr=bytecode.getValue(pos)
		
		p3=""
		p4=""
		if (Sys.getType(instr)=="String") {
			if (lookup.has(instr)) {
				p4=lookup.get(instr)
			}
			else error("Unknown instruction '" + instr + "'")
		} else if (Sys.getType(instr)=="int") {
			error(instr < 128, "lookup byte invalid value: " + instr)
			p3="["+instr+"]"
			constantValue=numberTable.resolveConstant(instr-128)
			
			p4 = "push 0x" + constantValue.hex(4).toUpper
		} else {
			error("Unknown instr type: " + instr)
		}
		report(p1,p2,p3,p4)
	| _=>rows
	Lib:ShowRows(rows)
/Disassemble
			
	

# Test by assembling ACode.txt, then disassembling it
# --
	Assemble => dict
	Disassemble(dict)
	
	bytecode=dict.bytecode
	metaInfo=dict.bytecode.metaInfo # indexed by ""+PC
	numberTable=dict.numberTable
	
	# Display all tags
	Lib:Header("Tags")
	
	Inner{
		dict.numberTable.getTagListSorted->tag
			report(tag,numberTable.resolveTag(tag).hex(4).toUpper)
		| _=>rows
		Lib:ShowRows(rows, null, false)
	}
	
	println

	# Display code as block that can be copy-pasted
	
	#println("bytecode")
	hexBlock=bytecode.getCodeHex
	#BlockFormat(bytecode.getCodeHex)
	#println(bytecode.getCodeHex.length)
	
	numbersStart=hexBlock.length div 2
	hexBlock=hexBlock + numberTable.generateOutput   # hex
	#println
	#println("numberTable")
	#println(numberTable.generateOutput)
	#println(numberTable.generateOutput.length)

	symbolsStart = hexBlock.length div 2
	hexBlock=hexBlock + numberTable.getSymbolHexString
	#println
	#println("symbols")
	#println(numberTable.getSymbolHexString)
	#println(numberTable.getSymbolHexString.length)
	#println
	
	println
	println("numbersStart", numbersStart.hex(4))
	println("symbolsStart", symbolsStart.hex(4))
	println
	#println("Hexblock length:", hexBlock.length)
	println("Total #bytes:", hexBlock.length div 2)
	

	# Store stuff in database for interpreter to pick up automagically
	tags=numberTable.tags
	tagListSorted=numberTable.getTagListSorted
	
	Db2:Set("RForth", "data", SymDict(hexBlock, numbersStart, symbolsStart, tags, tagListSorted, metaInfo))
	
	println("Constant numbers used = " + numberTable.getNumberCount + " of 127")
	println
	
	"ok"
	
/Compile

Compile
/t


# Block format text for copy/paste
# --
	P(1) as String => s
	
	loop
		if (s.length > 70) {
			println(s.sub(0,70))
			s=s.sub(70)
			continue
		} else {
			println(s)
			break
		}
/BlockFormat
