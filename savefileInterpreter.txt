# README
# --
<<< EOF
This test interpreter has no limits on the stacks or the heap. 
The goal is to validate the output from the Assembler.
>>> EOF
/Readme


# The interpreter
# --
	P(1) as String => code

	# number of words
	DSTACK_WORDS = 20
	CSTACK_WORDS = 40  # callstack
	FSTACK_FRAMES = 10  # frame stack - contains dictionaries
	
	self.WORDSIZE = 2
	self.memory=HWSim:Memory(self.WORDSIZE)
	self.memory.malloc(code.length)

	# write the code into memory
	addr=0
	code.chars->c self.memory.writeChar(addr,c) addr=addr+1 |

	#self.memory.dump

	self.PC=0

	self.HERE = Lambda{
		self.memory.HERE
	}
		
	# the call stack and data stacks exist in self.memory and grow upwards, storing words only,
	# for predictable address calculations.

	self.dbase=self.HERE
	self.memory.mallocWords(DSTACK_WORDS)
	self.dataStack=HWSim:MemStack(self.memory, self.dbase, DSTACK_WORDS, "data")

	self.cbase=self.HERE
	self.memory.mallocWords(CSTACK_WORDS)
	self.callStack=HWSim:MemStack(self.memory, self.cbase, CSTACK_WORDS, "calls")

	# the frame stack stores frames as two words: base and size
	self.fbase=self.HERE
	FSTACK_WORDS=FSTACK_FRAMES*2
	self.memory.mallocWords(FSTACK_WORDS)
	self.frameStack=HWSim:MemStack(self.memory, self.fbase, FSTACK_WORDS, "frames")

	# the frameStack contains dictionaries identifying the base and the top of the current
	# call frame, which lives on the call stack.
	
	self.nextInstruction=Lambda{
		self.memory.readChar(self.PC)
	}

	self.showMem=Lambda{
		P(1)=>fromAddr
		P(2,fromAddr+10) => toAddr
		result = tryCatch(self.memory.dump(fromAddr,toAddr))
		if (!result.ok) {
			println("*** FAILED: " + result.msg)
		}
	}


	# data stack
	self.push=Lambda{P(1)=>value self.dataStack.push(value)}
	self.pop=Lambda{self.dataStack.pop}


	# call stack
	self.cpush=Lambda{
		P(1) as int => value
		self.callStack.push(value)
		frameInfo=self.fpeek

		self.frameStack.pop
		self.frameStack.pop
		self.fpush(frameInfo.base, frameInfo.size+1)
	}

	# frame stack
	
	self.fpush = Lambda{
		P(1) as int => base
		P(2) as int => size
		self.frameStack.push(base)
		self.frameStack.push(size)
	}

	self.fpeek = Lambda {
		size=self.frameStack.pop
		base=self.frameStack.peek
		self.frameStack.push(size)
		SymDict(base,size)
	}

	self.fpop = Lambda{
		self.frameStack.pop
		self.frameStack.pop
	}

	# initialize frame stack - these numbers are offsets on the callStack

	self.fpush(0,0)

	
	self.executeInstruction=Lambda{
		pc=self.PC
		name="_"+self.memory.readChar(self.PC)
		if (self.has(name)) {
			closure = self.get(name)
			result = tryCatch(closure.call)
			
			if (!result.ok) {
				println("*** Execution failed:",result.msg)
			} else {
				# executed ok, now update PC unless a jump has already moved it
				if (self.PC == pc) {
					self.PC=pc+1
				}
				println("ok")
			}
		} else {
			println("*** Unknown instruction member",name)
		}
	}
	self._x=Lambda{self.push(0)}
	self._0=Lambda{self.push(self.pop*16+0)}
	self._1=Lambda{self.push(self.pop*16+1)}
	self._2=Lambda{self.push(self.pop*16+2)}
	self._3=Lambda{self.push(self.pop*16+3)}
	self._4=Lambda{self.push(self.pop*16+4)}
	self._5=Lambda{self.push(self.pop*16+5)}
	self._6=Lambda{self.push(self.pop*16+6)}
	self._7=Lambda{self.push(self.pop*16+7)}
	self._8=Lambda{self.push(self.pop*16+8)}
	self._9=Lambda{self.push(self.pop*16+9)}
	self._A=Lambda{self.push(self.pop*16+10)}
	self._B=Lambda{self.push(self.pop*16+11)}
	self._C=Lambda{self.push(self.pop*16+12)}
	self._D=Lambda{self.push(self.pop*16+13)}
	self._E=Lambda{self.push(self.pop*16+14)}
	self._F=Lambda{self.push(self.pop*16+15)}

	## Local variable pointer instructions a-f

	self._a=Lambda{
		self.push(self.cbase)
	}
	self._b=Lambda{
		self.push(self.cbase + self.WORDSIZE)
	}
	self._c=Lambda{
		self.push(self.cbase + self.WORDSIZE*2)
	}
	self._d=Lambda{
		self.push(self.cbase + self.WORDSIZE*3)
	}
	self._e=Lambda{
		self.push(self.cbase + self.WORDSIZE*4)
	}
	self._f=Lambda{
		self.push(self.cbase + self.WORDSIZE*5)
	}

	self.set("_+", Lambda{self.push(self.pop+self.pop)})
	self.set("_-", Lambda{b=self.pop a=self.pop self.push(a-b)})
	self.set("_*", Lambda{b=self.pop a=self.pop self.push(a*b)})
	self.set("_/", Lambda{b=self.pop a=self.pop self.push((a/b).i)})
	self.set("_<", Lambda{b=self.pop a=self.pop value=if(a<b,1,0) self.push(value)})
	self.set("_=", Lambda{b=self.pop a=self.pop value=if(a==b,1,0) self.push(value)})
	self.set("_>", Lambda{b=self.pop a=self.pop value=if(a>b,1,0) self.push(value)})
	
	self._g=Lambda{self.push(self.memory.length)}   # HERE
	self._U=Lambda{self.push(self.PC)}		# PC
	
	self.set("_&", Lambda{b=self.pop a=self.pop value=if(a != 0 && b != 0, 1, 0) self.push(value)})
	self.set("_|", Lambda{b=self.pop a=self.pop value=if(a != 0 || b != 0, 1, 0) self.push(value)})
	
	self._S=Lambda{self.PC=self.pop}  # jmp
	self._T=Lambda{addr=self.pop cond=self.pop if(cond != 0) self.PC=addr}  # jmp?
	
	self._Q=Lambda{  # call
		targetAddr=self.pop
		returnAddr=self.PC+1 # following call

		self.cpush(returnAddr)
		currFrame=self.fpeek

		frameInfo=Dict.set("base",currFrame.base+currFrame.size).set("size",0)
			# currFrame.size will be at least 1 after we pushed return address

		base=currFrame.base+currFrame.size
		size=0
		self.fpush(base,size)

		self.PC=targetAddr # JMP
	}
	self._R=Lambda{  # ret
		self.fpop

		frameInfo=self.fpeek  # previous frame

		# resetting callstack as it were before call
		self.callStack.setNext(frameInfo.base + frameInfo.size) 
	
		# popping the jump address
		targetAddr=self.callStack.pop

		# must update the frameInfo about having popped the PC from the callStack
		base=frameInfo.base
		size=frameInfo.size-1
		self.fpop
		self.fpush(base,size)

		self.PC=targetAddr # JMP
	}
	
	self._I=Lambda{  # @ = read word
		# our "memory" is word-based, which differs from the future C-impl
		addr=self.pop
		self.push(self.memory.readWord(addr))
	}
	
	self._J=Lambda{  # ! = write word
		addr=self.pop
		value=self.pop
		println("set","addr",addr,"value",value)
		self.memory.writeWord(addr,value)
	}

	self._O=Lambda{  # cpush
		count=self.pop  # ( [data] a b c -> [call] a b c )
		Std.Data.for(0,count,1)->i
			out(self.pop)  # cba
		| _.reverse->val
			self.cpush(val)
	}

	self._P=Lambda{ # cbase
		frameInfo=self.fpeek
		self.push(self.cbase + (frameInfo.base*self.WORDSIZE))
	}

	self._M=Lambda{ # dcopy: ( a b c 2 -- a b c a ) - argument 0 is top of stack 1 next and so on
		offset=self.pop
		value=self.dataStack.getValue(offset)
		self.push(value)
	}

	self._N=Lambda{ # dget: (a b c 0 -- a b) and (a b c 1 -- a c)
		offset=self.pop
		value=self.dataStack.removeValue(offset)
		self.push(value)
	}

	self._j=Lambda { # drop
		self.pop
	}
		
		
/class Interpreter



# Show frame stack
# --
	P(1) as &MemStack => frameStack

	# pair two values
	count=0
	frameStack.getStackValues->value
		count=count+1
		if (count % 2 == 0) out(":") else out(" ")
		out(value)
	| _.concat
//ShowFrameStack


# Show word stack
# --
	P(1) as &MemStack => stack
	stack.getStackValues->value
		out("" + value + "/x" + value.hex.toUpper)
	| _.concat("  ")
//ShowWordStack


# Read address
# --
	Input("Enter address hex NNNN or decimal #NNNN").get =>addr
	if (addr.startsWith("#")) {
		addr.after("#").parseInt(10)
	} else if (addr.startsWith("0x") || addr.startsWith("x")) {
		addr.after("x").parseInt(16)
	} else {
		addr.parseInt(16)
	}
//ReadAddress

# Test
# --
	P(1) => code
	
	if (code==null) {
		println("Paste then . for code")
		code=readLines(".").concat
	}
	Lib:Header("Code string: " + code.length + " bytes")
	println(code)
	println
	
	x=Interpreter(code)
	loop
		# show PC
		instr=x.nextInstruction
		instrName=instr
		instrName=Assembler:InstructionsLookup.get(instr)
		
		println
		# show dataStack
		println("dataStack  0x" + x.dbase.hex(4) + " [ " + ShowWordStack(x.dataStack) + " ] TOP")
		# show callStack
		println("callStack  0x" + x.cbase.hex(4) + " [ " + ShowWordStack(x.callStack) + " ] TOP")
		# show frameStack
		println("frameStack 0x" + x.fbase.hex(4) + " [ " + ShowFrameStack(x.frameStack) + " ] TOP")
		
		println
		println("PC", "0x" + ("0000"+x.PC.hex.toUpper).last(4), instr, instrName)
		
		println
		command=readLine("Command: 'q' to quit, 'i' to inspect, 'w' read word, ENTER to continue").trim
		if(command=="q") {
			break
		} else if (command=="i") {
			addr=ReadAddress
			x.showMem(addr)
		} else if (command=="w") {
			addr=ReadAddress
			println("=> " + x.memory.readWord(addr))
		} else if (command.trim=="") {
			x.executeInstruction
		}
		
		 
/t		
	
