:OP_JMP
	Ref addr = dsPopRef();
	
	Ref currCSF = getCurrCSF();   // may create if none found
	writeRef(currCSF + CSF_pc, addr);
	
:OP_COND_JMP
	Ref addr = dsPopRef();
	Long cond = dsPopInt4();
	if (cond != null) {
		Ref currCSF = getCurrCSF();   // may create if none found
		writeRef(currCSF + CSF_pc, addr);
	}

:OP_CALL
	Ref addr=dsPopRef();
	
	Ref currCSF = getCurrCSF();
	
	byte nextFrame = readByte(CS_NEXT_FRAME);
	writeByte(CS_NEXT_FRAME, nextFrame+1);
	
	Ref newCSF = getCurrCSF();
	byte tsNext = readByte(currCSF + CSF_tempStackNext);
	
	writeRef(newCSF + CSF_code, addr);
	writeByte(newCSF + CSF_tempStackBase, tsNext);
	writeByte(newCSF + CSF_tempStackNext, tsNext);
	writeRef(newCSF + CSF_pc, 0);
	
:OP_RETURN
	byte x = readByte(CS_NEXT_FRAME);
	writeByte(CS_NEXT_FRAME, x-1);
	
:OP_PANIC
	Ref word = dsPopRef();
	char *str = safeGetString(word);
	emitStr("PANIC ");
	emitStr(str);
	emitNewline();
	setPanicFlag();
	
:OP_HEAP_MAX
	dsPushInt2(getHeapSize());
			
:OP_TIBs
	dsPushInt1(getTIBsChar());
		
:OP_TIBr
	dsPushInt1(getTIBrChar());
	
:OP_TIBr_ADD
	advanceTIBr();
	
:OP_TIBs_ADD
	advanceTIBs();
	
:OP_TIBr_BACK
	resetTIBr();
	
:OP_TIBs_FWD
	confirmTIBr();
	
:OP_TIBW
	char *str = getTIBWord();
	Ref ref=getSymRef(str);
	dsPushRef(ref);
	
:OP_EMIT
	char c=dsPopInt1();
	emitChar(c);

:OP_EMITWORD
	Ref ref=dsPopRef();
	char *str = safeGetStr(ref);
	emitStr(str);
	
:OP_ADD
	Long b=dsPopInt4();
	Long a=dsPopInt4();
	dsPushInt4(a+b);
	
:OP_SUBTRACT
	Long b=dsPopInt4();
	Long a=dsPopInt4();
	dsPushInt4(a-b);

:OP_MUL
	Long b=dsPopInt4();
	Long a=dsPopInt4();
	dsPushInt4(a*b);
:OP_DIV
	Long b=dsPopInt4();
	Long a=dsPopInt4();
	dsPushInt4(a/b);

:OP_MOD
	Long b=dsPopInt4();
	Long a=dsPopInt4();
	dsPushInt4(a%b);

:OP_RIGHTSHIFT
	Long n=dsPopInt4();
	Long val=dsPopInt4();
	dsPushInt4(val >> n);

:OP_LEFTSHIFT
	Long n=dsPopInt4();
	Long val=dsPopInt4();
	dsPushInt4(val << n);

:OP_AND
	Long b=dsPopInt4();
	Long a=dsPopInt4();
	if (a & b != 0) dsPushInt4(F_TRUE); else dsPushInt4(F_FALSE);

:OP_OR
	Long b=dsPopInt4();
	Long a=dsPopInt4();
	if (a | b != 0) dsPushInt4(F_TRUE); else dsPushInt4(F_FALSE);

:OP_NOT
	Long val=dsPopInt4();
	dsPushInt4( ~val );
	
:OP_EQ
	Long b=dsPopInt4();
	Long a=dsPopInt4();
	if (a == b) dsPushInt4(F_TRUE); else dsPushInt4(F_FALSE);

:OP_NE
	Long b=dsPopInt4();
	Long a=dsPopInt4();
	if (a != b) dsPushInt4(F_TRUE); else dsPushInt4(F_FALSE);
	
:OP_GT
	Long b=dsPopInt4();
	Long a=dsPopInt4();
	if (a > b) dsPushInt4(F_TRUE); else dsPushInt4(F_FALSE);
	
:OP_LT
	Long b=dsPopInt4();
	Long a=dsPopInt4();
	if (a < b) dsPushInt4(F_TRUE); else dsPushInt4(F_FALSE);

:OP_GE
	Long b=dsPopInt4();
	Long a=dsPopInt4();
	if (a >= b) dsPushInt4(F_TRUE); else dsPushInt4(F_FALSE);

:OP_LE
	Long b=dsPopInt4();
	Long a=dsPopInt4();
	if (a <= b) dsPushInt4(F_TRUE); else dsPushInt4(F_FALSE);

:OP_DROP
	dsPopInt4();
	
:OP_SETLOCAL
	Long value=dsPopInt4();
	Ref sym=dsPopRef();
	setLocalValue(sym,value);
	
:OP_GETLOCAL
	Ref sym=dsPopRef();
	dsPushValue(getLocalValue(sym));
	
:OP_WORD
	// create word from substring of existing word
	Ref ref=dsPopRef();
	char *str=safeGetString(ref);
	addSymbol(str);
		
:OP_WRITE1
	Ref ref=dsPopRef();
	long val=dsPopInt4();
	writeByte(ref,val);
	
:OP_WRITE2
	Ref ref=dsPopRef();
	long val=dsPopInt4();
	write2(ref,val);
	
:OP_WRITE4
	Ref ref=dsPopRef();
	long val=dsPopInt4();
	write4(ref,val);
	
:OP_READ1
	Ref ref=dsPopRef();
	dsPushInt1(readInt1(ref));
	
:OP_READ2
	Ref ref=dsPopRef();
	dsPushInt2(readInt2(ref));
	
:OP_READ4
	Ref ref=dsPopRef();
	dsPushInt4(readInt4(ref));

:OP_READ1g
	Long addr=dsPopInt4();
	dsPushInt1(readGlobal(addr));
	
:OP_WRITE1g
	Long addr=dsPopInt4();
	Byte value=dsPopInt1();
	writeGlobal(addr,value);
	
:OP_LITERAL1
	dsPushInt1(nextByte());

:OP_LITERAL2
	a=nextByte();
	b=nextByte();
	dsPushInt2(a<<8 | b)
	
:OP_LITERAL4
	a=nextByte();
	b=nextByte();
	c=nextByte();
	d=nextByte();
	dsPushInt4(a<<24 | b<<12 | c<<8 | d)

:OP_CHECK_PARSE
	Ref symRef=dsPopRef();
	char *str = safeGetString(symRef);
	if (checkParseInt(str)) ds.pushValue(F_TRUE); else ds.pushValue(F_FALSE);
	
:OP_PARSE
	Ref symRef=dsPopRef();
	char *str = safeGetString(symRef);
	dsPushInt4(parseInt(str));

