# README
# --
<<< EOF
This test interpreter has no limits on the stacks or the heap. 
The goal is to validate the output from the Assembler.
>>> EOF
/Readme


# The interpreter
# --
	P(1) as String => hexString
	P(2) as int => numberLookupStart
	P(3) as int => symbolLookupStart

	# number of words
	DSTACK_WORDS = 20
	CSTACK_WORDS = 40  # callstack
	FSTACK_FRAMES = 10  # frame stack contains dictionaries
	
	self.WORDSIZE = 2
	self.memory=HWSim:Memory(self.WORDSIZE)
		
	self.globalVariableCount = 4
		# global variables, read with instruction 'global' and set with 'global!'
	
	# --- write the hex string into memory
	
	bytes = Util:HexToBytes(hexString)
	addr=self.memory.HERE
	error(addr != 0, "Invalid start address: " + addr)

	self.memory.malloc(bytes.length)
	bytes->b self.memory.writeByte(addr,b) addr=addr+1 |

	# -- store information about the imported hex string
	
	self.numberLookupStart=numberLookupStart
	self.symbolLookupStart=symbolLookupStart
	self.symbolLookupEnd=bytes.length

	self.PC=0
	self.haltFlag=false

		
	# --- create system data objects in memory
	
	# the data stack stores single words

	self.dbase=self.memory.HERE
	self.memory.mallocWords(DSTACK_WORDS)
	self.dataStack=HWSim:MemStack(self.memory, self.dbase, DSTACK_WORDS, "data")

	# the call stack stores single words
	
	self.cbase=self.memory.HERE
	self.memory.mallocWords(CSTACK_WORDS)
	self.callStack=HWSim:MemStack(self.memory, self.cbase, CSTACK_WORDS, "calls")

	# the frame stack stores frames as two words: base and size
	
	self.fbase=self.memory.HERE
	FSTACK_WORDS=FSTACK_FRAMES*2
	self.memory.mallocWords(FSTACK_WORDS)
	self.frameStack=HWSim:MemStack(self.memory, self.fbase, FSTACK_WORDS, "frames")

	# global variables
	self.globalVariablesBase=self.memory.HERE
	self.memory.mallocWords(self.globalVariableCount)
	
	# --- done with integrating code and setting up system structures on heap

	self.DATA_START=self.memory.HERE

	self.nextInstruction=Lambda{
		self.memory.readByte(self.PC)
	}


	# data stack
	self.push=Lambda{P(1)=>value self.dataStack.push(value)}
	self.pop=Lambda{self.dataStack.pop}


	# call stack
	self.cpush=Lambda{
		P(1) as int => value
		self.callStack.push(value)
		frameInfo=self.fpeek

		self.frameStack.pop
		self.frameStack.pop
		self.fpush(frameInfo.base, frameInfo.size+1)
	}

	# frame stack
	
	self.fpush = Lambda{
		P(1) as int => base
		P(2) as int => size
		self.frameStack.push(base)
		self.frameStack.push(size)
	}

	self.fpeek = Lambda {
		size=self.frameStack.pop
		base=self.frameStack.peek
		self.frameStack.push(size)
		SymDict(base,size)
	}

	self.fpop = Lambda{
		self.frameStack.pop
		self.frameStack.pop
	}

	# initialize frame stack these numbers are offsets on the callStack

	self.fpush(0,0)


	self.executionCount=1
	self.executeInstruction=Lambda{

		pc = self.PC
		
		instr=self.memory.readByte(self.PC)
		if (instr < 32) {
			# reserved
			error("Reserved instruction: " + instr)
		} else if (instr > 127) {
			# constant number lookup
			index=instr-128
			addr=self.numberLookupStart+(index*self.WORDSIZE)
			value=self.memory.readWord(addr)
			#println("[" + instr + "] push 0x" + value.hex(4).toUpper)
			self.push(value)
		} else {
			instr=Sys.uchar(instr)
			lambdaName="_"+instr
			
			error(!self.has(lambdaName), "Unknown instruction lambda '" + lambdaName + "'") 

			closure = self.get(lambdaName)
			result = tryCatch(closure.call)
			
			if (!result.ok) {
				error ("Execution failed: " 
				+ " lambdaName=" + lambdaName 
				+ " msg=" + result.get("msg","(no message)")
				+ " PC=" + pc
				+ " count=" + self.executionCount)
			}
		}
		
		# Executed ok, now update PC unless a jump has already moved it
		if (self.PC == pc) {
			self.PC=pc+1
		}
		self.executionCount=self.executionCount+1
	}

	self._k=Lambda{ # wordsize ( -- N )
		self.push(self.WORDSIZE)
	}
	self._K=Lambda{ # allot  ( N -- )
		byteCount=self.pop
		self.memory.malloc(byteCount)
	}
	self._G=Lambda{ # readb read byte ( addr -- value )
		addr=self.pop
		if (addr < self.DATA_START) println("Warning: readb: reading below DATA_START: 0x" + addr.hex(4).toUpper)
		self.push(self.memory.readByte(addr))
	}
	self._H=Lambda{ # writeb write byte ( addr -- value )
		addr=self.pop
		if (addr < self.DATA_START) println("ERROR: writeb: writing below DATA_START: 0x" + addr.hex(4).toUpper)
		value=self.pop
		self.memory.writeByte(addr,value)
	}


	## Local variable instructions a-f

	self._a=Lambda{  # a read local variable a ( -- value )
		frameInfo=self.fpeek
		base=(self.cbase + (frameInfo.base*self.WORDSIZE))
		value=self.memory.readWord(base)
		self.push(value)
	}
	self._b=Lambda{  # b read local variable b ( -- value )
		frameInfo=self.fpeek
		base=(self.cbase + (frameInfo.base*self.WORDSIZE))
		value=self.memory.readWord(base+self.WORDSIZE)
		self.push(value)
	}
	self._c=Lambda{  #  c read local variable c ( -- value )
		frameInfo=self.fpeek
		base=(self.cbase + (frameInfo.base*self.WORDSIZE))
		value=self.memory.readWord(base+self.WORDSIZE*2)
		self.push(value)
	}
	self._d=Lambda{  # a! set local variable a ( value -- )
		value=self.pop
		frameInfo=self.fpeek
		base=(self.cbase + (frameInfo.base*self.WORDSIZE))
		self.memory.writeWord(base, value)
	}
	self._e=Lambda{  # b! set local variable b ( value -- )
		value=self.pop
		frameInfo=self.fpeek
		base=(self.cbase + (frameInfo.base*self.WORDSIZE))
		self.memory.writeWord(base+self.WORDSIZE, value)
	}
	self._f=Lambda{ # c! set local variable c ( value -- )
		value=self.pop
		frameInfo=self.fpeek
		base=(self.cbase + (frameInfo.base*self.WORDSIZE))
		self.memory.writeWord(base+self.WORDSIZE*2, value)
	}

	self.set("_+", Lambda{self.push(self.pop+self.pop)}) # add ( a b -- a+b )
	self.set("_-", Lambda{b=self.pop a=self.pop self.push(a-b)}) # sub ( a b -- a-b )
	self.set("_*", Lambda{b=self.pop a=self.pop self.push(a*b)}) # mul ( a b -- a*b )
	self.set("_/", Lambda{b=self.pop a=self.pop self.push((a/b).i)}) # div ( a b -- a/b )
	self.set("_<", Lambda{b=self.pop a=self.pop value=if(a<b,1,0) self.push(value)}) # lt ( a b -- 0|1 )
	self.set("_=", Lambda{b=self.pop a=self.pop value=if(a==b,1,0) self.push(value)}) # eq ( a b -- 0|1 )
	self.set("_>", Lambda{b=self.pop a=self.pop value=if(a>b,1,0) self.push(value)}) # gt ( a b -- 0|1 )
	self._h=Lambda{	# ne boolean ( a b -- 0|1 )
		b=self.pop a=self.pop value=if(a!=b,1,0) self.push(value)
	}
	self._i=Lambda{ # not boolean ( x -- 0|1 )
		a=self.pop value=if(a==0,1,0) self.push(value)
	}
	
	self._g=Lambda{self.push(self.memory.HERE)}   # HERE ( -- value )
	
	self.set("_&", Lambda{b=self.pop a=self.pop value=if(a != 0 && b != 0, 1, 0) self.push(value)}) # and boolean ( a b -- 0|1 )
	self.set("_|", Lambda{b=self.pop a=self.pop value=if(a != 0 || b != 0, 1, 0) self.push(value)}) # or boolean ( a b -- 0|1 )
	
	self._S=Lambda{   # jmp ( addr -- ) updates PC
		self.PC=self.pop
	}
	self._T=Lambda{  # jmp? ( cond addr -- ) conditionally updates PC
		addr=self.pop 
		cond=self.pop 
		if(cond != 0) self.PC=addr  
	}  
	
	self._Q=Lambda{  # call ( addr -- )
		targetAddr=self.pop
		returnAddr=self.PC+1 # following call

		self.cpush(returnAddr)
		currFrame=self.fpeek

		frameInfo=Dict.set("base",currFrame.base+currFrame.size).set("size",0)
			# currFrame.size will be at least 1 after we pushed return address

		base=currFrame.base+currFrame.size
		size=0
		self.fpush(base,size)

		self.PC=targetAddr # JMP
	}
	self._R=Lambda{  # ret return
		self.fpop

		frameInfo=self.fpeek  # previous frame

		# resetting callstack as it were before call
		self.callStack.setNext(frameInfo.base + frameInfo.size) 
	
		# popping the jump address
		targetAddr=self.callStack.pop

		# must update the frameInfo about having popped the PC from the callStack
		base=frameInfo.base
		size=frameInfo.size-1
		self.fpop
		self.fpush(base,size)

		self.PC=targetAddr # JMP
	}
	
	self._I=Lambda{  # @ read word
		addr=self.pop
		if (addr < self.DATA_START) println("Warning: @: reading below DATA_START: 0x" + addr.hex(4).toUpper)
		self.push(self.memory.readWord(addr))
	}
	
	self._J=Lambda{  # ! write word
		addr=self.pop
		if (addr < self.DATA_START) println("ERROR: !: writing below DATA_START: 0x" + addr.hex(4).toUpper)
		value=self.pop
		self.memory.writeWord(addr,value)
	}

	self._O=Lambda{  # cpush push value from data stack on call stack ( x -- )
		self.cpush(self.pop)
	}

	self._M=Lambda{ # dcopy: ( a b c 1 -- a b c b )
		offset=self.pop
		value=self.dataStack.getValue(offset)
		self.push(value)
	}

	self._N=Lambda{ # dget: (a b c 1 -- a c b)
		offset=self.pop
		value=self.dataStack.removeValue(offset)
		self.push(value)
	}

	self._j=Lambda { # drop  ( a -- )
		self.pop
	}
	
	self._l=Lambda{ # dup ( x -- x x )
		value=self.pop
		self.push(value)
		self.push(value)
	}
	
	self._m=Lambda{ # swap ( a b -- b a )
		a=self.pop
		b=self.pop
		self.push(a)
		self.push(b)
	}
	
	self._n=Lambda{ # W+   ( n -- n+WORDSIZE )
		value=self.pop
		self.push(value+self.WORDSIZE)
	}

	self._o=Lambda{ # over ( a b -- a b a )
		b=self.pop
		a=self.pop
		self.push(a)
		self.push(b)
		self.push(a)
	}

	self._p=Lambda{ # dump show stack contents ( -- )

		println("Datastack BOTTOM ---> TOP")

		values=self.dataStack.getStackValues 
		values->x
			s=("    "+x).last(5)+" "
			print(s)
		|
		println

		values->x
			s=("    x"+x.hex).last(5)+" "
			print(s)
		|

		println
	}

	self._V=Lambda{ # show ( sym sym ... count -- )
		count=self.pop  # number of symbols

		Std.Data.for(0,count,1)->i
			out(self.pop)
		| _.reverse -> symbolRelativePos
			symbolAddr=self.symbolLookupStart + symbolRelativePos
			error(symbolAddr > self.symbolLookupEnd - self.WORDSIZE, "Invalid symbol lookup address: " + symbolAddr)
			
			self.memory.readChar(symbolAddr) => h
			self.memory.readChar(symbolAddr+1) => l
			(h+l).parseInt(16)=>length
			# read characters
			Inner{
				Std.Data.for(0,length,1)->pos
					ch=self.memory.readChar(symbolAddr+2+pos)  # +2 skip hl
					out(ch)
				| _.concat
			} => symbol
			print(symbol)
			print(" ")
	}
	self._W=Lambda{ # print print top value on hex format
		value=self.pop
		print("0x" + value.hex(4).toUpper)
		print(" ")
	}
	self._Y=Lambda{ # print# print top value on decimal format
		value=self.pop
		print(value)
		print(" ")
	}
	self._L=Lambda{ # printb print top value on binary format
		value=self.pop
		s=value.bin(self.WORDSIZE*8)
		print(s.sub(0,8)+"_"+s.sub(8))
		print(" ")
	}
	self._X=Lambda{ # cr print newline
		println
	}

	self._q=Lambda { # andb binary and ( a b -- c )
		b=self.pop
		a=self.pop
		self.push(HWSim:BitwiseAnd(a,b,self.WORDSIZE))	
	}

	self._r=Lambda { # orb binary or ( a b -- c )
		b=self.pop
		a=self.pop
		self.push(HWSim:BitwiseOr(a,b,self.WORDSIZE))	
	}
	self._s=Lambda{ # inv binary not  ( a -- b )
		a=self.pop
		self.push(HWSim:BitwiseNot(a, self.WORDSIZE))
	}
	self._t=Lambda { # << left shift  ( val n -- val )
		bits=self.pop
		value=self.pop
		self.push(HWSim:Leftshift(value, bits, self.WORDSIZE))
	}
	self._u=Lambda { # >> right shift  ( val n -- val )
		bits=self.pop
		value=self.pop
		self.push(HWSim:Rightshift(value, bits, self.WORDSIZE))
	}
	
	self._x=Lambda { # global - get global variable ( N -- value)
		n=self.pop
		error(n<0 || n>=self.globalVariableCount, "global: invalid reference: " + n)
		addr=self.globalVariablesBase + n*2
		self.push(self.memory.readWord(addr))
	}
	self._z=Lambda { # global! - set global variable ( value N -- )
		n=self.pop
		value=self.pop
		error(n<0 || n>=self.globalVariableCount, "global!: invalid reference: " + n)
		addr=self.globalVariablesBase + n*2
		self.memory.writeWord(addr, value)
	}
	self._Z=Lambda{  # halt - terminate execution
		self.haltFlag=true
	}

/class Interpreter



# Show frame stack
# --
	P(1) as &MemStack => frameStack

	# pair two values
	count=0
	frameStack.getStackValues->value
		count=count+1
		if (count % 2 == 0) out(":") else out(" ")
		out(value)
	| _.concat
//ShowFrameStack


# Show word stack
# --
	P(1) as &MemStack => stack
	stack.getStackValues->value
		out(value.hex(4).toUpper)
	| _.concat(" ")
//ShowWordStack


# Read address
# --
	Input("Enter address hex NNNN or decimal #NNNN").get =>addr
	if (addr.startsWith("#")) {
		addr.after("#").parseInt(10)
	} else if (addr.startsWith("0x") || addr.startsWith("x")) {
		addr.after("x").parseInt(16)
	} else {
		addr.parseInt(16)
	}
//ReadAddress

		

# Test
# --
	dict = Db2:Get("RForth","data")
	hexBlock=dict.hexBlock
	numbersStart=dict.numbersStart
	symbolsStart=dict.symbolsStart
	tags=dict.tags
	tagListSorted=dict.tagListSorted
	metaInfo=dict.metaInfo
	
	iCount=0
	autoRunCount=0

	interpreter=Interpreter(hexBlock, numbersStart, symbolsStart)

	loop
		if (interpreter.haltFlag) {
			if (autoRunCount>0) {
				println
				Lib:Header("haltFlag set, stopping automatic execution, then resetting it")
				autoRunCount=0
			} else {
				println
				println("haltFlag detected, resetting it")
				println
			}
			interpreter.haltFlag=false
		}
		if (autoRunCount > 0) {
			interpreter.executeInstruction
			iCount=iCount+1
			autoRunCount=autoRunCount-1
			continue
		}
			
		instr=interpreter.nextInstruction
		instrName=instr
		if (instr >= 33 && instr <= 127) {
			instr=Sys.uchar(instr)
			instrName=Assembler:InstructionsLookup.get(instr)
			
		}
		
		println
		# show dataStack
		println("dataStack  0x" + interpreter.dbase.hex(4) + " [ " + ShowWordStack(interpreter.dataStack) + " ] TOP")
		# show callStack
		println("callStack  0x" + interpreter.cbase.hex(4) + " [ " + ShowWordStack(interpreter.callStack) + " ] TOP")
		# show frameStack
		println("frameStack 0x" + interpreter.fbase.hex(4) + " [ " + ShowFrameStack(interpreter.frameStack) + " ] TOP")
		println("HERE = 0x" + interpreter.memory.HERE.hex(4).toUpper +  " (" + interpreter.memory.HERE + ")")
		println
		println("#" + iCount, 
			"PC:", "0x" + ("0000"+interpreter.PC.hex.toUpper).last(4), 
			instrName)
		
		println
		command=readLine("Command: 'q' to quit, 'i' to inspect, 'w' read word, 'r' to run, ENTER to continue").trim
		if(command=="q") {
			break
		} else if (command=="i") {
			addr=ReadAddress
			interpreter.showMem(addr)
		} else if (command=="w") {
			addr=ReadAddress
			value=interpreter.memory.readWord(addr)
			println("=> " + value + " x" + value.hex)
		} else if (command=="r") {
			Input("Enter number of instructions to run").get.parseInt => autoRunCount
		} else if (command.trim=="") {
			interpreter.executeInstruction
			iCount=iCount+1
		}
		
		 
/t		
	
