


# Example code
# --
	Sys.savefile.dir.file("ACode.txt").read
/ExampleCode


# Check for risky tagging such as creating tag when meaning to refer to it
# --
	num=0
	ExampleCode->line
		if (line.contains(":") || line.contains("&")) report(num,line)
		num=num+1
/ShowTagUse


# List all instructions, both actual and inline's
# --
	P(1,true) => includeInlines
	names=Instructions.keys
	if (includeInlines) names=names+Inlines.keys
	
	names.sort
/IShow


# Show instructions lookup sorted
# --
	data=InstructionsLookup
	data.keys.sort->key
		report(key,data.get(key))
/IRShow
		
		



# Assembly instructions mapped to "machine code"
# --
<<< EOF
	;; memory and registers
	readb		:G		;; read byte
	writeb		:H		;; write byte
	@		:I		;; read cell/word
	!		:J		;; write cell/word	
	allot		:K
	memcpy		:L
	HERE		:g

	;; data stack operations
	dcopy		:M		;; copy stack element n, where 0 is top etc, to top, so #1 dcopy is DUP
	dget		:N      ;; remove stack element n and push on top
	drop		:j		;; remove stack top element

	;;dup				;; inline: #0 dcopy
	;;swap				;; inline: #1 dget
	;;over				;; inline: #1 dcopy
	;;rot				;; inline: #2 dcopy
	;;2dup				;; inline: over over
	
	;; Both dStack and cstack must grow upwards in memory, containing words only, for
	;; predictable address calculations

	;; call stack: note that "marks" are separate (hidden) structure, not physical on the 
	;; visible call stack
	cpush		:O   ;; push N values from data stack to callstack in same order (abc->abc) - the first 6 values (word) are local variables a-f
	cbase		:P   ;; get address to base of current call stack frame (call frame stack) 

	call		:Q   ;; push PC+1 on callStack, then add mark (call frame stack), before jmp to address on dstack
	ret			:R	 ;; cbase-1 locate return address, then pop mark from 

	;; the call stack contains local variables + the return PC when calling something. 
	;; the callFrame stack contains two values; the base of the current frame on the call stack
	;;		and the number of words pushed with cpush, identifying top-of-stack for callStack

	;; local variable pointer instructions

	a		:a
	b		:b
	c		:c
	d		:d
	e		:e
	f		:f
	
	;; math (note x0-9A-F are not included)
	add		:+
	sub		:-
	mul		:*
	div		:/
	zero	:x   		;; push zero on stack
	0		:0
	1		:1
	2		:2
	3		:3
	4		:4
	5		:5
	6		:6
	7		:7
	8		:8
	9		:9
	A		:A
	B		:B
	C		:C
	D		:D
	E		:E
	F		:F

	;; logical operations
	eq		:=
	ne		:h
	gt		:>
	lt		:<
	not		:i
	and		:&	;; logical 
	or		:|	;; logical

	;; flow of control
		
	jmp		:S
	jmp?	:T   ;; conditional jump on true'	
	PC		:U   ;; puts PC on stack (as it was when invoking this instruction)
	
	;; I/O
	show		:V   ;; ( ptr ptr ... N -- ) - display N symbols with space between them
	print		:W   ;; print any single value 
	cr			:X
		
>>> EOF
	=>list
	
	dict=Dict
	values="" 
	
	list->rawLine
		line=rawLine.before(";")
		assert(line.trim.length>0)
		line.split(":")=>parts
		
		token=parts.first.trim
		value=parts.last.trim
		error(values.contains(value),"Duplicate machine instruction: " + value)
		
		dict.set(token,value)
		values=values+value
	|
	dict
//Instructions


# Debug mode?
# --
	Db2:Get(Sys.scriptId,"debug",false)
//IsDebug

# Flip debug mode
# --
	Db2:Set(Sys.scriptId,"debug", !IsDebug)
	IsDebug
/Debug


# Inline defs
# --
	Dict
	.set("WORDSIZE",Sequence(
		@ x2
	))

	# stack manipulation
	.set("dup",List("#0 dcopy"))
	.set("swap",List("#1 dget"))
	.set("over",List("#1 dcopy"))
	.set("rot",List("#2 dget"))
	.set("2dup",List("over over"))

	
	## CONS tuples
	.set("CDR",Sequence(
		@ WORDSIZE add
	))
	
//Inlines



# Word generator for source, for handling inlines (via push)
# --
	self.words=List
	self.push = Lambda{
		P(1) as List => lines
		words=Inner{
			lines->line
				#println(line)
				line.trim.before(";").split->word
					out(word.trim)
		}
		self.words=words+self.words
	}
	self.getWord = Lambda{
		if(self.words.empty) {
			null
		} else {
			self.words.first => word
			self.words=self.words.keep(1)
			if (IsDebug) println("getWord",word)
			word
		}
	}
/class Words
	

# Assemble input to "machine code" format
# --
	P(1,ExampleCode) => code
	
	currentTag="<DEFAULT>"
	
	words=Words
	words.push(code)

	instructions=Instructions
	inlines=Inlines

	tags=Dict
			
	result=""
	
	patchList=List
	symbolList=List
	
	loop
		word=words.getWord
		break(word==null)
		
		# inlines
		if (inlines.has(word)) {
			#println("Inline",word)
			words.push(inlines.get(word))
			continue
		}
		
	
		# specials
		
		# -- hex format number
		if (word.startsWith("x")) {
			result=result + "x" + word.after("x").parseInt(16).hex.toUpper
			continue
		}
		
		# -- decimal format numbers
		if (word.startsWith("#")) {
			s="x" + word.after("#").parseInt.hex.toUpper
			println(s)
			result=result+s
			continue
		}
		
		# -- symbol
		if (word.startsWith("'")) {
			symbol=word.after("'")
			patchPos=result.length
			symbolList.add(SymDict(symbol,patchPos))
			words.push(List("x0000 tSymbol"))
			continue
		}
		# -- local tag def
		if (word.startsWith(":*")) {
			tag=currentTag + "." + word.after(":*")
			pos=result.length
			pos=("0000"+pos.hex).last(4).toUpper
			pos="x"+pos
			tags.set(tag,pos)
			println(":"+tag,pos)
			continue
		}
		# -- global tag def
		if (word.startsWith(":")) {
			tag=word.after(":")
			pos=("0000"+result.length.hex).last(4).toUpper
			pos="x"+pos
			tags.set(tag,pos)
			println(":"+tag, pos)
			
			currentTag=tag
			continue
		}

		# -- local tag reference
		if (word.startsWith("&*")) {
			tag=currentTag + "." + word.after("&*")

			# generate dummy to be patched
			name=tag
			patchPos=result.length
			patchList.add(SymDict(name,patchPos))
			
			result=result+"x0000"  # dummy
			continue
		}
		# -- get global tag value
		if (word.startsWith("&")) {
			tag=word.after("&")

			# generate dummy to be patched
			name=tag
			patchPos=result.length
			patchList.add(SymDict(name,patchPos))
			result=result+"x0000"  # dummy
			continue
		}
			
		# look up word in instructions map or fail
		if (instructions.has(word)) result=result+instructions.get(word)
		else error("Unknown word: '" + word + "'")
	|
	
	# Now patch the missing tag references in the result string
	patchList->patch
		name=patch.name
		patchPos=patch.patchPos
		
		error(!tags.has(name), "Unknown tag: " + name)
		# replace digits+1 characters at patchPos with xNN or xNNNN
		address=tags.get(name)
		result=result.sub(0,patchPos) + address + result.sub(patchPos+address.length)
	|
		
		
	# Now allocate data elements (symbols) 
	symbols=Dict # store each symbol only once
	
	symbolList->data
		symbol = data.symbol
		patchPos = data.patchPos
		
		pos=result.length
		if (symbols.has(symbol)) {
			pos=symbols.get(symbol)
		} else {
			# add symbol to result (on readable format, wasting one byte for the length)
			result=result+("00"+symbol.length.hex.toUpper).last(2)
			result=result+symbol
			# store in symbol dictionary
			symbols.set(symbol,pos)
		}
		
		address="x" + ("0000"+pos.hex.toUpper).last(4)
		# insert address at patchPos

		result=result.sub(0,patchPos) + address + result.sub(patchPos+address.length)
	|
	
	# identify address of tag DATA
	tags.get("DATA").after("x").parseInt(16) => dataStart

	SymDict(result,dataStart,tags)
/Assemble


# Create instructions lookup dictionary
# (Reverse of the Instructions dict)
# --
	dict=Dict
	instr=Instructions
	instr.keys->key
		value=instr.get(key)
		dict.set(value,key)
	|
	dict
//InstructionsLookup


# Disassembler
# --
	P(1) as Dict => dict
	
	code=dict.result
	dataStart=dict.dataStart
		
	lookup=InstructionsLookup
	
	pos=0
	code.chars->c
		if (pos==dataStart) println("--- DATA ---")
		
		print(("0000"+pos.hex.toUpper).last(4)+" ")

		if (pos >= dataStart) {
			println(c)
			pos=pos+1
			continue
		}
					
		if ("0123456789ABCDEFx".contains(c)) {
			println(c)
		} else {
			if (lookup.has(c)) println(lookup.get(c))
			else error("Unknown instruction '" + c + "'")
		}
		pos=pos+1
/Disassemble
			
	

# Test by assembling ACode.txt, then disassembling it
# --
	Assemble => dict
	println(dict.result)
	Disassemble(dict)
	
	# Display all tags
	Lib:Header("Tags")
	Inner{
		dict.tags.keys->tag
			#println("tag",tag)
			dict.tags.get(tag) => addr
			#println("addr",addr)
			out(Str(addr,tag))
		| _.sort->x
			tag=x.data
			report(tag,dict.tags.get(tag))
		| _=>rows
		Lib:ShowRows(rows, null, false)
	}
	

	# Display code as block that can be copy-pasted
	Lib:Header("Code")
	Inner{
		s=dict.result
		loop
			if (s.length > 70) {
				println(s.sub(0,70))
				s=s.sub(70)
				continue
			} else {
				println(s)
				break
			}
	}
	println
	println(dict.result.length,"bytes")
	
/t
	

