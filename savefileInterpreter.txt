
# The interpreter
# --
	P(1) as String => hexString
	P(2) as int => symbolsStart

	Term.wrap(true)			# to see full error listings
	
	# number of words
	DSTACK_WORDS = 20
	CSTACK_WORDS = 50  # callstack
	FSTACK_FRAMES = 20  # frame stack contains dictionaries
	
	self.WORDSIZE = 2
	self.memory=HWSim:Memory(self.WORDSIZE)
		
	self.globalVariableCount = 8
		# global variables, read with instruction 'global' and set with 'global!'
	
	# --- write the hex string into memory
	
	bytes = Util:HexToBytes(hexString)
	addr=self.memory.HERE
	error(addr != 0, "Invalid start address: " + addr)

	self.memory.malloc(bytes.length)
	bytes->b self.memory.writeByte(addr,b) addr=addr+1 |

	# -- store information about the imported hex string
	
	self.symbolsStart=symbolsStart
	self.symbolLookupEnd=bytes.length

	self.PC=0
	self.haltFlag=false
	
	# --- output 

	self.outputLines=List("")

	self.addOutputText = Lambda{
		P(1) as String => s
		
		currOutputLine=self.outputLines.last
		index=self.outputLines.length-1
		updatedLine = currOutputLine + s
		self.outputLines.set(index,updatedLine)
	}
	self.addOutputCR = Lambda {
		self.outputLines.add("")
	}

	self.printString = Lambda{
		P(1) as int => addr
		length=self.memory.readByte(addr)
		Std.Data.for(0,length,1)->i
			out(Sys.uchar(self.memory.readByte(addr+1+i)))
		| _.concat => str
		self.addOutputText(str)
	}
		
	# --- create system data objects in memory
	
	# the data stack stores single words

	self.dbase=self.memory.HERE
	self.memory.mallocWords(DSTACK_WORDS)
	self.dataStack=HWSim:MemStack(self.memory, self.dbase, DSTACK_WORDS, "data")

	# the call stack stores single words
	
	self.cbase=self.memory.HERE
	self.memory.mallocWords(CSTACK_WORDS)
	self.callStack=HWSim:MemStack(self.memory, self.cbase, CSTACK_WORDS, "calls")

	# the frame stack stores frames as two words: base and size
	
	self.fbase=self.memory.HERE
	FSTACK_WORDS=FSTACK_FRAMES*2
	self.memory.mallocWords(FSTACK_WORDS)
	self.frameStack=HWSim:MemStack(self.memory, self.fbase, FSTACK_WORDS, "frames")

	# global variables

	self.globalVariablesBase=self.memory.HERE
	self.memory.mallocWords(self.globalVariableCount)
	
	# --- done with integrating code and setting up system structures on heap

	self.DATA_START=0  	# no protection

	self.nextInstruction=Lambda{
		self.memory.readByte(self.PC)
	}


	# data stack
	self.push=Lambda{P(1)=>value self.dataStack.push(value)}
	self.pop=Lambda{self.dataStack.pop}


	# call stack
	self.cpush=Lambda{
		P(1) as int => value
		self.callStack.push(value)
		frameInfo=self.fpeek

		self.frameStack.pop
		self.frameStack.pop
		self.fpush(frameInfo.base, frameInfo.size+1)
	}

	# frame stack
	
	self.fpush = Lambda{
		P(1) as int => base
		P(2) as int => size
		self.frameStack.push(base)
		self.frameStack.push(size)
	}

	self.fpeek = Lambda {
		size=self.frameStack.pop
		base=self.frameStack.peek
		self.frameStack.push(size)
		SymDict(base,size)
	}

	self.fpop = Lambda{
		self.frameStack.pop
		self.frameStack.pop
	}

	# initialize frame stack these numbers are offsets on the callStack

	self.fpush(0,0)


	self.executionCount=0
	self.executeInstruction=Lambda{

		pc = self.PC
		
		instr=self.memory.readByte(self.PC)
		if (instr < 32) {
			# reserved
			error("ERROR: Reserved instruction: " + instr)
		} else if (instr > 127) {
			# encoded number literal in 6 lowest bits
			if (instr.bin(8).chars.get(1)=="1") {
				self.push(0)
			}
			value=self.pop
			value=value*64 + (instr.bin(8).last(6).parseInt(2))
			self.push(value)
		} else {
			instr=Sys.uchar(instr)
			lambdaName="_"+instr
			
			error(!self.has(lambdaName), "Unknown instruction lambda '" + lambdaName + "'") 

			closure = self.get(lambdaName)
			result = tryCatch(closure.call)
			
			if (!result.ok) {
				error ("Execution failed: " 
				+ " lambdaName=" + lambdaName 
				+ " msg=" + result.get("msg","(no message)")
				+ " PC=" + pc.hex(4)
				+ " count=" + self.executionCount)
			}
		}
		
		# Executed ok, now update PC unless a jump has already moved it
		if (self.PC == pc) {
			self.PC=pc+1
		}
		self.executionCount=self.executionCount+1
	}

	self._k=Lambda{ # wordsize ( -- N )
		self.push(self.WORDSIZE)
	}
	self._K=Lambda{ # allot  ( N -- )
		byteCount=self.pop
		self.memory.malloc(byteCount)
	}
	self._G=Lambda{ # readb read byte ( addr -- value )
		addr=self.pop
		self.push(self.memory.readByte(addr))
	}
	self._H=Lambda{ # writeb write byte ( addr -- value )
		addr=self.pop
		if (addr < self.DATA_START) error("writeb: writing below DATA_START: 0x" + addr.hex(4))
		value=self.pop
		self.memory.writeByte(addr,value)
	}


	## Local variable instructions a-f

	self._a=Lambda{  # a read local variable a ( -- value )
		frameInfo=self.fpeek
		base=(self.cbase + (frameInfo.base*self.WORDSIZE))
		value=self.memory.readWord(base)
		self.push(value)
	}
	self._b=Lambda{  # b read local variable b ( -- value )
		frameInfo=self.fpeek
		base=(self.cbase + (frameInfo.base*self.WORDSIZE))
		value=self.memory.readWord(base+self.WORDSIZE)
		self.push(value)
	}
	self._c=Lambda{  #  c read local variable c ( -- value )
		frameInfo=self.fpeek
		base=(self.cbase + (frameInfo.base*self.WORDSIZE))
		value=self.memory.readWord(base+self.WORDSIZE*2)
		self.push(value)
	}
	self._d=Lambda{  # a! set local variable a ( value -- )
		value=self.pop
		frameInfo=self.fpeek
		base=(self.cbase + (frameInfo.base*self.WORDSIZE))
		self.memory.writeWord(base, value)
	}
	self._e=Lambda{  # b! set local variable b ( value -- )
		value=self.pop
		frameInfo=self.fpeek
		base=(self.cbase + (frameInfo.base*self.WORDSIZE))
		self.memory.writeWord(base+self.WORDSIZE, value)
	}
	self._f=Lambda{ # c! set local variable c ( value -- )
		value=self.pop
		frameInfo=self.fpeek
		base=(self.cbase + (frameInfo.base*self.WORDSIZE))
		self.memory.writeWord(base+self.WORDSIZE*2, value)
	}

	self.set("_+", Lambda{self.push(self.pop+self.pop)}) # add ( a b -- a+b )
	self.set("_-", Lambda{b=self.pop a=self.pop self.push(a-b)}) # sub ( a b -- a-b )
	self.set("_*", Lambda{b=self.pop a=self.pop self.push(a*b)}) # mul ( a b -- a*b )
	self.set("_/", Lambda{b=self.pop a=self.pop self.push((a/b).i)}) # div ( a b -- a/b )
	self.set("_<", Lambda{b=self.pop a=self.pop value=if(a<b,1,0) self.push(value)}) # lt ( a b -- 0|1 )
	self.set("_=", Lambda{b=self.pop a=self.pop value=if(a==b,1,0) self.push(value)}) # eq ( a b -- 0|1 )
	self.set("_>", Lambda{b=self.pop a=self.pop value=if(a>b,1,0) self.push(value)}) # gt ( a b -- 0|1 )
	self._h=Lambda{	# ne boolean ( a b -- 0|1 )
		b=self.pop a=self.pop value=if(a!=b,1,0) self.push(value)
	}
	self._i=Lambda{ # not boolean ( x -- 0|1 )
		a=self.pop value=if(a==0,1,0) self.push(value)
	}
	self._E=Lambda{ # ge ( a b -- 0|1 )
		b=self.pop
		a=self.pop
		if (a>=b) self.push(1) else self.push(0)
	}
	self._F=Lambda{ # le ( a b -- 0|1 )
		b=self.pop
		a=self.pop
		if (a<=b) self.push(1) else self.push(0)
	}
	
	self._g=Lambda{self.push(self.memory.HERE)}   # HERE ( -- value )
	
	self.set("_&", Lambda{b=self.pop a=self.pop value=if(a != 0 && b != 0, 1, 0) self.push(value)}) # and boolean ( a b -- 0|1 )
	self.set("_|", Lambda{b=self.pop a=self.pop value=if(a != 0 || b != 0, 1, 0) self.push(value)}) # or boolean ( a b -- 0|1 )
	
	self._S=Lambda{   # jmp ( addr -- ) updates PC
		self.PC=self.pop
	}
	self._T=Lambda{  # jmp? ( cond addr -- ) conditionally updates PC
		addr=self.pop 
		cond=self.pop 
		if(cond != 0) self.PC=addr  
	}  
	
	self._Q=Lambda{  # call ( addr -- )
		targetAddr=self.pop
		returnAddr=self.PC+1 # following call

		self.cpush(returnAddr)
		currFrame=self.fpeek

		frameInfo=Dict.set("base",currFrame.base+currFrame.size).set("size",0)
			# currFrame.size will be at least 1 after we pushed return address

		base=currFrame.base+currFrame.size
		size=0
		self.fpush(base,size)

		self.PC=targetAddr # JMP
	}
	self._R=Lambda{  # ret return
		self.fpop

		frameInfo=self.fpeek  # previous frame

		# resetting callstack as it were before call
		self.callStack.setNext(frameInfo.base + frameInfo.size) 
	
		# popping the jump address
		targetAddr=self.callStack.pop

		# must update the frameInfo about having popped the PC from the callStack
		base=frameInfo.base
		size=frameInfo.size-1
		self.fpop
		self.fpush(base,size)

		self.PC=targetAddr # JMP
	}
	
	self._I=Lambda{  # @ read word
		addr=self.pop
		self.push(self.memory.readWord(addr))
	}
	
	self._J=Lambda{  # ! write word
		addr=self.pop
		if (addr < self.DATA_START) error("!: writing below DATA_START: 0x" + addr.hex(4))
		value=self.pop
		self.memory.writeWord(addr,value)
	}

	self._O=Lambda{  # cpush push value from data stack on call stack ( x -- )
		self.cpush(self.pop)
	}

	self._M=Lambda{ # dcopy: ( a b c 1 -- a b c b )
		offset=self.pop
		value=self.dataStack.getValue(offset)
		self.push(value)
	}

	self._N=Lambda{ # dget: (a b c 1 -- a c b)
		offset=self.pop
		value=self.dataStack.removeValue(offset)
		self.push(value)
	}

	self._j=Lambda { # drop  ( a -- )
		self.pop
	}
	
	self._l=Lambda{ # dup ( x -- x x )
		value=self.pop
		self.push(value)
		self.push(value)
	}
	
	self._m=Lambda{ # swap ( a b -- b a )
		a=self.pop
		b=self.pop
		self.push(a)
		self.push(b)
	}
	
	self._n=Lambda{ # W+   ( n -- n+WORDSIZE )
		value=self.pop
		self.push(value+self.WORDSIZE)
	}

	self._o=Lambda{ # over ( a b -- a b a )
		b=self.pop
		a=self.pop
		self.push(a)
		self.push(b)
		self.push(a)
	}

	self._p=Lambda{ # dump show stack contents ( -- )

		println("Datastack BOTTOM ---> TOP")

		values=self.dataStack.getStackValues 
		values->x
			s=("    "+x).last(5)+" "
			print(s)
		|
		println

		values->x
			s=("    x"+x.hex).last(5)+" "
			print(s)
		|

		println
	}
	
	self._V=Lambda{ # show ( sym sym ... count -- )
		count=self.pop  # number of strings

		Std.Data.for(0,count,1)->i
			out(self.pop)
		| _.reverse -> addr
			length=self.memory.readByte(addr)
			
			# read characters
			Inner{
				Std.Data.for(0,length,1)->pos
					ch=self.memory.readChar(addr+1+pos)  # +1 skip length byte
					out(ch)
			} _.concat => symbol
			
			self.addOutputText(""+symbol+" ")
	}
	self._W=Lambda{ # print print top value on hex format
		value=self.pop
		self.addOutputText("0x" + value.hex(4))
	}
	self._Y=Lambda{ # print# print top value on decimal format
		value=self.pop
		self.addOutputText(""+value)
	}
	self._L=Lambda{ # printb print top value on binary format
		value=self.pop
		s=value.bin(self.WORDSIZE*8)
		self.addOutputText(s.sub(0,8)+"_"+s.sub(8))
	}
	self._X=Lambda{ # cr print newline
		self.addOutputCR
	}
	self._U=Lambda { # printc - print byte as character 
		value=self.pop
		if (value >= 32 && value < 255) {
			self.addOutputText(Sys.uchar(value))
		} else {
			error("printc: not a byte: " + value + " " + value.hex(4))
		}
	}

	self._q=Lambda { # andb binary and ( a b -- c )
		b=self.pop
		a=self.pop
		self.push(HWSim:BitwiseAnd(a,b,self.WORDSIZE))	
	}

	self._r=Lambda { # orb binary or ( a b -- c )
		b=self.pop
		a=self.pop
		self.push(HWSim:BitwiseOr(a,b,self.WORDSIZE))	
	}
	self._s=Lambda{ # inv binary not  ( a -- b )
		a=self.pop
		self.push(HWSim:BitwiseNot(a, self.WORDSIZE))
	}
	self._t=Lambda { # << left shift  ( val n -- val )
		bits=self.pop
		value=self.pop
		self.push(HWSim:Leftshift(value, bits, self.WORDSIZE))
	}
	self._u=Lambda { # >> right shift  ( val n -- val )
		bits=self.pop
		value=self.pop
		self.push(HWSim:Rightshift(value, bits, self.WORDSIZE))
	}
	
	self._x=Lambda { # global - get global variable ( N -- value)
		n=self.pop
		error(n<0 || n>=self.globalVariableCount, "global: invalid reference: " + n)
		addr=self.globalVariablesBase + n*2
		self.push(self.memory.readWord(addr))
	}
	self._y=Lambda { # global! - set global variable ( value N -- )
		n=self.pop
		value=self.pop
		error(n<0 || n>=self.globalVariableCount, "global!: invalid reference: " + n)
		addr=self.globalVariablesBase + n*2
		self.memory.writeWord(addr, value)
	}
	self._Z=Lambda{  # halt - terminate execution
		self.haltFlag=true
	}

	self._A=Lambda{  # sym2s - convert symbol offset to string pointer
		offset=self.pop
		addr=self.symbolsStart + offset
		self.push(addr)
	}

	self._C=Lambda{  # .str - print string
		addr=self.pop
		self.printString(addr)
	}

	self._B=Lambda{ # streq - compare strings, return 0 if not and 1 if equal
		a=self.pop
		b=self.pop
		len=self.memory.readByte(a)
		if (self.memory.readByte(b) != len) {
			self.push(0)
		} else {
			match=true
			Inner{Std.Data.for(0,len,1)->i
				if (self.memory.readByte(a+1+i) != self.memory.readByte(b+1+i)) {
					match=false
					break
				}
			}
			self.push(if(match,1,0))
		}
	}
	self._D=Lambda { # memcpy ( ptrSrc ptrTarget bytecount -- )
		byteCount=self.pop
		target=self.pop
		source=self.pop
		Std.Data.for(0,byteCount,1)->i
			self.memory.writeByte(target+i, self.memory.readByte(source+i))
	}
	
	self.bufferedInput=GetInitialForthCode

	# "42 dup add " <-- 1584 instructions to process this in interactive mode
	# ": rf 2 3 add ; rf print " # <-- 7455 instructions
	
	self._v=Lambda{ # readc ( -- byte ) - read single character - blocking
		if (self.bufferedInput.length==0) {
			Lib:Header("The REPL is waiting for more input characters!")
			self.bufferedInput = readLine("Enter input")
		}
		if (self.bufferedInput.length==0) {
			self.bufferedInput=" "
		}
		value=self.bufferedInput.chars.first.toHexString("ISO-8859-1").parseInt(16)
		self.push(value)
		self.bufferedInput=self.bufferedInput.sub(1)
		
	 }
	 
	 self._z = Lambda{ # null ( -- 0 ) pushes a single zero on the stack
	 	self.push(0)
	 }
	 
	 self._1 = Lambda { # n2code3 ( val addr -- ) convert value (0-16k) to 3 code bytes, written to addr+
	 	addr=self.pop
	 	number=self.pop
	 	bytes=NumberTable:GenerateNumberBytes(number,3)->b
	 		self.memory.writeByte(addr,b)
	 		addr=addr+1
	 	|
	 }
		
	 self._2 = Lambda { # n2code ( val addr -- N ) convert value to code, written to addr, returns number of bytes written
	 	addr=self.pop
	 	number=self.pop
	 	bytes=NumberTable:GenerateNumberBytes(number)->b
	 		self.memory.writeByte(addr,b)
	 		addr=addr+1
	 	|
	 	self.push(bytes.length)
	 }

	 self._3 = Lambda { # n2code2 ( val addr -- N ) convert (0-4096) to 2 code bytes, written to addr+
	 	addr=self.pop
	 	number=self.pop
	 	bytes=NumberTable:GenerateNumberBytes(number,2)->b
	 		self.memory.writeByte(addr,b)
	 		addr=addr+1
	 	|
	 }

	 self._P = Lambda{ # PC ( -- addr )
	 	self.push(self.PC)
	 }
		
		
/class Interpreter



# Show frame stack
# --
	P(1) as &MemStack => frameStack

	# pair two values
	count=0
	frameStack.getStackValues->value
		count=count+1
		if (count % 2 == 0) out(":") else out(" ")
		out(value)
	| _.concat
//ShowFrameStack


# Show word stack
# --
	P(1) as &MemStack => stack
	stack.getStackValues->value
		out(value.hex(4))
	| _.concat(" ")
//ShowWordStack


# Show global variables
# --
	P(1) as &Interpreter => interpreter

	Std.Data.for(0, interpreter.globalVariableCount, 1)->index
		out(" " + interpreter.memory.readWord(interpreter.globalVariablesBase + index*interpreter.WORDSIZE).hex(4))
	| _.concat.trim

/ShowGlobals



# Show memory content
# --
	P(1) as int => startAddr
	P(2) as &Memory => memory

	bytesPerLine=if(Term.w > 90, 8, 4)
	
	lastAddr=startAddr + (Term.h-4)*bytesPerLine
	if (lastAddr < startAddr+10) lastAddr=startAddr+10
	if (lastAddr >= memory.HERE) lastAddr=memory.HERE
		

	hex=""
	info=""
	dec=""
	
	Std.Data.for(startAddr, lastAddr, 1)->addr
		offset=addr-startAddr

		if (offset % bytesPerLine == 0) {
			println (hex + "  " + info + "  " + dec)
			print(("   "+addr).last(3) + "  " + addr.hex(4)+" | ")
			hex=info=dec=""
		}
		value=memory.readByte(addr)
		hex=hex+value.hex(2) + " "
		dec=dec+("   "+value).last(3)+" "

		if (value >=33 && value <=127) {
			info=info + Sys.uchar(value) + " "
		} else {
			info=info + ". "
		}
		
	|
	{loop break(hex.length>=bytesPerLine*3) hex=hex+" "}
	{loop break(info.length>=bytesPerLine*2) info=info+" "}
	{loop break(dec.length>=bytesPerLine*4) dec=dec+" "}

	println (hex + "  " + info + "  " + dec)

	println
	readLine("Continue")
/ShowMemory	


# Read memory address
# --
	P(1) as Dict => tags

	Input("Enter address hex NNNN or tag or part of tag").get =>s

	if (s.?parseInt(16)) {
		s.parseInt(16)
	} else if (tags.has(s)) {
		tags.get(s)
	} else {
		value=0
		Inner{
			tags.keys->key
				#println(key)
				if (key.contains(s)) {
					println("Using tag " + key)
					readLine("Enter")
					value=tags.get(key) 
					break
				}
			|
			if(value==0) {
				println("No matching tag, using DATA")
				value=tags.get("DATA")
				readLine("Enter")
			}
		}
		value
	}  	
//ReadMemoryAddress



# Initial forth code
# --
<<< EOF

( Current offset in compileBuf )
: . cr print# ;	

( current offset in compileBuf )
: _pc 1 global readb immediate ;

( emit dummy word to be patched )
: _0w 0 emitb 0 emitb immediate ;

( Push compile pos on stack )
: _ppos _pc immediate ;

: IF 
	105 emitb   ( not - works the condition )
	_pc dup .      ( push pc on stack - picked up the THEN )
	_0w         ( 0 0 - patched by THEN )
	80 emitb    ( PC )
	43 emitb    ( add )
	84 emitb    ( jmp? )
	immediate
	;
	
: THEN ( only modifies IF to jump here if condition fails )
	cpush            ( a is the paddress of the _0w field )
	_pc a sub cpush  ( b = bytes the IF jump should move forward )
	3 sub            ( compensate three PC++ before running jmp?)
		a
			n2code2
	immediate
	;


: ret?	( if true, return )
	( 4 PC add jmp? ret ... )
	196 emitb		( 0xc4 - constant 5 )
	80 emitb		( PC )
	43 emitb		( add )
	84 emitb		( jmp? )
	82 emitb		( ret )
	immediate
	;

: cond not ret? 999 . ;

>>> EOF
	->line
		s=line.before("(").trim
		reject(s=="")
		out(s)
	| => lines
	#lines.print
	#readLine("Enter")
	
	
	lines.concat(" ") => str
	#println(str)
	#readLine("Enter")
	str
/GetInitialForthCode

# Test
# --
	# uses Curses
	Curses:Enable

	dict = Db2:Get("RForth","data")
	hexBlock=dict.hexBlock
	symbolsStart=dict.symbolsStart
	tags=dict.tags
	tagListSorted=dict.tagListSorted
	metaInfo=dict.metaInfo
	
	
	
	runUntilCount=-1		# Sys.currentTimeMillis
	monitorByteAddr=-1		# monitor for changes
	breakpoint=-1
	autorun=false

	interpreter=Interpreter(hexBlock, symbolsStart)
	interpreter.DATA_START=tags.get("PROTECT")

	monitorByteValue=0

	lastReadTime=Sys.currentTimeMillis

	loop
		pc=interpreter.PC
		if (instr=interpreter.memory.readByte(pc)==118) {  # "v" is readc
			if (interpreter.bufferedInput=="") {
				Inner {
					interpreter.outputLines->line println(line) |
				}

				elapsedTime=Sys.currentTimeMillis - lastReadTime
				readLine("[" + elapsedTime + "] Ready")=>s
				if (s=="q") {
					interpreter.bufferedInput=" "
					autorun=false 
				} else {
					s=" " + s + " "
					interpreter.bufferedInput=s
				}
				lastReadTime=Sys.currentTimeMillis
			}
		}

		if (interpreter.haltFlag) {
			interpreter.haltFlag=false
			autorun=false
		}
		if (interpreter.PC==breakpoint) {
			runUntilCount=-1
			autorun=false
		}
		if (runUntilCount > 0 && interpreter.executionCount==runUntilCount) {
			runUntilCount=-1
			autorun=false
		}
		if (monitorByteAddr >= 0 && monitorByteAddr < interpreter.memory.HERE 
				&& interpreter.memory.readByte(monitorByteAddr) != monitorByteValue)
		{
			autorun=false
			monitorByteValue = interpreter.memory.readByte(monitorByteAddr)
		}
		
		if (autorun) {
			tryCatch(interpreter.executeInstruction) => result
			if (!result.ok) {
				println("ERROR: executeInstruction failed: " + result.msg)
				readLine("Press ENTER")
				# cancel autorun
				autorun=false
			}
			continue
		}
		
		# show outputlines
		print(Curses:Clear)
		
		outputLines=interpreter.outputLines
		if (outputLines.length > 10) outputLines = outputLines.last(10)
		outputLines=List("Output:","-------")+outputLines
		count=outputLines.length
		Inner {
			x=60
			maxLineLength=Term.w-x-2
			
			Std.Data.for(0,count,1)->y
				line=outputLines.get(y)
				if (line.length > maxLineLength) line=line.sub(0,maxLineLength)+"+"
				println(Curses:CurGoto(x,Term.h-10-count+y)+line)
				
		}
		
		print(Curses:Home)
		
		# show context
		lines=Term.h-10
		if (!Curses:Enabled) lines=lines-5
		
		from=interpreter.PC-(lines div 3)
		if (from < 0) from=0
		to=from+lines
		if (to > symbolsStart) to=symbolsStart
		
		Inner {
			Std.Data.for(from,to,1)->pc
				mark=""
				if (pc==interpreter.PC) {
					if (pc==breakpoint) {
						mark="BP =>"
					} else {
						mark="====>"
					}
				} else if (pc==breakpoint) {
					mark="BP"
				}
				
				instr=interpreter.memory.readByte(pc)
				if (instr >= 33 && instr <= 127) {
					ch=Sys.uchar(instr)
					tryCatch(x=Assembler:InstructionsLookup.get(ch))=>result
					if (result.ok) {
						instr=x
					} else {
						instr="(data: 0x" + instr.hex(2) + ")"
					}
				} else if (instr >= 128) {
					instr="0x"+instr.hex(2)
				}
				
				report(mark,pc.hex(4), 
					(metaInfo.get(""+pc,"")+" ".times(25)).first(25), instr)
		} _=>rows
		Lib:ShowRows(rows,null,false)
			
		
		
		println(Curses:CurGoto(0,Term.h-9))
		
		dmax="max=" + interpreter.dataStack.maxDepth
		cmax="max=" + interpreter.callStack.maxDepth
		fmax="max=" + interpreter.frameStack.maxDepth

		println("dataStack  0x" + interpreter.dbase.hex(4) + " [ " + ShowWordStack(interpreter.dataStack) + " ] TOP " + dmax)
		println("frameStack 0x" + interpreter.fbase.hex(4) + " [ " + ShowFrameStack(interpreter.frameStack) + " ] TOP " + fmax)
		println("callStack  0x" + interpreter.cbase.hex(4) + " [ " + ShowWordStack(interpreter.callStack) + " ] TOP " + cmax)
		
		print(Prompt:GetPathColor)
		println(
			"#instr=" + interpreter.executionCount,
			"DATA_START=" + interpreter.DATA_START.hex(4),
			"HERE=" + interpreter.memory.HERE.hex(4),
			"Globals=[" + ShowGlobals(interpreter) + "]"
			)
		print(Curses:Reset)
		
		localVariables=Inner{
			framesize=interpreter.frameStack.peek
			to=framesize
			if (to >= 3) to=3  
			Std.Data.for(0,to,1)->i
				value=interpreter.callStack.getValue(framesize-i-1)
				out("abc".chars.get(i)+"="+value.hex(4))
			| _.concat(" ").trim => x
			if (x != "") x=x+" "
			x
		}
		print(Prompt:GetColor)
		println(		
			localVariables + 
			if (breakpoint>=0, "bp="+breakpoint.hex(4), "")
		)
		println(Curses:Reset)

		command=readLine("==> q=quit, d=dump, b=bp, c=clear-bp, h=hex->dec, r=run s=skip, ENTER=step").trim
		if(command=="q") {
			break
		} else if (command=="d") {
			println
			addr=ReadMemoryAddress(tags)
			ShowMemory(addr, interpreter.memory)
		} else if (command=='b') {
			addr=ReadMemoryAddress(tags)
			breakpoint=addr
		} else if (command=='c') {
			breakpoint=-1
		} else if (command=='h') {
			println(readLine("Hex").parseInt(16))
			readLine("Continue")
		} else if (command.startsWith("r")) {
			Input("Enter instruction count, or 'bNNNN' = hex address to monitor byte change").get => s
			if (s.startsWith("b")) {
				monitorByteAddr=s.sub(1).parseInt(16)
				monitorByteValue=-1
				runUntilCount=-1
			} else {
				instrCount=s.parseInt
				runUntilCount=interpreter.executionCount + instrCount
				monitorByteAddr=-1
			}
			autorun=true

		} else if (command=="s") {
			breakpoint=interpreter.PC+1
			autorun=true
		} else if (command.trim=="") {
			tryCatch(interpreter.executeInstruction) => result
			if (!result.ok) {
				println("ERROR: executeInstruction failed: " + result.msg)
				readLine("Press ENTER")
				# cancel autorun
				autorun=false
			}
		}	 
/Run

Run
/t		
	
