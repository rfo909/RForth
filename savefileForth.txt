List( "+","ADD",
  "-","SUB",
  "*","MUL",
  "/","DIV",
  "%","MOD",
  "<<","LSHIFT",
  ">>","RSHIFT",
  "|", "BIT_OR",
  "&", "BIT_AND",
  "!", "BIT_NOT",
  "==", "EQ",
  "return", "RETURN",
  "read", "READ",
  "write", "WRITE",
  "dup", "DUP",
  "pop", "POP"
)



# Op-codes
# Position in list is binary op-code
# --
	List(
		"EOF",
		"RET",
		
		"CALL",
		"JMP",
		"ZJMP",
		"CJMP",
		"POP",
		"DUP",

		"READ",
		"WRITE",

		"LSET",
		"LGET",

		"ADD",
		"SUB",
		"MUL",
		"DIV",
		"MOD",
		"NEG",
		"GT",
		"LT",
		"GE",
		"LE",
		"EQ",
		"NE",
		"L_AND",  # Logical  
		"L_OR",
		"L_NOT",

		"LSHIFT",
		"RSHIFT",
		"B_AND",   # bitwise
		"B_OR",
		"B_NOT"
	 )
/opCodes
 
# Check for duplicates
# --
	opCodes.length == opCodes.unique.length
/unique


# Create code
# --
	pos=0
	opCodes->s
		println("#define OP_" + s + "    " + pos)
		pos=pos+1
	|
/c1


# Create code
# --
	opCodes->s
		Inner{
			s.chars->c 
				out("'" + c + "'") 
			| _.concat(",") + ",'\0'"
		} => chars
		str="const char STR_OP_"+s+"[] PROGMEM = {" + chars + "};"
		println(str)
/c2a

# Create code
# --
	println
	println("char *getOp (byte b) {")
	println("	// auto-generated")

	pos=0
	opCodes->s
		Inner {
			@ 	if (b==OP_<<s>>) return "<<s>>";
			.mergeExpr->line println(line)
		}
		pos=pos+1
	|	
	println()
	println('	return NULL;')
	println("}")
/c2
		

# Create code
# --
	println("bool executeOp (byte b) {")
	println("	switch (b) {")
	pos=0
	opCodes->s
		{
		@ 	case OP_<<s>> : return true;
			.mergeExpr->line println(line)
		}
		pos=pos+1
	|	
	println("	}")
	println('	return false;')
	println("}")
/c3


# Error codes
# --
<<<<<< EOF
#define ERR_UNKNOWN_OP        1
#define FUNC_csPop              2
#define FUNC_csPeek            3
#define FUNC_inpLocalVariableAdd 4
#define FUNC_csPush   5
#define FUNC_mapAddPos 6
#define FUNC_pcAddByte 7
#define FUNC_psAddChar 8
#define ERR_dsGet_not_number 9
#define ERR_dsPop_not_number  10
#define FUNC_dsPopValue 11
#define ERR_dsPeek_not_number 12
#define FUNC_inpAddToken 13
#define FUNC_inpAddChar 14
#define FUNC_dsPeekValue 15
#define FUNC_dsPushValue 16
#define ERR_INVALID_TYPE_CAST 17
>>>>>> EOF
	->line
		reject(line.trim.length==0)
		out(line.after(" ").before(" "))
/Strings


Strings.concat.length + Strings.length*3 - Strings.length*2
/space


# Generate String data for error codes
# --
	longest=0
	
	dict=Dict
	pos=0
	Strings->s
		pad=" ".times(40-s.length)
		println("#define " + s + " " + pad + pos)
	|
	
	println println println
	
	println("void printCode (int code) {")
	println("  switch(code) {")
	Strings->s
		println("    case " + s + ": {")
		println('      Serial.print(F("' + s + '"));')
		println("      return;")
		println("    }")
	|
	println("  }")
	println("}")
		
	
		
/PS
