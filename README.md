Forth never ceases to fascinate
================================

Version 3

2025-08-11 RFO

It's been said that the best way of understanding Forth is to build one
yourself. This project aims at the Pi Pico as the run platform,
simply because the toolchain and the deploy is so easy. 

It is unlikely this Forth will ever be used for anything but testing
and development.

The initial effort consisted of making a byte code assembler, and 
developing and compiling the code in the ACode.txt file, which is 
the base code. 

The compiled byte code is kept a printable string, for copy-paste
into the interpreter. 

A major milestone was getting the "call" and "ret" instructions
up and working. 

We manage our own call
stack, which is also the home for local variables inside functions,
which means that calling and returning from functions ("words") are
implemented as JMP's. This means we are not using the microcontroller's
native call and return stack (although the C implementation of the 
interpreter, naturally will).

External assembler
------------------

The plan is to compile the base code (ACode.txt) outside the Pico,
using the Assembler script (written in [CFT](https://github.com/rfo909/CFT)),
and send the bytecode string (which is kept on printable format) to
it over serial.

A CFT interpreter will also need to be created, in order to step through
the byte code, in order to verify the assembler, and as a measuring stick
for the C code interpreter.

Going Forth ... (hah hah)
-------------------------


At some point, after having decided how to interface serial input, the C code is 
rewritten. New features will be tested in the CFT interpreter first, before
sent to the microcontroller. 

At some point we create Forth dictionaries and Forth words out of the 
low level ("assembly") functions, and the capability of defining new words,
compiling them to "assembly". At this point, after sending the base
byte code, we may pipe Forth word definitions over serial, and also
interact with it, probing and examining both memory and functionality.

When the base program stabilizes, it will get included in the interpreter 
written in C, so it can execute automatically without
having to be piped into the microcontroller every time. 

Now we talk Forth over the serial connection.

If all this doesn't sound like fun, I don't know what will! 

Third attempt ...
-----------------

The previous attempts were bogged down in assembly complexities,
which I think are solved now, by introducing the xNNN number literals
as singlebyte instructions, and of course the assembler supporting
local tags within functions.

Other important features of the assembler:

	- data stack
	- call stack, which supports local variables (via inlining)
	- frame stack, which manages the call stack
	- handling of symbols on format 'xxx

The previous attempts tried defining as much as possible within the bytecode,
and it got very complex. It also would have been quite inefficient.

Bytecode size
-------------
It is of course important keeping the size of the generated byte code down. The
current version of ACode.txt plus the compiler, handles call+ret and CONS cells
free-listed. 

It compiles to about 150 bytes of code, which I think is quite good! 
It should be possible implementing the basics of dictionaries and running
a first (non-compiled) Forth engine within an additional 100-150 bytes.

Output from Assembler:

```
Tags
----
Test               | x0000
TestJmp            | x0000
Main               | x0002
Init               | x001A
Error              | x0023
Halt               | x002A
ConsFree           | x0030
ConsAlloc          | x0032
ConsGet            | x004E
ConsGet.FreelistOk | x0063
ConsDispose        | x0083
DATA               | x0098

Code
----
+Rx001AQx004EQx0083Qx002ASx0x0030JRVx002ASx002ASx0x2x2*Kx1Ox0030IPx2+J
Px0030JRx0030Ix0hx0063Tx0032Qx0030x2+Ix1OPx0030Jx0PJx0Px2+JPRx1Ox0030P
x2+JPx0030JR

152 bytes
```
