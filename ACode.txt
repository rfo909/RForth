:Test
	#10 #20 &TestJmp call

	;; #999  ;; to indicate on stack we are back

	;; &Halt jmp

	;; #0 b !
	;; HERE
	;; PC
	;; #21 #39 lt
	;; #39 #21 lt
	;; #21 #39 gt
	;; #39 #21 gt
	;; xAA xAB eq
	;; xCC xCC eq
	;; #21 #39 add #15 div  ;; works
	;; #1 #2 and #2 #0 or  ;; works
	&Halt jmp

:TestJmp
	add ret

:Main
	&Init call
	&ConsGet call 
		&ConsDispose call
	&Halt jmp

:Init
	#0 &ConsFree !		;; initialize ConsFree pointer to zero
	ret

:Error ;; ( sym sym symCount -- )
	show
	&Halt jmp
	
:Halt
	&Halt jmp
	
	
;; Stack operations


;; Cons cells are created as a CAR+CDR tuple, each value a Word. They are allotted
;; as needed, but also freelisted when disposed off

:ConsFree x0	;; freelist pointer	
	;; 0 means empty
	;; Using two instructions to generate two bytes, which are not null, 
	;; so the value is nulled in :Init before use
	;; ---
	;; NOTE the interpreter works with word-based memory, and so will affect only the
	;; first "reserved" byte above. 

:ConsAlloc
	WORDSIZE #2 mul allot #1 cpush ;; a=pointer new cons
	&ConsFree @ 
		a CDR ! ;; Cons.CDR = ConsFree
	a &ConsFree !   ;; ConsFree = Cons
	;; no return value
	ret

:ConsGet   ;; get Cons cell from free list (call ConsAlloc first if empty)
	&ConsFree @ #0 ne &*FreelistOk jmp?
		;; freelist is empty, add one Cons
		&ConsAlloc call
	
	:*FreelistOk
	;; freelist not empty, take first cons
	&ConsFree CDR @ #1 cpush   ;; a=cons.CDR
	a &ConsFree !			;; update freelist
	#0 a !
	#0 a CDR !
	a
	ret
	
:ConsDispose  ;; (ptr -- )
	#1 cpush  ;; a=ptr
	&ConsFree
		a CDR !		;; ptr.cdr=freelist
	a &ConsFree !		;; freelist=ptr
	;; no return value
	ret

;; ---------------------------------
;; Reserved tags, must be present
;; ---------------------------------	

:DATA		
	;; data is generated here - the tag is used by disassembler to 
	;; show bytes correctly beyond this point (not as instructions)


