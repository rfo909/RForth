;; This file implements a state machine for the REPL and compiler.
;;
;; The data stack is already defined, as this "pretend assembly" exists on
;; a virtual stack machine. The return stack also exists, and there are
;; instructions call and ret which use it. The state machine that follows
;; only uses jumps.
;;
;; Towards the end follows the data fields. Using the following notation to
;; create placeholders and values in memory:
;;
;;  HEX:0001 
;;  %'symbol     - generates one length byte followed by the characters
;;  %tag         - inlines a tag address as a two byte word
;;  %NEXT        - generates a pointer one word ahead, then writes that value as a word
;;  b0           - generates a null byte, shortcut for HEX:00
;;  w0           - generates a null word, shortcut for HEX:0000
;;
;; Note tags must be defined earlier in the file, as the %tag references are not
;; part of the resolve scheme implemented in NumberTable

;; ------------ top of file ----------

#define DIGIT_0		48
#define DIGIT_9		57



:Init
	;; if PANIC restart, preserve dictionary head
	0 global 0 ne &*keepDictHead jmp?
		;; Store dictionary head pointer in 0 global for
		;; access from assembly
		&DictionaryHead 0 global!

	:*keepDictHead
	0 &IsCompiling writeb
	0 &IsCompilingWord writeb	

:REPL
	&GetNextWord call
	&IsNumber readb cpush     ; a
	&IsWord readb cpush       ; b

	a &ProcessNumber call?
	b &ProcessWord call?
	;; otherwise ignore (must have been an error)
	a not b not and &ResetCompile call?	;; something went wrong
	&REPL jmp


:GetNextWord
	0 &NextWord writeb
	0 &NextNumber !
	1 &IsNumber writeb	; assuming number until non-digit
	0 &IsWord writeb

	0 cpush  		; using a for next char
	0 cpush			; using b to keep track of length of current word
	:*nextChar
		readc a!
		a 0x20 eq b 0 eq and &*nextChar jmp? 	;; ignore preceding space
		a 0x20 eq &*done jmp?			;; word identified

		a DIGIT_0 gt a DIGIT_9 gt or &*notDigit jmp?

		;; digit - update NextNumber
		&NextNumber @ 10 mul a DIGIT_0 sub add &NextNumber !
		&*doNext
	:*notDigit
		0 &IsNumber writeb
		1 &IsWord writeb
		
	:*doNext
		;; update NextWord
		a &NextWord b 1 add add writeb
		b 1 add b!
		&*nextChar jmp
	:*done
		b &NextWord writeb
		ret
	
	
:ProcessNumber  
	&IsCompiling readb &*compile jmp?
	
		;; not compiling
		&NextNumber @		;; push on stack
		ret
	
	:*compile
	
		&NextNumber @ &EmitNumber call
		ret
		
:ProcessWord
	;; look up word in dictionary
	
	cr "Looking_up_ .str &NextWord .str
	
	&NextWord &DictLookup call 			;; dictionary entry pointer or null
	
	; ( dictEntryPointer )
	dup 
		null eq &*notFound jmp?
		dup readb add 1 add			;; advance past the string	
	
	; (dictEntryPointer past the string - pointing at CODE, MODE, NEXT (words)
	; ( CODE-ptr )
	dup W+ @  
		; (CODE-ptr-ptr MODE-value) 
		&ExecuteWord call
	
	ret
	
	:*notFound
		drop					;; dup'ed value before call
		cr "Unknown_word_ .str	
		&NextWord .str
		PANIC
		

;; -----------------------------------------------
;; Utility subroutines, invoked with call
;; -----------------------------------------------

:ResetCompile
	0 &IsCompiling writeb			;; set IsCompiling flag = 0 - set to 1 when compiling a word
	0 &IsCompilingWord writeb
	0 &IsCompilingWordMode writeb
	0 &CompileBuf writeb
	ret

:EmitByte   ;; ( byte -- )
	cpush				;; a=bytevalue
	&CompileBuf readb 1 add cpush	;; b=offset 
	a b &CompileBuf add writeb
	b &CompileBuf writeb
	ret
	
:EmitNumber ;; ( value -- )
	cpush			;; number
	
	;; calculate write position
	&CompileBuf readb 1 add &CompileBuf add cpush    ;; b
	
	;; generate number as code
	a 
		b n2code cpush 				;; c = number of bytes generated
		
	;; update CompileBuf length
	&CompileBuf readb
		c add
			&CompileBuf writeb
			
	ret
	
:EmitOp  ;; ( str -- code ) - lookup in dictionary
	&DictLookup cpush 		;; a=dictionary entry
	a readb 1 add a!		;; skip string
	a wordsize add @ 2 eq &*ok jmp?  ;; mode==2 (LITERAL) is ok
		cr "EmitOp:_unknown_op_ .str
		a .str
		PANIC
	:*ok
	a @ &EmitByte call
	ret
	
		
		

:DictLookup ;; ( str -- dictEntry|null )
	cpush				;; a=str
	&DictionaryHead @ cpush		;; b=current dictionary entry
	:*next
		b null eq &*notFound jmp?	;; pointer is null, not found
		b a streq &*found jmp?		;; got a match
		
		b 
			b readb add 1 add 	;; byte count past string
				W+ W+			;; past code-pointer and flags
					@			;; read next pointer
		b!						;; update b with it
		&*next jmp
	:*notFound
		null ret
	:*found
		b ret

:ExecuteWord ;; ( code-ptr-ptr mode-value -- ) ;; decide how to handle word
	swap @ cpush				; a=code-ptr  
	cpush    				; b=mode-value
	
	&IsCompiling readb not &*NotCompiling jmp?
		;; --- compiling
		b 1 eq &*callCode jmp?		;; mode==immediate: call CODE
		b 0 eq &*generateCall jmp?	;; mode==normal: generate call to CODE
		b 2 eq &*inlineCode jmp?	;; mode==inline: add single instruction to code
		ret
	:*NotCompiling
		;; --- interactive		
		b 0 eq &*callCode jmp?		;; mode==normal, call the code
		b 2 eq &*callInline jmp?	;; mode==inline, execute that instruction
		b 1 eq &*callCode jmp?		;; mode==immediate, call the code

		&REPL jmp
		
	:*callCode
		cr "callCode_ .str a print
		a call 
		ret
	:*generateCall
		cr "generateCall_ .str a print
		a						;; the number
			&CompileBuf &CompileBuf readb add 1 add		;; write position in CompileBuf
				n2code				;; generate code, return N = number of bytes written
		
		; (N)
		&CompileBuf readb 				;; old length
			add 					;; add to N 
				&CompileBuf writeb		;; update counter for CompileBuf

		;; add the call instruction
		0x51						;; Q = call
			&EmitByte call

		ret
	:*inlineCode
		;; when inlining, the "code pointer" is the instruction! 00nn!
		cr "inlineCode_ .str a print
		a &EmitByte call
		ret
	:*callInline
		;; when inlining, the "code pointer" is the instruction! 00nn!
		cr "callInline_ .str a print
		0 &CompileBuf writeb				;; clear CompileBuf (this is interactive mode, so buffer not in use)
		a &EmitByte call					;; add the opcode
		0x52 &EmitByte call  				;; add "R" = ret
		&CompileBuf 1 add call    			;; invoke CompileBuf offset 1 (as byte 0 is the length)
		ret
	
;; -----------------------------------------------
;; Implementations for initial complex words in dictionary
;; -----------------------------------------------

	
:COLON
	;; already in compile mode?
	&IsCompiling readb &*nested jmp?

	;; set compile mode
	1 &IsCompiling writeb

	;; next word is to be a literal
	&GetNextWord call
	
	&IsNumber readb &*numberError jmp?
	
	;; copy NextWord to IsCompilingWord buffer
	&NextWord
		&IsCompilingWord
			&NextWord readb 1 add
				memcpy
	
	;; set compile output length to 0
	0 &CompileBuf writeb

	;; that's all?
	ret

	:*nested
		cr "Can_not_nest_colons:_ .str "_Ignoring .str
		PANIC
	
	:*numberError
		cr "Can_not_use_number_as_word_name:_ .str
		&ResetCompile call
		PANIC
		
:SEMICOLON
	;; verify compile mode
	&IsCompiling readb &*ok jmp?
		;; ignore it
		ret
	:*ok
		;; info
		cr "Finishing_word_ .str &IsCompilingWord .str

		;; add a ret instruction to CompileBuf
		0x52 &EmitByte call

		;; allocate buffer including length byte
		HERE cpush								;; a=codebuffer
		&CompileBuf readb 1 add
			allot

		;; copy code into codebuffer
		&CompileBuf add
			a
				&CompileBuf readb 1 add
					memcpy
		
		;; allocate dictionary entry
		HERE cpush							;; b=dictEntry
		&IsCompilingWord readb 1 add		;; length of symbol
			wordsize 3 mul add				;; code pointer, flags, next
				allot

		;; copy symbol
		&IsCompilingWord					;; src
			b								;; target
				&IsCompilingWord readb 1 add	;; byte count
					memcpy
		
		;; advance dict entry pointer past name
		b readb b add 1 add cpush					;; c=point to CODE field

		;; write code address and advance c
		a 1 add c !		;; 1 + to go past the length byte, which we keep for control etc
		c W+ c!

		;; write mode and advance pointer
		&IsCompilingWordMode readb
			c !
		c W+ c!

		;; write next pointer
		&DictionaryHead @ 
			c !

		;; update DictionaryHead
		b &DictionaryHead !

		;; switch off compile mode and clean up
		&ResetCompile call

		;; all done
		ret

	:*noSymbol
		"No_symbol_defined_for_word .str
		PANIC
	
:immediate
	;; change the IsCompilingWordMode to immediate
	1 &IsCompilingWordMode writeb
	ret
		


:DATA

;; The dictionary entry has the following format:
;;
;;  - name as string: 1 byte length, followed by characters
;;  - code reference: word pointer
;;  - flags: word
;;  - next: word
;;
;; Next=0 means terminated

;; use these in the Dictionary only, as they generate raw memory values, not code!

#define NORMAL 		HEX:0000
#define IMMEDIATE	HEX:0001
#define INLINE		HEX:0002	;; code pointer is single-byte instruction: "00xx"

;; Note that the dictionary is protected (appears before the :PROTECT tag), because it is
;; a readonly structure. It can still be extended by adding new words that point to it, in
;; effect pushing new entries on the stack that is the dictionary. And which is the 
;; Forth way.


:Dictionary
	;; # --- autogenerated content: Assembler:InlineDictionary
	;; #
		
	%'!             HEX:004A        INLINE      %NEXT        ;; J
	%'.str          HEX:0043        INLINE      %NEXT        ;; C
	%'<<            HEX:0074        INLINE      %NEXT        ;; t
	%'>>            HEX:0075        INLINE      %NEXT        ;; u
	%'@             HEX:0049        INLINE      %NEXT        ;; I
	%'HERE          HEX:0067        INLINE      %NEXT        ;; g
	%'PANIC         HEX:0030        INLINE      %NEXT        ;; 0
	%'PC            HEX:0050        INLINE      %NEXT        ;; P
	%'W+            HEX:006E        INLINE      %NEXT        ;; n
	%'a             HEX:0061        INLINE      %NEXT        ;; a
	%'a!            HEX:0064        INLINE      %NEXT        ;; d
	%'add           HEX:002B        INLINE      %NEXT        ;; +
	%'allot         HEX:004B        INLINE      %NEXT        ;; K
	%'and           HEX:0026        INLINE      %NEXT        ;; &
	%'andb          HEX:0071        INLINE      %NEXT        ;; q
	%'b             HEX:0062        INLINE      %NEXT        ;; b
	%'b!            HEX:0065        INLINE      %NEXT        ;; e
	%'c             HEX:0063        INLINE      %NEXT        ;; c
	%'c!            HEX:0066        INLINE      %NEXT        ;; f
	%'call          HEX:0051        INLINE      %NEXT        ;; Q
	%'call?         HEX:0034        INLINE      %NEXT        ;; 4
	%'cpush         HEX:004F        INLINE      %NEXT        ;; O
	%'cr            HEX:0058        INLINE      %NEXT        ;; X
	%'dcopy         HEX:004D        INLINE      %NEXT        ;; M
	%'dget          HEX:004E        INLINE      %NEXT        ;; N
	%'div           HEX:002F        INLINE      %NEXT        ;; /
	%'drop          HEX:006A        INLINE      %NEXT        ;; j
	%'dump          HEX:0070        INLINE      %NEXT        ;; p
	%'dup           HEX:006C        INLINE      %NEXT        ;; l
	%'eq            HEX:003D        INLINE      %NEXT        ;; =
	%'ge            HEX:0045        INLINE      %NEXT        ;; E
	%'global        HEX:0078        INLINE      %NEXT        ;; x
	%'global!       HEX:0079        INLINE      %NEXT        ;; y
	%'gt            HEX:003E        INLINE      %NEXT        ;; >
	%'halt          HEX:005A        INLINE      %NEXT        ;; Z
	%'inv           HEX:0073        INLINE      %NEXT        ;; s
	%'jmp           HEX:0053        INLINE      %NEXT        ;; S
	%'jmp?          HEX:0054        INLINE      %NEXT        ;; T
	%'le            HEX:0046        INLINE      %NEXT        ;; F
	%'lt            HEX:003C        INLINE      %NEXT        ;; <
	%'memcpy        HEX:0044        INLINE      %NEXT        ;; D
	%'mul           HEX:002A        INLINE      %NEXT        ;; *
	%'n2code        HEX:0032        INLINE      %NEXT        ;; 2
	%'n2code2       HEX:0033        INLINE      %NEXT        ;; 3
	%'n2code3       HEX:0031        INLINE      %NEXT        ;; 1
	%'ne            HEX:0068        INLINE      %NEXT        ;; h
	%'not           HEX:0069        INLINE      %NEXT        ;; i
	%'null          HEX:007A        INLINE      %NEXT        ;; z
	%'or            HEX:007C        INLINE      %NEXT        ;; |
	%'orb           HEX:0072        INLINE      %NEXT        ;; r
	%'over          HEX:006F        INLINE      %NEXT        ;; o
	%'print         HEX:0057        INLINE      %NEXT        ;; W
	%'print#        HEX:0059        INLINE      %NEXT        ;; Y
	%'printb        HEX:004C        INLINE      %NEXT        ;; L
	%'printc        HEX:0055        INLINE      %NEXT        ;; U
	%'rback?        HEX:0037        INLINE      %NEXT        ;; 7
	%'readb         HEX:0047        INLINE      %NEXT        ;; G
	%'readc         HEX:0076        INLINE      %NEXT        ;; v
	%'ret           HEX:0052        INLINE      %NEXT        ;; R
	%'ret?          HEX:0035        INLINE      %NEXT        ;; 5
	%'rfwd?         HEX:0036        INLINE      %NEXT        ;; 6
	%'show          HEX:0056        INLINE      %NEXT        ;; V
	%'streq         HEX:0042        INLINE      %NEXT        ;; B
	%'sub           HEX:002D        INLINE      %NEXT        ;; -
	%'swap          HEX:006D        INLINE      %NEXT        ;; m
	%'wordsize      HEX:006B        INLINE      %NEXT        ;; k
	%'writeb        HEX:0048        INLINE      %NEXT        ;; H

	;; ----------------------------------------------------------
	
	%'emitb		%EmitByte	NORMAL		%NEXT	
	%':		%COLON		NORMAL		%NEXT
	HEX:013B	%SEMICOLON	IMMEDIATE	%NEXT
	%'immediate	%immediate	IMMEDIATE	w0	;; <-- w0 = terminating the linked list
:DictionaryEnd

:PROTECT		;; protects data before this point against writes - reads are allowed

:DictionaryHead %Dictionary

:IsCompiling		b0
:IsCompilingWord	b w0 w0 w0 w0 w0 w0 w0 w0		;; 16 character stringbuffer
:IsCompilingWordMode	b0					;; NORMAL or IMMEDIATE

:CompileBuf		w0 w0 w0 w0 w0 w0 w0 w0 		;; up to 255 bytes, allocated when hitting a COLON
			w0 w0 w0 w0 w0 w0 w0 w0			;; first byte is length
			w0 w0 w0 w0 w0 w0 w0 w0
			w0 w0 w0 w0 w0 w0 w0 w0

			w0 w0 w0 w0 w0 w0 w0 w0
			w0 w0 w0 w0 w0 w0 w0 w0
			w0 w0 w0 w0 w0 w0 w0 w0
			w0 w0 w0 w0 w0 w0 w0 w0

			w0 w0 w0 w0 w0 w0 w0 w0
			w0 w0 w0 w0 w0 w0 w0 w0
			w0 w0 w0 w0 w0 w0 w0 w0
			w0 w0 w0 w0 w0 w0 w0 w0

			w0 w0 w0 w0 w0 w0 w0 w0
			w0 w0 w0 w0 w0 w0 w0 w0
			w0 w0 w0 w0 w0 w0 w0 w0
			w0 w0 w0 w0 w0 w0 w0 w0


:NextWord		b w0 w0 w0 w0 w0 w0 w0 w0		;; 16 character stringbuffer
:NextNumber		w0
:IsNumber		b0
:IsWord			b0



	
:MemoryEnd


