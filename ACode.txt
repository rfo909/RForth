;; Assembly level for virtual stack machine
;; ----------------------------------------
;;
;; This file implements the REPL, the colon compiler and the initial dictionary.
;; It implements IF, THEN and ELSE, and the BEGIN ... AGAIN? loop words. It is sufficient
;; to get off the ground. It contains both code and data, addressed by tags.
;;
;; When running, the data stack, call stack and call frame stack are defined by the
;; runtime (interpreter). These exist in RAM above the blob of bytes that is the
;; output from this file. 
;;
;; This means that this code, when being executed, runs on a fully featured
;; virtual stack machine, supporting call and ret. 
;;
;; Some implementations refer to the data stack as "parameter stack", and 
;; the call stack is commonly known as "return stack" in other Forth's. The 
;; call frame stack keeps track of additional values pushed to the call stack,
;; like local variables, which means they don't need to be removed before
;; word return.
;;
;; Tags
;; ----
;;
;; This file is both code, data and initial memory map of the Forth REPL
;; and compiler / interpreter. Tags are defined at two levels, global and
;; local. Global tags are denoted
;;
;;  :Something
;;
;; They can only be defined once, but may be referred multiple times from anywhere, 
;; as &Something.
;;
;; Local tags exist between global tags, and are seen as extensions of the previous
;; global tag. They are used to do conditional and other jumps inside functions,
;; without polluting global tag space. They are written as
;;
;;  :*Something
;;
;; To address them, use &*Something
;;
;; The compiler automatically handles patching of forward references to tags.
;; 
;; Data content
;; ------------
;;
;; Towards the end follows the data fields. Using the following notation to
;; create placeholders and values in memory:
;;
;;  HEX:0001 
;;  %'symbol     - generates one length byte followed by the characters
;;  %tag         - inlines a tag address as a two byte word
;;  %NEXT        - generates a pointer one word ahead, then writes that value as a word
;;  b0           - generates a null byte, shortcut for HEX:00
;;  w0           - generates a null word, shortcut for HEX:0000
;;
;; Note tags to be referred via %tag must be defined earlier in the file, as %tag references
;; are not part of the resolve scheme implemented in NumberTable
;;
;; Local variables
;; ---------------
;;
;; The assembler offers some local variables in each (called!) routine, named 
;; a, b, c, d, e and f. Local variables must be defined/initialized with a call to cpush, which
;; takes a value off the data stack, and pushes it on top of the return address on the
;; call stack. 
;;
;; Note that before a local variable can be used or updated, a value must be cpush'ed to the call
;; stack. After doing a single cpush, we can then use "a" to retrieve that value and
;; "a!" to update it. Using two more cpush'es we get local variables b and c and so on. Using
;; more than the 6 predefined variables, it is time to split up the function.
;;
;; 2025-10-20
;;
;; The colon compiler has extended the concept of local variables, supporting custom
;; names, via the => word, which create and update a local variable, which can then
;; be referred directly in code. It is implemented via cpush / cset / cget, as for
;; the abcd... functionality in this file.

;; ------------ top of file ----------

#define CELL 2

;; dictionary entry modes: use these in code

#define MODE_NORMAL	0
#define MODE_IMMEDIATE	1
#define MODE_INSTR	2	;; code pointer is single-byte instruction: "00xx"
#define MODE_CONSTANT	3	;; code pointer is constant word to be pushed on stack


;; use these in the static Dictionary definition, as they generate raw memory values, which is not valid code!

#define BIN_NORMAL		HEX:0000
#define BIN_IMMEDIATE		HEX:0001
#define BIN_INSTR		HEX:0002
#define BIN_CONSTANT		HEX:0003

#define b0		HEX:00
#define w0		HEX:0000

;; Local variables
#define a		0 cget		
#define b		1 cget		
#define c		2 cget		
#define d		3 cget	
#define e		4 cget
#define f		5 cget	

#define a!		0 cset
#define b!		1 cset
#define c!		2 cset
#define d!		3 cset
#define e!		4 cset
#define f!		5 cset



;; When executing code, we start at PC=0x0000 (&Init)

:Init	
	&PostCompile call

:REPL
	&GetNextWord call
	
	; DEBUG
	; cr &NextWord .str 

	&NextWordIsNumber call &*num jmp?  ;; if true stores number value in &NextNumber
	&NextWord 1+ readb dup 
		34 eq 		;; single quote
		swap 39 eq	;; double quote
			or &*str jmp?  ;; starts with double quote

		&ProcessWord call
		&REPL jmp
	:*num
		&ProcessNumber call
		&REPL jmp
	:*str
		&ProcessString call
		&REPL jmp

:Str_GetNextWordTooLong  %"GetNextWord:_too_long

:GetNextWord
	0 &NextWord writeb
	
	0 cpush  		; using a for next char
	0 cpush			; using b to keep track of length of current word

	:*nextChar
		readc a!
		a 0x28 eq &*comment jmp?		;; start of comment
		a 0x09 ne &*notTab jmp?
			(tab)
			0x20 a!    ;; replace with space
		:*notTab
		
		a 0x20 eq b 0 eq and &*nextChar jmp? 	;; ignore preceding space
		a 0x20 eq &*done jmp?			;; word identified

		;; check buffer size
		b 1+ (length + length byte = required space)
			&NextWordEnd &NextWord sub lt &*bufSizeOk jmp?
				cr &Str_GetNextWordTooLong .str
				PANIC

		:*bufSizeOk
		
		;; update NextWord
		a &NextWord b add 1+ writeb
		b 1+ b!
		&*nextChar jmp
	:*comment
		readc a!			
		a 0x29 eq &*nextChar jmp?		;; end of comment
		&*comment jmp
	:*done
		b &NextWord writeb			( write length byte)
		&DebugFlag readb &*debug jmp?
		ret
	:*debug
		cr &Str_DebugMark .str &NextWord .str
		ret

:Str_DebugMark %">_
	


:NextWordIsNumber		; if &NextWord is a number, parse it and store in &NextNumber, returns boolean
	&NextWord &NextNumber atoi ret

		
	
:ProcessNumber  
	&IsCompiling readb &*compile jmp?
	
		;; not compiling
		&NextNumber @		;; push on stack
		ret
	
	:*compile
	
		&NextNumber @ 0 &EmitNumber call
		ret
	
:ProcessString
	; NextWord starts with single or double quote; if double quote, replace _ with space
	
	&NextWord 1+ readb 39 eq &*noReplace jmp?  ;; starts with single quote

		(replace underscore with space, directly in RAM)
		&NextWord u2spc
	
	:*noReplace

	;; overwrite the quote with length-1
	&NextWord 1+	cpush			;; a=offset 1
	
	&NextWord readb 1 sub
		a writeb
	
	a &BufCreateCopy call 		( address-of-copy )
		&NextNumber ! 
		&ProcessNumber call	;; use the ProcesNumber routine
	ret


:Str_Looking_up_ %"Looking_up_
:Str_Unknown_word_ %"Unknown_word_

:ProcessWord

	;; check for local variable
	&IsCompiling readb not &*noLocal jmp?
	
		&ProcessLVRef call not &*noLocal jmp?
			;; ok
			ret
	
	:*noLocal

	;; look up word in dictionary
	
	;; cr &Str_Looking_up_ .str &NextWord .str
	
	&NextWord &DictLookup call 			;; dictionary entry pointer or null
	
	; ( dictEntryPointer )
	dup 
		null eq &*notFound jmp?
		dup readb add 1+			;; advance past the string	
	
	; (dictEntryPointer past the string - pointing at CODE, MODE, NEXT (words)
	; ( CODE-ptr )
	dup CELL+ @  
		; (CODE-ptr-ptr MODE-value) 
		&ExecuteWord call
	
	ret
	
	:*notFound
		drop					;; dup'ed value before call
		cr &Str_Unknown_word_ .str	
		&NextWord .str
		PANIC
		


:ProcessLVRef ( -- bool)  ;; (&NextWord - check for local variable ref, if so generate code to retrieve it)
	;; compile mode only
	0 cpush (a=index of word)
	0 cpush (b=pos)

	:*again
		;; end of list?
		&LVBuf b add readb 0 eq  
			&*notFound jmp?

		;; match?
		&NextWord &LVBuf b add 
			streq &*found jmp?

		;; go to next
		b &LVBuf readb add 1+ b!
		a 1+ a!

		;; repeat
		&*again jmp

	:*notFound
		0 ret

	:*found
		;; generate code to read variable
		a 0 &EmitNumber call    ;; number
		51 &EmitByte call		;; cget
		1 ret


;; -----------------------------------------------
;; Utility subroutines, invoked with call
;; -----------------------------------------------

:PreCompile
	0 &CompilingWord writeb
	0 &CompileStack writeb
	0 &CompileBuf writeb

	&LVBuf 32 &FillZeroes call
           ;; local variable names
	
	MODE_NORMAL &CompilingWordMode writeb

	1 &IsCompiling writeb
	ret
	
:PostCompile
	0 &IsCompiling writeb			;; set IsCompiling flag = 0 - set to 1 when compiling a word
	0 &CompilingWord writeb
	0 &CompilingWordMode writeb
	0 &CompileBuf writeb
	0 &CompileStack writeb
	0 &LVBuf writeb
	ret

:FillZeroes ( buf count )
	cpush (a=count)
	cpush (b=buf)
	:*again
		a 1 sub a!
		0 b a add writeb
		a 0 gt &*again jmp?
	ret

:ShowBuffer (buf size) 
	cpush (a=size)
	cpush (b=buf)
	0 cpush (c=count)
	:*again
		b c add readb print# &Str_Space .str 
		c 1+ c!
		c a le &*again jmp?
	ret


:CompileBufSize
	&CompileBufEnd &CompileBuf sub
	ret

:Str_CompileBufOverflow %'CompileBuf_overflow

:EmitByte   ;; ( byte -- )
	cpush				;; a=bytevalue

	;; check for space
	&CompileBufSize call 1 sub (<-- limit, room for at least 1 byte)
		&CompileBuf readb (used)
			gt &*spaceOk jmp?

		&Str_CompileBufOverflow .str 
		PANIC 

	:*spaceOk
			
	&CompileBuf readb 1+ cpush	;; b=offset 
	a b &CompileBuf add writeb
	b &CompileBuf writeb
	ret
	
:EmitNumber ;; ( value nbytes -- ) 
	swap 
	cpush			;; a=number
	cpush			;; b=nbytes

	;; check for space
	&CompileBufSize call 4 sub (<-- limit - room for at least 3 bytes number data and one byte ret)
		&CompileBuf readb (used)
			gt &*spaceOk jmp?

			&Str_CompileBufOverflow .str
			PANIC

	:*spaceOk
	
	;; calculate write position
	&CompileBuf readb 1+ &CompileBuf add cpush    ;; c
	
	;; generate number as code
	a 
		c 
			b
				n2code 			;; returns number of bytes generated
		
	;; update CompileBuf length from number of bytes generated 
	(#bytes)
		&CompileBuf readb
		add
			&CompileBuf writeb
			
	ret

		


:PushDictionaryEntry ( ptr -- )
	cpush						(a=dictionary-entry)

	&CustomDictionaryHeadPtr @ 0 ne &*custom jmp?
		( regular dictionary pointer )
		&DictionaryHead cpush			(b=regular dictionary head)
		&*continue jmp
	:*custom
		(custom dictionary pointer active )
		&CustomDictionaryHeadPtr @ cpush 		(b=custom dictionary head)
	:*continue
	
	a 
		a readb add 1 add
			CELL+ CELL+ cpush			(c=next-field)

	;; write next pointer
	b @ c !

	;; update Dictionary Head
	a b !
	ret


:CreateDictionaryEntry ( name code mode -- ) (And push it on the dictionary)
	cpush			(a=mode)
	cpush			(b=code)
	cpush			(c=name)

	c readb 1 add cpush	(d=name buffer length incl length byte)
	HERE cpush		(e=dict entry)
	
	d CELL+ CELL+ CELL+ allot		(name code mode next)
	c e &BufCopy call
	
	(code)
	b 
		e d add !
	
	(mode)
	a 
		e d add CELL+ !
	
	e &PushDictionaryEntry call
	ret 

	
	

:DictLookup ;; ( str -- dictEntry|null )
	cpush 						(a=str)
	&CustomDictionaryHeadPtr @ 0 eq &*defaultDict jmp?
	
		&CustomDictionaryHeadPtr @ a &DictTraverse call cpush (b=result)
		b null eq &*defaultDict jmp?
		b
		ret
	
	:*defaultDict
	
	&DictionaryHead a &DictTraverse call
	ret
	


:DictTraverse ;; ( dictHead str -- dictEntry|null )
	cpush				;; a=str
	; &StrLooking_up_ .str a .str cr
	
	(dictHead)
		@ cpush				;; b=current dictionary entry
	:*next
		b null eq &*notFound jmp?	;; pointer is null, not found
		b a streq &*found jmp?		;; got a match
		
		b 
			b readb add 1+ 	;; byte count past string
				CELL+ CELL+			;; past code-pointer and flags
					@			;; read next pointer
		b!						;; update b with it
		&*next jmp
	:*notFound
		null ret
	:*found
		b ret
		
(print DE ptr for word in hex)
:.W
	&GetNextWord call
	&NextWord &DictLookup call cr print
	ret
	
:>>str (ptr -- ptr) (skip past str)
	dup readb add 1+
	ret
	
:?C (str -- addr)
	&DictLookup call	
	&>>str call 
	@
	ret
	
	
(allocate a new dictionary head - its just a variable)
:Dict
	0 &VARIABLE call
	ret
	
:DictUse ( dict -- )	
	&CustomDictionaryHeadPtr !
	ret		
	
:DictClear ( -- )
	0 &CustomDictionaryHeadPtr !
	ret		

:Str_No_dictionary_found_  %"No_dictionary_found_
:Str_Invalid_dictionary_   %"Invalid_dictionary_
:Str_Not_constant		%"_:_Not_constant

:IN (dictWord word -- ? )
	&GetNextWord call 
	&NextWord &DictLookup call cpush 	(a=dict-entry for dict)
	a null eq &*dictNotFound jmp?
	
	a dup readb add 1+ cpush 			(b=code)
	b CELL+ @ MODE_CONSTANT ne &*notConstant jmp?

	b @ b!		(b=dict-head)
	
	&GetNextWord call
	b &NextWord &DictTraverse call cpush  	(c=dict-entry for word)
	
	c c readb add 1+ cpush			(d=ptr to code-bytes)
	
	d					(code-ptr-ptr)
		d CELL+ @				(mode)
			&ExecuteWord call
			
	ret				

	:*dictNotFound
		cr &Str_No_dictionary_found_ .str &NextWord .str
		PANIC
		ret
	:*notConstant
		cr &Str_Invalid_dictionary_ .str &NextWord .str &Str_Not_constant .str
		PANIC
		ret
	


		
:BufCopy ( src target -- ) (for buffer with length byte)
	swap
	cpush 	(a=src)
	cpush	(b=target)
	a b a readb 1+ memcpy
	ret
	
:BufCreateCopy ( src -- ptr) (for buffer with length byte)
	cpush		(a=src)
	HERE cpush	(b=ptr)
	a readb 1+ allot 
	a b &BufCopy call
	b
	ret

:ExecuteWord ;; ( code-ptr-ptr mode-value -- ) ;; decide how to handle normal word
	swap @ cpush				; a=code-ptr  
	cpush    				; b=mode-value
	
	&IsCompiling readb not &*NotCompiling jmp?
		;; --- compiling
		b MODE_NORMAL    eq &*generateCall jmp?		;; mode==normal: generate call to CODE
		b MODE_IMMEDIATE eq &*callCode jmp?		;; mode==immediate: call CODE
		b MODE_INSTR    eq &*inlineCode jmp?		;; mode==inline: add single instruction to code
		b MODE_CONSTANT      eq &*inlineData jmp?		;; mode=data, push code pointer on stack as is
		ret
	:*NotCompiling
		;; --- interactive		
		b MODE_NORMAL    eq &*callCode jmp?		;; mode==normal, call the code
		b MODE_IMMEDIATE eq &*callCode jmp?		;; mode==immediate, call the code
		b MODE_INSTR    eq &*callInline jmp?		;; mode==inline, execute that instruction
		b MODE_CONSTANT      eq &*executeData jmp?

		ret
		
	:*callCode
		;; cr "callCode_ .str a print
		a call 
		ret
	:*generateCall
		;; cr "generateCall_ .str a print
		a 0 &EmitNumber call

		;; add the call instruction
		0x51						;; Q = call
			&EmitByte call

		ret
	:*inlineCode
		;; when inlining, the "code pointer" is the instruction! 00nn!
		;; cr "inlineCode_ .str a print
		a &EmitByte call
		ret
	:*callInline
		;; when inlining, the "code pointer" is the instruction! 00nn!
		;; cr "callInline_ .str a print
		0 &CompileBuf writeb		;; clear CompileBuf (this is interactive mode, so buffer not in use)
		a &EmitByte call
		;; add the opcode
		0x52 &EmitByte call  		;; add "R" = ret
		&CompileBuf 1+ call    	;; invoke CompileBuf offset 1 (as byte 0 is the length)
		ret
	:*inlineData
		;; Data word, push code pointer value to stack
		;; Data words are static, so generating code is ok. For variables, this
		;; value is typically a memory reference!
		a 0 &EmitNumber call
		ret
	:*executeData
		a
		ret

; -------------------------------------------
; Compile stack functions
; -------------------------------------------
	
; Note type=0 is used to invalidate matched values from the stack

:comps! ( pos type -- )			( p=requires pos parameter )
	8 << 				(type is high byte) 
	orb        	         	(pos is low byte)
		cpush			(a=data word)

	&CompileStack readb cellsize mul 1+
		&CompileStack add 
			cpush			(b = write pos )

	a b !

	(increase stack counter)
	&CompileStack readb 1+ &CompileStack writeb
	ret
	

:Str_CompStack_empty			%"CompStack_empty
:Str_CompStack_no_type_		%"CompStack:_no_type_


:comps@ ;; (type -- offset)
	cpush						(a=type)
	&CompileStack readb 0 eq &*emptyStack jmp?
	&CompileStack readb 1 sub cpush			(b=stack pos index for counting down)
	0 cpush						(make variable c available)
	
	:*next
		&CompileStack 
			b cellsize mul add 
				1+ c!		(c=actual read pos)
		;;cr "CompStack:_ .str "read_pos=" .str c print
		;;cr "CompStack:_ .str "checking_value= .str c @ print

		c @ 8 >> a eq &*found jmp?
		b 0 eq &*notFound jmp?		(can count no further down)
		b 1 sub b!
		&*next jmp
	:*emptyStack
		cr &Str_CompStack_empty .str
		PANIC
	:*notFound
		cr &Str_CompStack_no_type_ .str a print#
		PANIC
	:*found
		c @ 255 andb		( return value )
		0 c writeb			( overwrite the type entry so it can't match again )
		ret


; CompileStack types

#define COMPS_TYPE_IF		0 
#define COMPS_TYPE_BEGIN	1

;; NOTE: using single byte relative offsets, which with the number encoding scheme
;; means max relative fwd/back is 63 locations.

 

:IF 
	105 &EmitByte call		( not - invert false to true for conditional jmp ) 
	&CompileBuf readb 		( get next byte pos of CompileBuf )
		COMPS_TYPE_IF 		( type flag for IF logic )
			&comps! call	( push on compile stack )

	; (emit dummy offset data)
	0 &EmitByte call		(note: if not patched, crashes, since 0 is no valid instruction)
	54 &EmitByte call		(rfwd? instruction)
	ret

		
:THEN 			 		( patch forward jump at back address )
	COMPS_TYPE_IF 			( type flag for IF logic )
		&comps@ call cpush	( a=mark pos ) 
	&CompileBuf readb cpush		( b=curr pos )
	b a sub 1 sub cpush   		( c=offset, subtract 1 for the offset byte, as jump relative to rfwd? instr )

	(patch the IF forward jump)
	c					(offset)
		&CompileBuf 1+
			a add   		( write pos )
				1 n2code drop	( generate c as code, handles values 0-63 only )
					( NOTE: don't update buffer count, since this is a patch of an earlier loc )
			
	ret

:ELSE
	( Insert jump to the THEN at end of IF block, if original condition was true, to skip ELSE block )
	( But we can not push it on the compile-stack before resolving the first IF fwd jump )
	
	1 0 &EmitNumber call			( make rfwd? unconditional )
	&CompileBuf readb cpush  		( a=location of forward jump to THEN )
	0 &EmitByte call			( dummy offset )
	54 &EmitByte call			( rfwd? instruction )
	
	( now resolve the IF conditional forward jump to this position )
	&THEN call
	
	( push a new IF forward jump for location a, on compile stack, to be processed by THEN )
	a COMPS_TYPE_IF &comps! call
	ret


:BEGIN
	( store current pos in CompileBuf as type DO on compile stack for conditional back jump from AGAIN? )
	
	&CompileBuf readb 
		COMPS_TYPE_BEGIN 
			&comps! call
	ret
	
:AGAIN?
	&CompileBuf readb cpush			( a=curr pos in compilebuf )
	
	a
		COMPS_TYPE_BEGIN &comps@ call sub	( calculate offset from current pos back to the position stored at DO )
		1+ 				( compensate for one byte of jump offset )
			cpush			( b=back jump count from rback? )

	b 
		1 &EmitNumber call		( generate code for b as 1 byte, which allows values of 0-63 )

	55 &EmitByte call			(rback?)
	ret
	
	
;; -----------------------------------------------
;; Implementations for initial complex words in dictionary
;; -----------------------------------------------


:Str_ok_			%"_ok_	
:Str_bytes			%"_bytes
:Str_CompilingWordTooLong:	%"Compiling_word_too_long:_

:SetCompilingWord (str -- )
	cpush (a=str)
	a readb 1+ 
	   	&CompilingWordEnd &CompilingWord sub le &*ok jmp?
	   		&Str_CompilingWordTooLong: .str PANIC
	:*ok
	a &CompilingWord &BufCopy call
   	ret
   		

	
:COLON
	&PreCompile call
	&GetNextWord call
	&NextWord &SetCompilingWord call
	ret




:Str_NoInteractiveLocals
	%"No_interactive_locals

:Str_LocalsMaxLength
	%"Locals_max_length:_7

;; ---------------------------------------------------------
;; Local variables
;; ---------------------------------------------------------

:LVSet ;; => (immediate word)
	&GetNextWord call
	&IsCompiling readb not &*interactive jmp?
		&NextWord readb 7 gt &*length jmp?
			&NextWord &LVSetOrAdd call
			
			;; DEBUG
			;cr &NextWord .str
			;cr &LVBuf 32 &ShowBuffer call
			ret
	:*interactive
			cr &Str_NoInteractiveLocals .str
			PANIC
	:*length
			cr &Str_LocalsMaxLength .str
			PANIC



:LVSetOrAdd ;; &NextWord (called from :LVSet)
	;; LVBuf:  N...N...0
	0 cpush (a=index of word)
	0 cpush (b=pos)
	&NextWord readb cpush (c=len)

	:*again
		;; end of list?
		&LVBuf b add readb 0 eq  
			&*add jmp?

		;; match?
		&NextWord &LVBuf b add 
			streq &*found jmp?

		;; go to next
		b &LVBuf readb add 1+ b!
		a 1+ a!

		;; repeat
		&*again jmp

	:*add
		(b is at the terminating 0)

		&NextWord
			&LVBuf b add
				c 1+ memcpy

		;; generate code
		79 &EmitByte call		;; cpush
		ret

	:*found
		;; generate code
		a 0 &EmitNumber call
		52 &EmitByte call		;; cset
		ret


;; ---------------------------------------------------------
;; CREATE , DOES>
;; ---------------------------------------------------------
	
	
:CREATE
  &GetNextWord call

  &NextWord &SetCompilingWord call 
  HERE &CREATE-HERE !
  ret

:Str_CommaCompileModeOnly %"COMMA_-_compile_mode_only

:COMMA (val--)
  HERE CELL allot !
  ret
  
:DODOES (non-public)
  (CREATE stored value in &CompilingWord)
  (store it in CompileBuf+1)
  (as index 0 is nulled at PreCompile)
  &CompilingWord &CompileBuf 1+ &BufCopy call

  &PreCompile call

  (restore CompilingWord)
  &CompileBuf 1+ &CompilingWord &BufCopy call
  
  (data pointer)
  &CREATE-HERE @ 0 &EmitNumber call
  
  (return address + 1 = past ret generated in DOES>)
  crget 1+ 0 &EmitNumber call
  83 &EmitByte call (jmp) 

  &SEMICOLON call

  ret

:Str_DOESCompileModeOnly %"DOES>_-_compile_mode_only

:DOES>
  (immediate - compiling the word with CREATE DOES>)
  
  &IsCompiling readb &*ok jmp?
  	cr &Str_DOESCompileModeOnly .str
  	PANIC
  :*ok

  (building call to DODOES)
  &DODOES 0 &EmitNumber call
  81 &EmitByte call (call) 

  (generating a ret; this returns from the code after DOES> but the)
  (compiler will still compile the rest of the code, adding it after)
  (the ret, and that's where the DODOES generates a JMP to, after first)
  (generating the CREATE-HERE address as set in CREATE)
    
  82 &EmitByte call (ret) (<-- this is the return addr inside DODOES)
  ret


:SEMICOLON
	(immediate)
	;; verify compile mode
	&IsCompiling readb &*ok jmp?
		;; ignore it
		ret
	:*ok

	;; info
	cr &CompilingWord .str &Str_ok_ .str

	;; add a ret instruction to CompileBuf
	0x52 &EmitByte call

	&CompileBuf readb print# &Str_bytes .str cr

	;; allocate permanent code buffer including length byte
	&CompileBuf &BufCreateCopy call cpush            (a=codeBuffer)
	
	&CompilingWord 			(name)
		a 1 add				(code - advance past the length byte)
		&CompilingWordMode readb	(mode)
			&CreateDictionaryEntry call

	;; switch off compile mode and clean up
	&PostCompile call

	;; all done
	ret



(variables are memory areas pointed to by named constants)
(constants are words, stored in the code fielf of the dictionary entry)
(and recognized via the mode field = CONSTANT)

:CONSTANT (value -- )
	cpush						(a=value)

	&GetNextWord call
	
	&NextWord	 			(name)
		a				(code)
		MODE_CONSTANT			(mode)
			&CreateDictionaryEntry call
	ret


(Use: value VARIABLE xx, then read and write it as a pointer to a word)

:VARIABLE ( value )
	HERE cellsize allot		(value ptr)
	swap				(ptr value)
	over				(ptr value ptr) 
	!				(ptr)
	&CONSTANT call 			(create word for the pointer)
	ret
	
:DOT
	print#s 
	&Str_Space .str
	ret

:NATIVE
	(marked as immediate in dictionary below)
	
	&GetNextWord call
	&NextWord nativec cpush  (a=native function address)
	&IsCompiling readb not &*interpreting jmp?
		(compiling mode)
		a 0 &EmitNumber call
		97 &EmitByte call     (native = a = 97)
		ret
	:*interpreting
		a native
		ret

:immediate
	;; change the CompilingWordMode to immediate
	1 &CompilingWordMode writeb
	ret		

:Str_Separator		%'--
:Str_Space		%"_

:Words
	cr
	&CustomDictionaryHeadPtr @ 0 eq &*noCustom jmp?
		&CustomDictionaryHeadPtr @ &DictShowWords call
		cr &Str_Separator .str cr
	:*noCustom
	&DictionaryHead &DictShowWords call
	cr
	ret

:.s
	dump
	ret
	

:CELL CELL ret
:CELLS CELL mul ret
	
:DictShowWords ( dictHead -- )
	@ cpush 		;; a=dict-entry
	0 cpush		;; b=chars per line
	:*next
		a 0 eq &*done jmp?
		
		a .str &Str_Space .str			;; name
		
		a readb 1+ b add b!		;; update b with number of characters
		b 70 lt &*noBreak jmp?
			cr
			0 b!
		:*noBreak

		a readb a add 1+ a!   		;; past the name
		a CELL+ CELL+ @ a!			;; a=a.next
		&*next jmp
	:*done
	ret

	

;; look up data addresses after the PROTECT tag

:GetAddrDictionaryHead &DictionaryHead ret
:GetAddrDebugFlag &DebugFlag ret
:GetAddrCompileBuf &CompileBuf ret
:GetAddrCompileBufEnd &CompileBufEnd ret
:GetAddrNextWord &NextWord ret
:GetAddrNextWordEnd &NextWordEnd ret
:GetAddrIsCompiling &IsCompiling ret
:GetAddrCompilingWord &CompilingWord ret
:GetAddrCompilingWordEnd &CompilingWordEnd ret
:GetAddrCompilingWordMode &CompilingWordMode ret
:GetAddrCompileStack &CompileStack ret
:GetAddrCompileStackEnd &CompileStackEnd ret
:GetAddrLVBuf &LVBuf ret
:GetAddrLVBufEnd &LVBufEnd ret
:GetAddrAllBuffers &AllBuffers ret
:GetAddrAllBuffersEnd &AllBuffersEnd ret

;; Utility Forth words for buffer processing

:BufReset ( bufPtr -- )
	cpush
	0 a writeb 
	ret

:BufAdd ( byte bufPtr -- )
	cpush	(a=bufPtr)
	a readb cpush (b=len)
	(byte)
	a b add 1+ writeb
	(update length)
	b 1+ a writeb
	ret



:DATA

;; The dictionary entry has the following format:
;;
;;  - name as string: 1 byte length, followed by characters
;;  - code reference: word pointer
;;  - flags: word
;;  - next: word
;;
;; Next=0 means terminated


;; Note that the dictionary is protected (appears before the :PROTECT tag), because it is
;; a readonly structure. It can still be extended by adding new words that point to it, in
;; effect pushing new entries on the stack that is the dictionary. And which is the 
;; Forth way.


:Dictionary

	;; # --- autogenerated content: Assembler:InlineDictionary
	;; #
			
	%'!             HEX:004A        BIN_INSTR       %NEXT        ;; J
	%'.str          HEX:0043        BIN_INSTR       %NEXT        ;; C
	%'1+            HEX:0064        BIN_INSTR       %NEXT        ;; d
	%'<<            HEX:0074        BIN_INSTR       %NEXT        ;; t
	%'>>            HEX:0075        BIN_INSTR       %NEXT        ;; u
	%'@             HEX:0049        BIN_INSTR       %NEXT        ;; I
	%'CELL+         HEX:006E        BIN_INSTR       %NEXT        ;; n
	%'HERE          HEX:0067        BIN_INSTR       %NEXT        ;; g
	%'PANIC         HEX:0030        BIN_INSTR       %NEXT        ;; 0
	%'PC            HEX:0050        BIN_INSTR       %NEXT        ;; P
	%'add           HEX:002B        BIN_INSTR       %NEXT        ;; +
	%'allot         HEX:004B        BIN_INSTR       %NEXT        ;; K
	%'and           HEX:0026        BIN_INSTR       %NEXT        ;; &
	%'andb          HEX:0071        BIN_INSTR       %NEXT        ;; q
	%'atoi          HEX:0031        BIN_INSTR       %NEXT        ;; 1
	%'call          HEX:0051        BIN_INSTR       %NEXT        ;; Q
	%'cellsize      HEX:006B        BIN_INSTR       %NEXT        ;; k
	%'cforce        HEX:0066        BIN_INSTR       %NEXT        ;; f
	%'cget          HEX:0033        BIN_INSTR       %NEXT        ;; 3
	%'clear         HEX:0077        BIN_INSTR       %NEXT        ;; w
	%'cpush         HEX:004F        BIN_INSTR       %NEXT        ;; O
	%'cr            HEX:0058        BIN_INSTR       %NEXT        ;; X
	%'crget         HEX:0041        BIN_INSTR       %NEXT        ;; A
	%'cset          HEX:0034        BIN_INSTR       %NEXT        ;; 4
	%'div           HEX:002F        BIN_INSTR       %NEXT        ;; /
	%'drop          HEX:006A        BIN_INSTR       %NEXT        ;; j
	%'dump          HEX:0070        BIN_INSTR       %NEXT        ;; p
	%'dup           HEX:006C        BIN_INSTR       %NEXT        ;; l
	%'eq            HEX:003D        BIN_INSTR       %NEXT        ;; =
	%'ge            HEX:0045        BIN_INSTR       %NEXT        ;; E
	%'gt            HEX:003E        BIN_INSTR       %NEXT        ;; >
	%'halt          HEX:005A        BIN_INSTR       %NEXT        ;; Z
	%'inv           HEX:0073        BIN_INSTR       %NEXT        ;; s
	%'jmp           HEX:0053        BIN_INSTR       %NEXT        ;; S
	%'jmp?          HEX:0054        BIN_INSTR       %NEXT        ;; T
	%'le            HEX:0046        BIN_INSTR       %NEXT        ;; F
	%'lt            HEX:003C        BIN_INSTR       %NEXT        ;; <
	%'memcpy        HEX:0044        BIN_INSTR       %NEXT        ;; D
	%'mul           HEX:002A        BIN_INSTR       %NEXT        ;; *
	%'n2code        HEX:0032        BIN_INSTR       %NEXT        ;; 2
	%'native        HEX:0061        BIN_INSTR       %NEXT        ;; a
	%'nativec       HEX:0063        BIN_INSTR       %NEXT        ;; c
	%'ne            HEX:0068        BIN_INSTR       %NEXT        ;; h
	%'not           HEX:0069        BIN_INSTR       %NEXT        ;; i
	%'null          HEX:007A        BIN_INSTR       %NEXT        ;; z
	%'or            HEX:007C        BIN_INSTR       %NEXT        ;; |
	%'orb           HEX:0072        BIN_INSTR       %NEXT        ;; r
	%'over          HEX:006F        BIN_INSTR       %NEXT        ;; o
	%'print         HEX:0057        BIN_INSTR       %NEXT        ;; W
	%'print#        HEX:0059        BIN_INSTR       %NEXT        ;; Y
	%'print#s       HEX:0062        BIN_INSTR       %NEXT        ;; b
	%'printb        HEX:004C        BIN_INSTR       %NEXT        ;; L
	%'printc        HEX:0055        BIN_INSTR       %NEXT        ;; U
	%'rback?        HEX:0037        BIN_INSTR       %NEXT        ;; 7
	%'readb         HEX:0047        BIN_INSTR       %NEXT        ;; G
	%'readc         HEX:0076        BIN_INSTR       %NEXT        ;; v
	%'ret           HEX:0052        BIN_INSTR       %NEXT        ;; R
	%'rfwd?         HEX:0036        BIN_INSTR       %NEXT        ;; 6
	%'streq         HEX:0042        BIN_INSTR       %NEXT        ;; B
	%'sub           HEX:002D        BIN_INSTR       %NEXT        ;; -
	%'swap          HEX:006D        BIN_INSTR       %NEXT        ;; m
	%'u2spc         HEX:005F        BIN_INSTR       %NEXT        ;; _
	%'writeb        HEX:0048        BIN_INSTR       %NEXT        ;; H


	;; ----------------------------------------------------------
	;; Upper case system words

	%'.		%DOT		BIN_NORMAL			%NEXT
	%'IF		%IF		BIN_IMMEDIATE		%NEXT
	%'THEN		%THEN		BIN_IMMEDIATE		%NEXT
	%'ELSE		%ELSE		BIN_IMMEDIATE		%NEXT
	%'BEGIN		%BEGIN		BIN_IMMEDIATE		%NEXT
	%'AGAIN?	%AGAIN?		BIN_IMMEDIATE		%NEXT
	%'CONSTANT	%CONSTANT	BIN_NORMAL			%NEXT
	%'VARIABLE	%VARIABLE	BIN_NORMAL			%NEXT
	%'NATIVE	%NATIVE		BIN_IMMEDIATE		%NEXT
	%'Dict		%Dict		BIN_NORMAL			%NEXT
	%'DictUse	%DictUse	BIN_NORMAL			%NEXT
	%'DictClear	%DictClear	BIN_NORMAL			%NEXT
	%'IN		%IN		BIN_IMMEDIATE			%NEXT
	%'.W		%.W		BIN_NORMAL			%NEXT    ;; show addr to DE for word
	%'>>str		%>>str		BIN_NORMAL			%NEXT
	%'?C		%?C		BIN_NORMAL			%NEXT    ;; get code ptr for word

	%'CELL		%CELL		BIN_NORMAL			%NEXT
	%'CELLS		%CELLS		BIN_NORMAL			%NEXT
	
	%'CREATE	%CREATE		BIN_NORMAL			%NEXT
	%',		%COMMA		BIN_NORMAL			%NEXT
	%'DOES>		%DOES>		BIN_IMMEDIATE			%NEXT
	
	;; ----------------------------------------------------------
	;; More system words

	%'BufReset		%BufReset		BIN_NORMAL		%NEXT
	%'BufAdd		%BufAdd			BIN_NORMAL		%NEXT
	%'ShowBuffer		%ShowBuffer		BIN_NORMAL		%NEXT
	%'BufCopy		%BufCopy		BIN_NORMAL		%NEXT
	%'BufCreateCopy		%BufCreateCopy		BIN_NORMAL		%NEXT
	%'EmitNumber		%EmitNumber		BIN_NORMAL		%NEXT
	%'EmitByte		%EmitByte		BIN_NORMAL		%NEXT
	%'GetNextWord		%GetNextWord		BIN_NORMAL		%NEXT
    	%'PreCompile  		%PreCompile		BIN_NORMAL		%NEXT
    	%'PostCompile  		%PostCompile		BIN_NORMAL		%NEXT
	%'SetCompilingWord	%SetCompilingWord	BIN_NORMAL		%NEXT
	
	;; ----------------------------------------------------------
	;; System addresses as words

	%'&DictionaryHead	%GetAddrDictionaryHead		BIN_NORMAL	%NEXT
	%'&DebugFlag 		%GetAddrDebugFlag		BIN_NORMAL	%NEXT
	%'&CompileBuf 		%GetAddrCompileBuf		BIN_NORMAL	%NEXT
	%'&CompileBufEnd	%GetAddrCompileBufEnd		BIN_NORMAL	%NEXT
	%'&LVBuf		%GetAddrLVBuf			BIN_NORMAL	%NEXT
	%'&LVBufEnd		%GetAddrLVBufEnd		BIN_NORMAL	%NEXT
	%'&NextWord		%GetAddrNextWord		BIN_NORMAL	%NEXT
	%'&NextWordEnd		%GetAddrNextWordEnd		BIN_NORMAL	%NEXT
	%'&AllBuffers		%GetAddrAllBuffers		BIN_NORMAL	%NEXT
	%'&AllBuffersEnd	%GetAddrAllBuffersEnd		BIN_NORMAL	%NEXT
	%'&IsCompiling		%GetAddrIsCompiling		BIN_NORMAL	%NEXT
	%'&CompilingWordMode	%GetAddrCompilingWordMode	BIN_NORMAL	%NEXT
	%'&CompilingWord	%GetAddrCompilingWord		BIN_NORMAL	%NEXT
	%'&CompilingWordEnd	%GetAddrCompilingWordEnd	BIN_NORMAL	%NEXT
	%'&CompileStack		%GetAddrCompileStack		BIN_NORMAL	%NEXT
	%'&CompileStackEnd	%GetAddrCompileStackEnd		BIN_NORMAL	%NEXT
	
	;; ----------------------------------------------------------
	;; Colon, local variables, semicolon etc
		
	%'?			%Words		BIN_NORMAL	%NEXT
	%'.s			%.s		BIN_NORMAL	%NEXT
	%'words			%Words		BIN_NORMAL	%NEXT
	%':			%COLON		BIN_NORMAL	%NEXT
	%'=>			%LVSet		BIN_IMMEDIATE	%NEXT
	HEX:013B		%SEMICOLON	BIN_IMMEDIATE	%NEXT
	%'IMMEDIATE		%immediate	BIN_IMMEDIATE	w0	;; <-- w0 = terminating the linked list
:DictionaryEnd

:PROTECT		;; protects data before this point against writes - reads are allowed

:DebugFlag		b0

:DictionaryHead %Dictionary

:CustomDictionaryHeadPtr w0

;;; ---------------------------------------------------------------------------------
;;; buffers used to process input and compile code - available for scratch use
;;; at normal runtime, not compiling, either separately, or together (as they
;;; are placed next to each other in memory). Including the NextNumber and the
;;; CompileStack, we get a AllBuffers of 137 bytes
;;; ---------------------------------------------------------------------------------



:IsCompiling		b0
:CompilingWordMode	b0					;; NORMAL or IMMEDIATE
:CREATE-HERE		w0
:NextNumber		w0 					;; single word - output when parsing ok (atoi op)

:AllBuffers

:CompilingWord	b0 w0 w0 w0 w0 w0 w0 w0 w0		;; 16 characters stringbuffer
:CompilingWordEnd

:CompileBuf	w0 w0 w0 w0 w0 w0 w0 w0 		;; + up to 63 code bytes (1 byte length)
		w0 w0 w0 w0 w0 w0 w0 w0			;; 
		w0 w0 w0 w0 w0 w0 w0 w0			;; For colon compiler
		w0 w0 w0 w0 w0 w0 w0 w0			;; and as scratch buffer at runtime
			
:CompileBufEnd

:NextWord	w0 w0 w0 w0 w0 w0 w0 w0 		;; string buffer
		w0 w0 w0 w0 w0 w0 w0 w0			;; and scratch buffer at runtime
:NextWordEnd

:LVBuf		w0 w0 w0 w0 w0 w0 w0 w0 		;; local variables in colon compiler - 32 bytes
		w0 w0 w0 w0 w0 w0 w0 w0		    ;; and scratch buffer at runtime
:LVBufEnd

:CompileStack	b0 w0 w0 w0 w0 w0 w0 w0 w0 		
				;; 8 words each consists of type (1 byte) and offset in CompileBuf (1 byte)
				;; see COMPS_TYPE_* defs
:CompileStackEnd
:AllBuffersEnd

:MemoryEnd


