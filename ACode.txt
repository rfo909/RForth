
:Main
 	cr 'HERE #1 show    ;; does not assemble properly!!
	HERE print
	
	;; init
	null &ConsFree !		;; initialize ConsFree pointer to zero

	&ConsAlloc call
	&ConsAlloc call

	cr 'Done #1 show
		
	;; test
	;&ConsGet call 
	;	&ConsDispose call
	&Halt jmp	

:Error ;; ( sym sym symCount -- )
	show
	&Halt jmp
	
:Halt
	&Halt jmp
	
	
;; Stack operations


;; CONS cells are created as a CAR+CDR tuple, each value a Word. They are allotted
;; as needed, but also freelisted when disposed off. To calculate the CDR address
;; from the Cons pointer: W+

:ConsFree 0 0 0 0	;; freelist pointer 	
	;; 0 means empty
	;; Using four instructions to generate four bytes as a placeholder.
	;; The value is nulled in :Init before use. Using 4 bytes instead
	;; of 2 to ensure compatibility with 4 byte wordsize - any more is
	;; unthinkable for embedded devices

:ConsAlloc  ; ( -- )
	&ConsFree cpush		;; a=&ConsFree
	HERE   cpush		;; b=Ptr to new Cons
	wordsize #2 mul allot	;; reserve space for Cons
		
	a @ b !			;; ptr.CAR=&ConsFree
	b a !			;; &ConsFree=ptr	
	
	;; no return value
	ret


:ConsGet  ; ( -- ConsPtr) - get Cons cell from free list (call ConsAlloc first if empty)
	&ConsFree cpush   ;; a=&ConsFree
	
	a @ null ne &*FreelistOk jmp?
		;; freelist is empty, allocate one Cons
		&ConsAlloc call
	
	:*FreelistOk
	
	;; got data in freelist, take first cons

	a @  		;; (ptr to Cons)

	dup W+ a !   ;; &ConsFree = ptr.cons

	;; (Ptr)
	ret
	
:ConsDispose  ;; (ptr -- )
	&ConsFree cpush 	;; a=&ConsFree
	
	dup a swap 		;; (ptr &ConsFree ptr)
		!		;; ptr.car=&ConsFree
		
	;; (ptr)
	a !			;; &ConsFree=ptr
	;; no return value
	ret

;; ---------------------------------
;; Reserved tags, must be present
;; ---------------------------------	

:DATA		
	;; data is generated here - the tag is used by disassembler to 
	;; show bytes correctly beyond this point (not as instructions)


