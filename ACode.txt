;; This file implements a state machine for the REPL and compiler.
;;
;; The data stack is already defined, as this "pretend assembly" exists on
;; a virtual stack machine. The return stack also exists, and there are
;; instructions call and ret which use it. The state machine that follows
;; only uses jumps.
;;
;; Towards the end follows the data fields. Using the following notation to
;; create placeholders and values in memory:
;;
;;  HEX:0001 
;;  %'symbol     - generates one length byte followed by the characters
;;  %tag         - inlines a tag address as a two byte word
;;  %NEXT        - generates a pointer one word ahead, then writes that value as a word
;;  b0           - generates a null byte, shortcut for HEX:00
;;  w0           - generates a null word, shortcut for HEX:0000
;;
;; Note tags must be defined earlier in the file, as the %tag references are not
;; part of the resolve scheme implemented in NumberTable

;; ------------ top of file ----------

#define DIGIT_0		48
#define DIGIT_9		57



:Init
	&Dictionary 0 global!			;; store dictionary pointer in 0 global

:REPL
	cr "Ready>_ .str
	&ResetCompile call
	&StartNextWord jmp

:StartNextWord
	&ResetWordParser call
	&GetChar jmp

:GetChar
	readc &NextChar writeb

	&NextChar readb 
		0x20 eq &ProcessSpace jmp?	;; is it a space?

	;; add character to NextWord, regardless of whether it is believed to be a number
	;; because future characters may change it from number to word
			
	&NextChar readb
		&NextWord readb 1 add &NextWord add	;; write pos
			writeb				
	&NextWord readb 1 add &NextWord writeb			;; update length


	&IsNumber readb &ProcessDigit jmp?		;; if IsNumber is set, go directly there
	&IsWord readb &ProcessChar jmp?		;; is IsWord is set, go directly there
	
	&NextChar readb 
		dup DIGIT_0 ge			;; '0' 
		swap DIGIT_9 le and 			;; '9'
			&ProcessDigit jmp?	;; is it a digit?
			
	&ProcessChar jmp			;; assuming word


:ProcessSpace
	&NextWord readb
		0 eq &StartNextWord jmp?	;; no word, just a space, ignore it
		
	&IsNumber readb &CompleteNumber jmp?
	&CompleteWord jmp
	
:ProcessDigit
	1 &IsNumber writeb					;; set IsNumber flag = 1
	
	;; calculate digit value		
	&NextChar readb
		DIGIT_0 sub 9 gt &InvalidNumber jmp?	;; if bigger than 9, invalid number
		
	&NextNumber @ 10 mul 
		&NextChar readb DIGIT_0 sub add 
			&NextNumber !			;; update NextNumber
	&GetChar jmp					;; GOTO GetChar

:ProcessChar
	1 &IsWord writeb					;; set IsWord flag = 1
	&GetChar jmp					;; GOTO GetChar
	
:InvalidNumber
	0 &IsNumber writeb					;; change from IsNumber to IsWord
	1 &IsWord writeb
	&GetChar jmp
	
:CompleteNumber
	cr "Got_number_ .str 
	&NextNumber @ print#
	;
	&IsLiteral readb &InvalidLiteralNumber jmp?	;; numbers can't be dictionary names
	&IsCompiling readb &CompileNumber jmp?		;; are we in compile mode?
	&NextNumber @					;; push number on stack
	&StartNextWord jmp					;; GOTO NextWord
	
	
:CompleteWord
	cr "Got_word_ .str &NextWord .str
	&NextWord &DictLookup call 			;; dictionary entry pointer or null
	
	; ( dictEntryPointer )
	dup 
		null eq &*notFound jmp?
		dup readb add 1 add			;; advance past the string	
	
	; (dictEntryPointer past the string - pointing at CODE, MODE, NEXT (words)
	; ( CODE-ptr )
	dup W+ @  
		; (CODE-ptr MODE-value) 
		&ExecuteWord call
	
	&StartNextWord jmp
	
	:*notFound
		drop					;; dup'ed value before call
		cr "Unknown_word_ .str	
		&NextWord .str
		&REPL jmp	


:InvalidLiteralNumber					;; expected word name 
	cr
	"Unexpected_number_ .str
	&NextNumber @ print			
	&REPL jmp
	
:CompileNumber
	&NextNumber @					;; the number
		&CompileBuf dup readb add		;; write position in CompileBuf
			n2code				;; generate code, return N = number of bytes written
	
	; (N)
	&CompileBuf readb 				;; old length
		add 					;; add to N 
			&CompileBuf writeb		;; update counter for CompileBuf

	&StartNextWord jmp





;; -----------------------------------------------
;; Utility subroutines, invoked with call
;; -----------------------------------------------

:ResetCompile
	0 &IsCompiling writeb			;; set IsCompiling flag = 0 - set to 1 when compiling a word
	0 &IsCompilingWord writeb
	0 &IsCompilingWordMode writeb
	ret

:ResetWordParser
	0 &IsNumber writeb				;; set IsNumber flag = 0
	0 &IsWord writeb				;; set IsWord flag = 0
	0 &IsLiteral writeb				;; set IsLiteral flag = 0	
	0 &NextWord writeb				;; set next word length = 0
	0 &NextNumber !				;; set next number = 0 (word write)
	ret


:EmitByte   ;; ( byte -- )
	cpush				;; a=bytevalue
	&CompileBuf readb 1 add cpush	;; b=offset 
	a b &CompileBuf add writeb
	b &CompileBuf writeb
	ret
	
:DictLookup ;; ( str -- stackEntry|null )
	cpush				;; a=str
	&Dictionary cpush		;; b=current dictionary entry
	:*next
		b @ null eq &*notFound jmp?	;; pointer is null, not found
		b a streq &*found jmp?		;; got a match
		
		b 
			b readb add 1 add 	;; byte count past string
				W+ W+			;; past code-pointer and flags
					@			;; read next pointer
		b!						;; update b with it
		&*next jmp
	:*notFound
		null ret
	:*found
		b ret

:ExecuteWord ;; ( code-ptr mode-value -- ) ;; decide how to handle word
	swap cpush				; a=code  
	cpush    				; b=mode-value
	
	&IsCompiling readb not &*NotCompiling jmp?
		;; --- compiling
		b 1 eq &*callCode jmp?		;; mode==immediate: call CODE
		b 0 eq &*generateCall jmp?	;; mode==normal: generate call to CODE
		b 2 eq &*inlineCode jmp?	;; mode==inline: add single instruction to code
		ret
	:*NotCompiling
		;; --- interactive		
		b 0 eq &*callCode jmp?		;; mode==normal, call the code
		b 2 eq &*callInline jmp?	;; mode==inline, execute that instruction
	
		cr "Immediate_word_ .str
		&NextWord .str
		"_has_no_interactve_use .str
		&REPL jmp
		
	:*callCode
		cr "callCode_ .str a print
		a call 
		ret
	:*generateCall
		cr "generateCall_ .str a print
		a						;; the number
			&CompileBuf dup readb add		;; write position in CompileBuf
				n2code				;; generate code, return N = number of bytes written
		
		; (N)
		&CompileBuf readb 				;; old length
			add 					;; add to N 
				&CompileBuf writeb		;; update counter for CompileBuf

		ret
	:*inlineCode
		cr "inlineCode_ .str a print
		a @ &EmitByte call
		;; -- the inline symbols have the opcode encoded as 0x00nn in the code field
		ret
	:*callInline
		cr "callInline_ .str a print
		0 &CompileBuf writeb				;; clear CompileBuf (this is interactive mode, so buffer not in use)
		a @ &EmitByte call				;; add the opcode
		0x52 &EmitByte call  				;; add "R" = ret
		&CompileBuf 1 add call    			;; invoke CompileBuf offset 1 (as byte 0 is the length)
		ret
	
;; -----------------------------------------------
;; Implementations for initial complex words in dictionary
;; -----------------------------------------------

	
:COLON
	;; already in compile mode?
	&IsCompiling readb &*nested jmp?

	;; set compile mode
	1 &IsCompiling writeb

	;; next word is to be a literal
	1 &IsLiteral writeb

	;; ensure compile buffer is ready
	0 &CompileBuf writeb

	;; that's all?
	ret

	:*nested
		cr "Can_not_nest_colons:_ .str "Ignoring .str
		ret
	
:SEMICOLON
	;; verify compile mode
	&IsCompiling readb &*ok jmp?
		;; ignore it
		ret
	:*ok
		;; check that there is a symbol
		&IsCompilingWord readb 0 eq &*noSymbol jmp?

		;; info
		cr "Finishing_word_ .str &IsCompilingWord .str

		;; add a ret instruction to CompileBuf
		0x52 &EmitByte call

		;; allocate buffer not including length byte
		HERE cpush								;; a=codebuffer
			&CompileBuf readb 
				allot

		;; copy code into codebuffer
		&CompileBuf 1 add
			a
				&CompileBuf readb
					memcpy
		
		;; allocate dictionary entry
		HERE cpush							;; b=dictEntry
		&IsCompilingWord readb 1 add		;; length of symbol
			wordsize 3 mul add				;; code pointer, flags, next
				allot

		;; copy symbol
		&IsCompilingWord					;; src
			b								;; target
				&IsCompilingWord readb 1 add	;; byte count
					memcpy
		
		;; advance dict entry pointer past name
		b readb b add cpush					;; c=point to CODE field

		;; write code address and advance c
		a c !
		c W+ c!

		;; write mode and advance pointer
		&IsCompilingWordMode readb
			c !
		c W+ c!

		;; write next pointer
		&DictionaryHead @ 
			c !

		;; update DictionaryHead
		b &DictionaryHead !

		;; all done
		ret

	:*noSymbol
		"No_symbol_defined_for_word .str
		halt
		&ResetCompile call
		ret
	
:immediate
	;; change the IsCompilingWordMode to immediate
	1 &IsCompilingWordMode writeb
	ret
		


:DATA

;; The dictionary entry has the following format:
;;
;;  - name as string: 1 byte length, followed by characters
;;  - code reference: word pointer
;;  - flags: word
;;  - next: word
;;
;; Next=0 means terminated

;; use these in the Dictionary only, as they generate raw memory values, not code!

#define NORMAL 		HEX:0000
#define IMMEDIATE	HEX:0001
#define INLINE		HEX:0002	;; code pointer is single-byte instruction: "00xx"

;; Note that the dictionary is protected (appears before the :PROTECT tag), because it is
;; a readonly structure. It can still be extended by adding new words that point to it, in
;; effect pushing new entries on the stack that is the dictionary. And which is the 
;; Forth way.


:Dictionary
	;; # --- autogenerated content: Assembler:InlineDictionary
	;; #
		
	%'!             HEX:004A        INLINE      %NEXT        ;; J
	%'.str          HEX:0043        INLINE      %NEXT        ;; C
	%'<<            HEX:0074        INLINE      %NEXT        ;; t
	%'>>            HEX:0075        INLINE      %NEXT        ;; u
	%'@             HEX:0049        INLINE      %NEXT        ;; I
	%'HERE          HEX:0067        INLINE      %NEXT        ;; g
	%'W+            HEX:006E        INLINE      %NEXT        ;; n
	%'a             HEX:0061        INLINE      %NEXT        ;; a
	%'a!            HEX:0064        INLINE      %NEXT        ;; d
	%'add           HEX:002B        INLINE      %NEXT        ;; +
	%'allot         HEX:004B        INLINE      %NEXT        ;; K
	%'and           HEX:0026        INLINE      %NEXT        ;; &
	%'andb          HEX:0071        INLINE      %NEXT        ;; q
	%'b             HEX:0062        INLINE      %NEXT        ;; b
	%'b!            HEX:0065        INLINE      %NEXT        ;; e
	%'c             HEX:0063        INLINE      %NEXT        ;; c
	%'c!            HEX:0066        INLINE      %NEXT        ;; f
	%'cpush         HEX:004F        INLINE      %NEXT        ;; O
	%'cr            HEX:0058        INLINE      %NEXT        ;; X
	%'dcopy         HEX:004D        INLINE      %NEXT        ;; M
	%'dget          HEX:004E        INLINE      %NEXT        ;; N
	%'div           HEX:002F        INLINE      %NEXT        ;; /
	%'drop          HEX:006A        INLINE      %NEXT        ;; j
	%'dump          HEX:0070        INLINE      %NEXT        ;; p
	%'dup           HEX:006C        INLINE      %NEXT        ;; l
	%'eq            HEX:003D        INLINE      %NEXT        ;; =
	%'ge            HEX:0045        INLINE      %NEXT        ;; E
	%'global        HEX:0078        INLINE      %NEXT        ;; x
	%'global!       HEX:0079        INLINE      %NEXT        ;; y
	%'gt            HEX:003E        INLINE      %NEXT        ;; >
	%'halt          HEX:005A        INLINE      %NEXT        ;; Z
	%'inv           HEX:0073        INLINE      %NEXT        ;; s
	%'le            HEX:0046        INLINE      %NEXT        ;; F
	%'lt            HEX:003C        INLINE      %NEXT        ;; <
	%'memcpy        HEX:0044        INLINE      %NEXT        ;; D
	%'mul           HEX:002A        INLINE      %NEXT        ;; *
	%'n2code        HEX:0032        INLINE      %NEXT        ;; 2
	%'n2code3       HEX:0031        INLINE      %NEXT        ;; 1
	%'ne            HEX:0068        INLINE      %NEXT        ;; h
	%'not           HEX:0069        INLINE      %NEXT        ;; i
	%'null          HEX:007A        INLINE      %NEXT        ;; z
	%'or            HEX:007C        INLINE      %NEXT        ;; |
	%'orb           HEX:0072        INLINE      %NEXT        ;; r
	%'over          HEX:006F        INLINE      %NEXT        ;; o
	%'print         HEX:0057        INLINE      %NEXT        ;; W
	%'print#        HEX:0059        INLINE      %NEXT        ;; Y
	%'printb        HEX:004C        INLINE      %NEXT        ;; L
	%'printc        HEX:0055        INLINE      %NEXT        ;; U
	%'readb         HEX:0047        INLINE      %NEXT        ;; G
	%'readc         HEX:0076        INLINE      %NEXT        ;; v
	%'ret           HEX:0052        INLINE      %NEXT        ;; R
	%'show          HEX:0056        INLINE      %NEXT        ;; V
	%'streq         HEX:0042        INLINE      %NEXT        ;; B
	%'sub           HEX:002D        INLINE      %NEXT        ;; -
	%'swap          HEX:006D        INLINE      %NEXT        ;; m
	%'wordsize      HEX:006B        INLINE      %NEXT        ;; k
	%'writeb        HEX:0048        INLINE      %NEXT        ;; H

	;; ----------------------------------------------------------
		
	%':		%COLON		NORMAL		%NEXT
	HEX:013B	%SEMICOLON	IMMEDIATE	%NEXT
	%'immediate	%immediate	IMMEDIATE	w0	;; <-- w0 = terminating the linked list
:DictionaryEnd


; Note: The dictionary needs to be extended, and then must exist after DATA
	
:PROTECT

:DictionaryHead %Dictionary

:IsCompiling 	b0
:IsCompilingWord	b0 w0 w0 w0 w0  w0 w0 w0 w0   ;; length + 16 bytes
:IsCompilingWordMode b0						;; modified by the immediate word, default is 0 (NORMAL)

:IsNumber 	b0
:IsWord 	b0
:IsLiteral	b0

:NextChar 	b0
:NextWord			;; length + 16 characters
	b0
	b0 b0 b0 b0   b0 b0 b0 b0 	; 8 bytes
	b0 b0 b0 b0   b0 b0 b0 b0 	; 8 bytes

:NextNumber w0


:CompileBuf	; 256 bytes: one length byte 255 data bytes
	w0 w0 w0 w0 w0 w0 w0 w0		; 16 bytes
	w0 w0 w0 w0 w0 w0 w0 w0		; 16 bytes
	w0 w0 w0 w0 w0 w0 w0 w0		; 16 bytes
	w0 w0 w0 w0 w0 w0 w0 w0		; 16 bytes

	w0 w0 w0 w0 w0 w0 w0 w0		; 16 bytes
	w0 w0 w0 w0 w0 w0 w0 w0		; 16 bytes
	w0 w0 w0 w0 w0 w0 w0 w0		; 16 bytes
	w0 w0 w0 w0 w0 w0 w0 w0		; 16 bytes

	w0 w0 w0 w0 w0 w0 w0 w0		; 16 bytes
	w0 w0 w0 w0 w0 w0 w0 w0		; 16 bytes
	w0 w0 w0 w0 w0 w0 w0 w0		; 16 bytes
	w0 w0 w0 w0 w0 w0 w0 w0		; 16 bytes

	w0 w0 w0 w0 w0 w0 w0 w0		; 16 bytes
	w0 w0 w0 w0 w0 w0 w0 w0		; 16 bytes
	w0 w0 w0 w0 w0 w0 w0 w0		; 16 bytes
	w0 w0 w0 w0 w0 w0 w0 w0		; 15 bytes

:CompileStack	; nested levels of patchback words like IF THEN etc - bytes only
	w0 w0 w0 w0 w0 w0 w0 w0          ; one byte for count and 15 bytes of data
	
:MemoryEnd


