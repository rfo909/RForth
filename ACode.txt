; This is the base system that eventually will implement some sort of a
; REPL on a microcontroller. It contains instructions, organized under
; tags at two levels, which are employed for direct jumps (jmp), conditional 
; jumps (jmp?) and calls (call), which assume a return (ret).
;
; The outer level of tags is denoted :xxx to define a tag, and &xxx to refer
; it. All tag references result in 5 bytes of code, which when run puts the
; address on the stack. Outer level tags are global.
;
; Then there are local tags. These exist only in the scope between outer 
; tags. This means common words like "again" or "exit" can be used
; in different functions, without mixing up.
;
; These are defined with :*xxx and referred via &*xxx.
;
; The assembler handles patching all forward tag references when building
; the code.
;

#DictHead 0 global
#InputBuffer 1 global
#SymHead 2 global


:Init
	;; create variables in normal r/w heap memory

	HERE 0 global!		;; DictHead
	wordsize allot

	HERE 1 global!		;; InputBuffer - points to input buffer
	256 allot		;; 1 global points to this buffer

	HERE 2 global!		;; SymHead - symbol list in HEAP memory
	wordsize allot 
	
	;; initialize InputBuffer length byte to 0
	0 InputBuffer writeb
		
	;; register inputbuffer and event handler
	InputBuffer 0 registerPointer				;; this triggers availability of the input buffer
	&SerialWordReceived 1 registerPointer		;; this triggers availability of calling it when data in input buffer
	
	&Main jmp
	
:SerialWordReceived 
	InputBuffer cpush   ;; a points to inputbuffer
	;;cr "Word_" .str a .str ""_received .str
	
	a &DictLookup call cpush  ;; b is result

	b null eq &*NotFound jmp?
		b call 			;; call code for word
		&*WordConsumed jmp
	:*NotFound
		cr "Word_" .str a .str ""_not_found .str
		
	:*WordConsumed	
		;; indicate word consumed
		0 a writeb 
	ret

:Main

	cr
	

:Halt 
	halt
	;;; Forever loop, serving events only from now on
	&Halt jmp
	
:DictLookup ; ( stringPtr -- codePtr )
	cpush				;; a=string
	&Dictionary cpush		;; b=current entry
	:*next
		b @ 0xFFFF eq &*notFound jmp?
		a b streq &*found jmp?
		b readb 1 add
			b add 
				wordsize add b!
		&*next jmp
	:*notFound
		null ret
	:*found
		b readb 1 add 
			b add @ ret




:IDup dup ret
:IN 42 ret
:IAdd add ret
:IPrint# print# ret
:Icr cr ret

;; The DATA tag affects how stuff is displayed by the disassembler
;;
;; Note that the interpreter should enforce a different rule. The output
;; from the assembler is as follows
;;
;; - Code - all code in this file, including the DATA section
;; - NumberTable - all tag references, all static numbers and all static symbols 'xxx in this file
;; - Symbols - all static symbols in this file
;;
;; The interpreter, after populating its virtual RAM with this output, and with offsets for where
;; NumberTable and Symbols are located, then creates its own runtime structures (3 stacks etc).
;; When this is done, it stores the value of HERE internally, which is the address of the next available
;; RAM location, and uses this to prevent wild pointer writes into the code and the runtime
;; structures.

:DATA

;; The literals (%'xxx and %tag are one-pass only, no patching, so they must only refer
;; to tags defined above, not below. The strings are written with a length byte followed
;; by characters, and the references as a Word-sized numbers (2 bytes). These become part
;; of the hex string output from the assembler.

:Dictionary
	%'dup 		%IDup
	%'n 		%IN
	%'add 		%IAdd
	%'print#	%IPrint#
	%'cr		%Icr
	;; end mark
	HEX:FFFF
