: PINB 0x23 ;
: DDRB 0x24 ;
: PORTB 0x25 ;
: PINC 0x26 ;
: DDRC 0x27 ;
: PORTC 0x28 ;
: PIND 0x29 ;
: DDRD 0x2a ;
: PORTD 0x2b ;

: wait =ms millis ms + =ms loop{ millis ms > break  } ;

: Reg! =addr =valueMask =clearMask
	addr read clearMask ! &
		valueMask | addr write ;


: blink
	b0010_0000 =m
	m m DDRB Reg!
	loop{
		m m PORTB Reg! 500 wait
		m 0 PORTB Reg! 400 wait
	}
;


: N-blink =n
	b0010_0000 =m
	m m DDRB Reg!
	loop{
		m m PORTB Reg! 1000 wait
		m 0 PORTB Reg! 500 wait
		n 1 - =n
		n 0 <= break
	}
;

# Integrate DStackValue with local variables!
# 

# Must serialize data types, not using bitmasks.

## Data types
# :bool
# :number -> :bool ok
# :byte
# :char
# :long :ulong
# :struct:xxx
# :list:yyy
# 
# element list .add
# element struct 'x .set
# 
# !! = write
# ?? = read
#
# Malloc for storing shared data in RAM, with managed pointers (GC)
# Malloc is synchronized, and may reallocate data 
# Threads?

# Defines for constants instead of words?
#
# Create linear storage drivers for readonly Flash storage
#
# Use SRAM to cache serialized functions from such storage.
# 
# Use linear storage driver on on-chip EEPROM. 

# TWI (i2c) directly via register manipulation
# (Arduino <Wire.h> consumed 200+ bytes of ram, probably for buffers etc)

: Reg! =addr =valueMask =clearMask
	addr read clearMask ! &
		valueMask | addr write ;

: TWBR 0xb8 ;
: TWSR 0xb9 ;
: TWAR 0xba ;
: TWDR 0xbb ;
: TWCR 0xbc ;
: TWAMR 0xbd ;


#######
### https://electronics.stackexchange.com/questions/309135/i2c-atmega328p-as-master-and-24lc256-as-slave
---------------------------

# TWCR bits

: TWINT 7 ;
: TWEA 6 ;
: TWSTA 5 ;
: TWSTO 4 ;
: TWWC 3 ;
: TWEN 2 ;
: TWIE 0 ;

# TWSR bits

: TWPS1 1 ;
: TWPS0 0 ;


# Clock speed
: FOSC 16000000 :ulong ;
: START 0x08 ;
: MT_SLA_ACK 0x18 ;
: MT_SLA_NACK 0x18 ;
: DEV_ADDR 0x50 ;


: setClock =khz 
	1 TWEN << 
		TWCR write
	1 TWPS0 << 
		TWSR Reg!
	FOSC khz / 
		TWBR write
	TWBR read 16 - 
		TWBR write
	TWBR read 8 / 
		TWBR write
;
	
: sendStart
	1 TWINT << 1 TWEN << 1 | TWSTA << | TWCR write
	loop{ TWCR read 1 TWINT << & break }
;

: sendStop 
	1 TWINT << 1 TWEN << 1 TWSTO << | | TWCR write
	loop{ TWCR read 1 << TWINT & break }
;

: checkStartStatus
	TWSR read 0xF8 & START ==
;

: sendAddress =addr =wbit
	addr & 0x7F 1 << wbit 0x01 & | TWDR write
	1 TWINT << 1 TWEN << | TWCR write
	loop{ TWCR read 1 TWINT << & break }
;

: checkMTSlaveAck
	TWSR read 0xF8 & MT_SLA_ACK == 
;

: checkMTSlaveNack 
	TWSR read 0xF8 MT_SLA_NACK == 
;


: transmitData =data
	data TWDR write
	1 TWINT << 1 TWEN << | TWCR write
	loop{ TWCR read 1 TWINT << & break }
	
	0x00 transmitData
	checkMDSlaveAck ! if { 999 ERROR }
;

# Enable pins

: i2c_main
	0xFF DDRC write
	0x30 PORTC write
	0xFF DDRD write
	
	100 setClock
	sendStart
	checkStartStatus not if{ ERROR }
	
	devAddress 0 sendAddress

	checkMTSlaveAck ! if { ERROR }
	0
;
