; This is the base system that eventually will implement some sort of a
; REPL on a microcontroller. It contains instructions, organized under
; tags at two levels, which are employed for direct jumps (jmp), conditional 
; jumps (jmp?) and calls (call), which assume a return (ret).
;
; The outer level of tags is denoted :xxx to define a tag, and &xxx to refer
; it. All tag references result in 5 bytes of code, which when run puts the
; address on the stack. Outer level tags are global.
;
; Then there are local tags. These exist only in the scope between outer 
; tags. This means common words like "again" or "exit" can be used
; in different functions, without mixing up.
;
; These are defined with :*xxx and referred via &*xxx.
;
; The assembler handles patching all forward tag references when building
; the code.
;
; ---
;
; Note that the :Init and :Main tags are never jumped to nor called, and 
; so they exist for clarity only. Also note that the remaining global tags
; before the :DATA are supposed to be call'ed, and end in 'ret' to return.
;

:Init
	&DATA SET_DATA_START  ; to catch write attempts below this limit

	;; initialize pointers to zero
	null &ConsFree !
	null &DictHead !

:Tests

	&ConsGet call
	&ConsDispose call

	&ConsGet call
	
:Main
 	cr 'HERE ': 2 show HERE print cr

	;; falling through to Halt

:Halt			;; endless loop
	&Halt jmp


;; Generalized free list mechanism
;; -------------------------------

;; Pop an element off the freelist, or null if freelist empty

:FreePop   ; ( freeHead -- null|ptr )
	cpush			;; a=address of freelist head word
	a @ dup cpush null ne &*notEmpty jmp?  ;; b=address of first element in free list
		null ret

	:*notEmpty
	b @ a!			;; store b.next (first word) into freelist head
	b ret

;; Push an element on the freelist

:FreePush ; ( dataAddr freeHead -- )
	cpush		;; a=freeHead
	cpush		;; b=dataAddr

	a @ b !		;; store freeHead into dataAddr.next (first word)
	b a !		;; store dataAddr in freeHead
	
	ret
	
	
	
	


;; Dictionary stuff
;;	
	
; (TODO)


;; CONS cells are created as a two-word CAR+CDR tuple. They are allotted
;; as needed, but also freelisted when disposed off. To calculate the CDR address
;; from the Cons pointer: W+


:ConsGet  ; ( -- ConsPtr) - get Cons cell from free list (call ConsAlloc first if empty)
	&ConsFree cpush ;; a
	a &FreePop call cpush ;; b=ptr/null
	b null ne &*ok jmp?
		HERE b!				;; b=ptr new cons
		wordsize 2 mul allot  ;; reserve the space
	:*ok
	b ret

	
:ConsDispose  ;; ( ptr -- )
	&ConsFree &FreePush call ret

;; ---------------------------------
;; Reserved tags, must be present
;; ---------------------------------	

:DATA		
	;; data is generated here, which includes symbols - the tag is used 
	;; by disassembler to show bytes correctly beyond this point (not 
	;; as instructions)

;; for pointers we reserve bytes by entering instructions that occupy 4 bytes,
;; even though we are never going to call them. Using 4 bytes instead of
;; just 2 (current wordsize) ensures compatibility with a future 4 byte word size.
;;
;; At the top of the code, these pointers are nulled with program code, before being
;; used. Note that on a 2-byte word size, listing the memory for a pointer, once
;; initialized, will look like this: 0 0 x x. The two "x" are the extra zeroes.
;;

:ConsFree 0 0 0 0	;; freelist pointer 	
	;; 0 means empty
	;; Using four instructions to generate four bytes as a placeholder.
	;; The value is nulled in the Init section before use. Using 4 bytes instead
	;; of 2 to ensure compatibility with 4 byte wordsize - any more is
	;; unthinkable for embedded devices

:DictHead 0 0 0 0   ;; pointer


