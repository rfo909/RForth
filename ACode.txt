;; This file implements a state machine for the REPL and compiler.
;;
;; The data stack is already defined, as this "pretend assembly" exists on
;; a virtual stack machine. The return stack also exists, and there are
;; instructions call and ret which use it. The state machine that follows
;; only uses jumps.
;;
;; Towards the end follows the data fields. Using the following notation to
;; create placeholders and values in memory:
;;
;;  HEX:0001 
;;  %'symbol     - generates one length byte followed by the characters
;;  %tag         - inlines a tag address as a two byte word
;;  %NEXT        - generates a pointer one word ahead, then writes that value as a word
;;  b0           - generates a null byte, shortcut for HEX:00
;;  w0           - generates a null word, shortcut for HEX:0000
;;
;; Note tags must be defined earlier in the file, as the %tag references are not
;; part of the resolve scheme implemented in NumberTable

;; ------------ top of file ----------


:REPL
	cr "Ready>_ .str
	0 &IsCompiling writeb			;; set IsCompiling flag = 0 - set to 1 when compiling a word
	&StartNextWord jmp
	
:StartNextWord
	0 &IsNumber writeb				;; set IsNumber flag = 0
	0 &IsWord writeb				;; set IsWord flag = 0
	0 &IsLiteral writeb				;; set IsLiteral flag = 0	
	0 &NextWord writeb				;; set next word length = 0
	0 &NextNumber !				;; set next number = 0 (word write)
	
:GetChar
	readc &NextChar writeb

	&NextChar readb 
		0x20 eq &ProcessSpace jmp?	;; is it a space?

	;; add character to NextWord, regardless of whether it is believed to be a number
	;; because future characters may change it from number to word
			
	&NextChar
		&NextWord readb 1 add &NextWord add	;; write pos
			writeb				
	&NextWord readb 1 add &NextWord writeb			;; update length


	&IsNumber readb &ProcessDigit jmp?		;; if IsNumber is set, go directly there
	&IsWord readb &ProcessChar jmp?		;; is IsWord is set, go directly there
	
	&NextChar readb 
		dup '0 ge 
		swap '9 le and 
			&ProcessDigit jmp?	;; is it a digit?
			
	&ProcessChar jmp			;; assuming word


:ProcessSpace
	&IsNumber readb &CompleteNumber jmp?
	&CompleteWord jmp?
	
:ProcessDigit
	1 &IsNumber writeb					;; set IsNumber flag = 1
	
	;; calculate digit value		
	&NextChar '0 sub 9 gt &InvalidNumber jmp?	;; if bigger than 9, invalid number
		
	&NextNumber @ 10 mul &NextChar '0 sub add 
		&NextNumber !				;; update NextNumber
	&GetChar jmp					;; GOTO GetChar

:ProcessChar
	1 &IsWord writeb					;; set IsWord flag = 1
	&GetChar jmp					;; GOTO GetChar
	
:InvalidNumber
	0 &IsNumber writeb					;; change from IsNumber to IsWord
	1 &IsWord writeb
	&GetChar jmp
	
:CompleteNumber
	&IsLiteral readb &InvalidLiteralNumber jmp?	;; numbers can't be dictionary names
	&IsCompiling readb &CompileNumber jmp?		;; are we in compile mode?
	&NextNumber @					;; push number on stack
	&StartNextWord jmp					;; GOTO NextWord
	
	
:CompleteWord
	ret


:InvalidLiteralNumber					;; expected word name 
	cr
	"Unexpected_number_ .str
	&NextNumber @ print			
	&REPL jmp
	
:CompileNumber
	;; ### TODO
	&StartNextWord jmp

:CompileWord
	;; look up in dictionary, error if not found
	;; is isCompiling && immediate: call word code
	;; if isCompiling && !immediate: emit instructions to call the code
	;; if !isCompiling && immediate: do nothing
	;; if !isCompiling && !immediate: call word code
	&StartNextWord jmp
	
;; -----------------------------------------------
;; Implementations for initial words in dictionary
;; -----------------------------------------------

:COLON
	ret
	
:SEMICOLON
	ret
	
:immediate
	ret
		
	
:DATA

:NextChar 	b0
:IsCompiling 	b0
:IsNumber 	b0
:IsWord 	b0
:IsLiteral	b0

:NextWord			;; length + 16 characters
	b0
	b0 b0 b0 b0   b0 b0 b0 b0 	; 8 bytes
	b0 b0 b0 b0   b0 b0 b0 b0 	; 8 bytes


:NextNumber w0

#define NORMAL 		HEX:0000
#define IMMEDIATE	HEX:0001

;; The dictionary entry has the following format:
;;
;;  - name as string: 1 byte length, followed by characters
;;  - code reference: word pointer
;;  - flags: word
;;  - next: word
;;
;; Next=0 means terminated

:Dictionary
	%':		%COLON		IMMEDIATE	%NEXT
	HEX:013B	%SEMICOLON	IMMEDIATE	%NEXT
	%'immediate	%immediate	NORMAL		w0
	
:DictionaryEnd  ;; for memory dumping - the w0 in the next of last row is the search terminator
