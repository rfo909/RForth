;; Assembly level for virtual stack machine
;; ----------------------------------------
;;
;; This file implements the REPL, the colon compiler and the initial dictionary.
;; It implements IF, THEN and ELSE, and the DO ... AGAIN? loop words. It is sufficient
;; to get off the ground. It contains both code and data, addressed by tags.
;;
;; When running, the data stack, call stack and call frame stack are defined by the
;; runtime (interpreter). These exist in RAM above the blob of bytes that is the
;; output from this file. 
;;
;; This means that this code, when being executed, runs on a fully featured
;; virtual stack machine, supporting call and ret. 
;;
;; Some implementations refer to the data stack as "parameter stack", and 
;; the call stack is commonly known as "return stack" in other Forth's. The 
;; call frame stack keeps track of additional values pushed to the call stack,
;; like local variables, which means they don't need to be removed before
;; word return.
;;
;; Tags
;; ----
;;
;; This file is both code, data and initial memory map of the Forth REPL
;; and compiler / interpreter. Tags are defined at two levels, global and
;; local. Global tags are denoted
;;
;;  :Something
;;
;; They can only be defined once, but may be referred multiple times from anywhere, 
;; as &Something.
;;
;; Local tags exist between global tags, and are seen as extensions of the previous
;; global tag. They are used to do conditional and other jumps inside functions,
;; without polluting global tag space. They are written as
;;
;;  :*Something
;;
;; To address them, use &*Something
;;
;; The compiler automatically handles patching of forward references to tags.
;; 
;; Data content
;; ------------
;;
;; Towards the end follows the data fields. Using the following notation to
;; create placeholders and values in memory:
;;
;;  HEX:0001 
;;  %'symbol     - generates one length byte followed by the characters
;;  %tag         - inlines a tag address as a two byte word
;;  %NEXT        - generates a pointer one word ahead, then writes that value as a word
;;  b0           - generates a null byte, shortcut for HEX:00
;;  w0           - generates a null word, shortcut for HEX:0000
;;
;; Note tags to be referred via %tag must be defined earlier in the file, as %tag references
;; are not part of the resolve scheme implemented in NumberTable
;;
;; Local variables
;; ---------------
;;
;; The assembler offers some local variables in each (called!) routine, named 
;; a, b, c, d. Local variables must be defined/initialized with a call to cpush, which
;; takes a value off the data stack, and pushes it on top of the return address on the
;; call stack. To make things easy in the assembler code (this file), the assembler defines
;; six inline symbols, for reading and updating three statically named local variables,
;; a, b and c. Note that in order to use these, values must be cpush'ed to the call stack
;; for each. So, after doing a single cpush, we can then use "a" to retrieve that value and
;; "a!" to update it. Using two more cpush'es we get local variables b and c and so on. Using
;; more than the 6 predefined variables, we will need to use the cget and cset instructions
;; manually.
;;
;; These are defined below

;; Note that these inline replacement apply to this file, but not to Forth code. 
;;
;; The colon compiler should be extended, to keep track of local variables by name,
;; and handle interactions via cget and cset.  
;;  

;; ------------ top of file ----------

;; dictionary entry modes: use these in code

#define MODE_NORMAL	0
#define MODE_IMMEDIATE	1
#define MODE_INSTR	2	;; code pointer is single-byte instruction: "00xx"
#define MODE_CONSTANT	3	;; code pointer is constant word to be pushed on stack (directly or with code)


;; use these in the static Dictionary definition, as they generate raw memory values, which is not valid code!

#define NORMAL 		HEX:0000
#define IMMEDIATE	HEX:0001
#define INSTR		HEX:0002
#define CONSTANT	HEX:0003

;; When executing code, we start at PC=0x0000 (&Init)

#define b0		HEX:00
#define w0		HEX:0000

;; cget variables a,b,c are present as single byte instructions, as they are most used
#define d		3 cget
#define e		4 cget
#define f		5 cget
#define a!		0 cset
#define b!		1 cset
#define c!		2 cset
#define d!		3 cset
#define e!		4 cset
#define f!		5 cset

:Init	
	0 &IsCompiling writeb
	0 &IsCompilingWord writeb	

:REPL
	&GetNextWord call
	
	; DEBUG
	; cr &NextWord .str 

	&NextWordIsNumber call &*num jmp?  ;; if true stores number value in &NextNumber
	&NextWord 1+ readb 34 eq &*str jmp?  ;; starts with double quote
	&NextWord 1+ readb 39 eq &*str jmp?  ;; starts with single quote

		&ProcessWord call
		&REPL jmp
	:*num
		&ProcessNumber call
		&REPL jmp
	:*str
		&ProcessString call
		&REPL jmp


:GetNextWord
	0 &NextWord writeb
	
	0 cpush  		; using a for next char
	0 cpush			; using b to keep track of length of current word
	
	:*nextChar
		readc a!
		a 0x20 eq b 0 eq and &*nextChar jmp? 	;; ignore preceding space
		a 0x20 eq &*done jmp?			;; word identified

		;; update NextWord
		a &NextWord b add 1+ writeb
		b 1+ b!
		&*nextChar jmp
	:*done
		b &NextWord writeb
		ret


:NextWordIsNumber		; if &NextWord is a number, parse it and store in &NextNumber, returns boolean
	&NextWord &NextNumber atoi ret

		
	
:ProcessNumber  
	&IsCompiling readb &*compile jmp?
	
		;; not compiling
		&NextNumber @		;; push on stack
		ret
	
	:*compile
	
		&NextNumber @ 0 &EmitNumber call
		ret
		

:ProcessString
	; NextWord starts with single or double quote; if double quote, replace _ with space
	
	&NextWord 1+ readb 39 eq &*noReplace jmp?  ;; starts with single quote

		(replace underscore with space, directly in RAM)
		&NextWord 'u2spc nativec native
	
	:*noReplace

	;; overwrite the quote with length-1
	&NextWord 1+	cpush			;; a=offset 1
	
	&NextWord readb 1 sub
		a writeb
	
	a &BufCreateCopy call 		( address-of-copy )
		&NextNumber ! 
		&ProcessNumber call	;; use the ProcesNumber routine
	ret


:ProcessWord
	;; check for tag lookup
	&NextWord 1+ readb 38 ne &*notTag jmp?    ;; starts with &
		; overwrite amp char with length - 1 
		&NextWord readb 1 sub
			&NextWord 1+ writeb
		; look up tag
		&NextWord 1+
			tag cpush		;; a
		
		a 0 ne &*foundTag jmp?
		
		cr "Bad_tag_ .str &NextWord 1+ .str
		PANIC
	
	:*foundTag
		; reuse ProcessNumber
		a &NextNumber ! 
		&ProcessNumber call
		ret
	
	:*notTag 
	
	;; look up word in dictionary
	
	;; cr "Looking_up_ .str &NextWord .str
	
	&NextWord &DictLookup call 			;; dictionary entry pointer or null
	
	; ( dictEntryPointer )
	dup 
		null eq &*notFound jmp?
		dup readb add 1+			;; advance past the string	
	
	; (dictEntryPointer past the string - pointing at CODE, MODE, NEXT (words)
	; ( CODE-ptr )
	dup W+ @  
		; (CODE-ptr-ptr MODE-value) 
		&ExecuteWord call
	
	ret
	
	:*notFound
		drop					;; dup'ed value before call
		cr "Unknown_word_ .str	
		&NextWord .str
		PANIC
		

;; -----------------------------------------------
;; Utility subroutines, invoked with call
;; -----------------------------------------------

:ResetCompile
	0 &IsCompiling writeb			;; set IsCompiling flag = 0 - set to 1 when compiling a word
	0 &IsCompilingWord writeb
	0 &IsCompilingWordMode writeb
	0 &CompileBuf writeb
	0 &CompileStack writeb
	ret

:EmitByte   ;; ( byte -- )
	cpush				;; a=bytevalue
	&CompileBuf readb 1+ cpush	;; b=offset 
	a b &CompileBuf add writeb
	b &CompileBuf writeb
	ret
	
:EmitNumber ;; ( value nbytes -- ) 
	swap 
	cpush			;; a=number
	cpush			;; b=nbytes
	
	;; calculate write position
	&CompileBuf readb 1+ &CompileBuf add cpush    ;; c
	
	;; generate number as code
	a 
		c 
			b
				n2code 			;; returns number of bytes generated
		
	;; update CompileBuf length
	&CompileBuf readb
		add
			&CompileBuf writeb
			
	ret

		

:DictLookup ;; ( str -- dictEntry|null )
	cpush				;; a=str
	; "Looking_up_ .str a .str cr
	
	&DictionaryHead @ cpush		;; b=current dictionary entry
	:*next
		b null eq &*notFound jmp?	;; pointer is null, not found
		b a streq &*found jmp?		;; got a match
		
		b 
			b readb add 1+ 	;; byte count past string
				W+ W+			;; past code-pointer and flags
					@			;; read next pointer
		b!						;; update b with it
		&*next jmp
	:*notFound
		null ret
	:*found
		b ret
		
		
:BufCopy ( src target --   --- for buffer with length byte)
	swap
	cpush 	(a=src)
	cpush	(b=target)
	a b a readb 1+ memcpy
	ret
	
:BufCreateCopy ( src -- ptr --- for buffer with length byte)
	cpush		(a=src)
	HERE cpush	(b=ptr)
	a readb 1+ allot 
	a b &BufCopy call
	b
	ret

:ExecuteWord ;; ( code-ptr-ptr mode-value -- ) ;; decide how to handle word
	swap @ cpush				; a=code-ptr  
	cpush    				; b=mode-value
	
	&IsCompiling readb not &*NotCompiling jmp?
		;; --- compiling
		b MODE_NORMAL    eq &*generateCall jmp?		;; mode==normal: generate call to CODE
		b MODE_IMMEDIATE eq &*callCode jmp?		;; mode==immediate: call CODE
		b MODE_INSTR    eq &*inlineCode jmp?		;; mode==inline: add single instruction to code
		b MODE_CONSTANT      eq &*inlineData jmp?		;; mode=data, push code pointer on stack as is
		ret
	:*NotCompiling
		;; --- interactive		
		b MODE_NORMAL    eq &*callCode jmp?		;; mode==normal, call the code
		b MODE_IMMEDIATE eq &*callCode jmp?		;; mode==immediate, call the code
		b MODE_INSTR    eq &*callInline jmp?		;; mode==inline, execute that instruction
		b MODE_CONSTANT      eq &*executeData jmp?

		ret
		
	:*callCode
		;; cr "callCode_ .str a print
		a call 
		ret
	:*generateCall
		;; cr "generateCall_ .str a print
		a 0 &EmitNumber call

		;; add the call instruction
		0x51						;; Q = call
			&EmitByte call

		ret
	:*inlineCode
		;; when inlining, the "code pointer" is the instruction! 00nn!
		;; cr "inlineCode_ .str a print
		a &EmitByte call
		ret
	:*callInline
		;; when inlining, the "code pointer" is the instruction! 00nn!
		;; cr "callInline_ .str a print
		0 &CompileBuf writeb		;; clear CompileBuf (this is interactive mode, so buffer not in use)
		a &EmitByte call
		;; add the opcode
		0x52 &EmitByte call  		;; add "R" = ret
		&CompileBuf 1+ call    	;; invoke CompileBuf offset 1 (as byte 0 is the length)
		ret
	:*inlineData
		;; Data word, push code pointer value to stack
		;; Data words are static, so generating code is ok. For variables, this
		;; value is typically a memory reference!
		a 0 &EmitNumber call
		ret
	:*executeData
		a
		ret

; -------------------------------------------
; Compile stack functions
; -------------------------------------------
	
; Note type=0 is used to invalidate matched values from the stack

:comps! ( pos type -- )			( p=requires pos parameter )
	8 << 				(type is high byte) 
	orb        	         	(pos is low byte)
		cpush			(a=data word)

	&CompileStack readb wordsize mul 1+
		&CompileStack add 
			cpush			(b = write pos )

	a b !

	(increase stack counter)
	&CompileStack readb 1+ &CompileStack writeb
	ret
	

:comps@ ;; (type -- offset)
	cpush						(a=type)
	&CompileStack readb 0 eq &*emptyStack jmp?
	&CompileStack readb 1 sub cpush			(b=stack pos index for counting down)
	0 cpush						(make variable c available)
	
	:*next
		&CompileStack 
			b wordsize mul add 
				1+ c!		(c=actual read pos)
		;;cr "Compile_stack:_ .str "read_pos=" .str c print
		;;cr "Compile_stack:_ .str "checking_value= .str c @ print

		c @ 8 >> a eq &*found jmp?
		b 0 eq &*notFound jmp?		(can count no further down)
		b 1 sub b!
		&*next jmp
	:*emptyStack
		cr "CStack_empty .str
		PANIC
	:*notFound
		cr "CStack:_no_type_ .str a print#
		PANIC
	:*found
		c @ 255 andb		( return value )
		0 c writeb			( overwrite the type entry so it can't match again )
		ret

; CompileStack types
;
; IF = 0
; DO = 1

; CompileStack types

#define COMPS_TYPE_IF		0 
#define COMPS_TYPE_DO		1

;; NOTE: using single byte relative offsets, which with the number encoding scheme
;; means max relative fwd/back is 63 locations. That should be enough for most 
;; FORTH words

 

:IF 
	105 &EmitByte call		( not - invert false to true for conditional jmp ) 
	&CompileBuf readb 		( get next byte pos of CompileBuf )
		COMPS_TYPE_IF 		( type flag for IF logic )
			&comps! call	( push on compile stack )

	; (emit dummy offset data)
	0 &EmitByte call		(note: if not patched, crashes, since 0 is no valid instruction)
	54 &EmitByte call		(rfwd? instruction)
	ret

		
:THEN 			 		( patch forward jump at back address )
	COMPS_TYPE_IF 			( type flag for IF logic )
		&comps@ call cpush	( a=mark pos ) 
	&CompileBuf readb cpush		( b=curr pos )
	b a sub 1 sub cpush   		( c=offset, subtract 1 for the offset byte, as jump relative to rfwd? instr )

	(patch the IF forward jump)
	c					(offset)
		&CompileBuf 1+
			a add   		( write pos )
				1 n2code drop	( generate c as code, handles values 0-63 only )
					( NOTE: don't update buffer count, since this is a patch of an earlier loc )
			
	ret

:ELSE
	( Insert jump to the THEN at end of IF block, if original condition was true, to skip ELSE block )
	( But we can not push it on the compile-stack before resolving the first IF fwd jump )
	
	1 0 &EmitNumber call			( make rfwd? unconditional )
	&CompileBuf readb cpush  		( a=location of forward jump to THEN )
	0 &EmitByte call			( dummy offset )
	54 &EmitByte call			( rfwd? instruction )
	
	( now resolve the IF conditional forward jump to this position )
	&THEN call
	
	( push a new IF forward jump for location a, on compile stack, to be processed by THEN )
	a COMPS_TYPE_IF &comps! call
	ret


:DO
	( store current pos in CompileBuf as type DO on compile stack for conditional back jump from AGAIN? )
	
	&CompileBuf readb 
		COMPS_TYPE_DO 
			&comps! call
	ret
	
:AGAIN?
	&CompileBuf readb cpush			( a=curr pos in compilebuf )
	
	a
		COMPS_TYPE_DO &comps@ call sub	( calculate offset from current pos back to the position stored at DO )
		1+ 				( compensate for one byte of jump offset )
			cpush			( b=back jump count from rback? )

	b 
		1 &EmitNumber call		( generate code for b as 1 byte, which allows values of 0-63 )

	55 &EmitByte call			(rback?)
	ret
	
	
;; -----------------------------------------------
;; Implementations for initial complex words in dictionary
;; -----------------------------------------------


	
:COLON
	;; set compile mode
	1 &IsCompiling writeb

	&GetNextWord call
	
	&NextWordIsNumber call &*numberError jmp?
	
	;; copy NextWord to IsCompilingWord buffer
	&NextWord &IsCompilingWord &BufCopy call
	
	;; set compile output length to 0
	0 &CompileBuf writeb

	;; that's all?
	ret

	:*numberError
		cr "Bad_word_name:_ .str &NextWord .str
		&ResetCompile call
		PANIC

		
		
:SEMICOLON
	;; verify compile mode
	&IsCompiling readb &*ok jmp?
		;; ignore it
		ret
	:*ok
		;; info
		cr "Word_ .str &IsCompilingWord .str

		;; add a ret instruction to CompileBuf
		0x52 &EmitByte call

		"_#bytes= .str
		&CompileBuf readb print#

		;; allocate permanent code buffer including length byte
		&CompileBuf &BufCreateCopy call cpush            ;; a=codeBuffer
		
					
		a 1+ a!	; skip the length byte
		
		;; allocate dictionary entry
		HERE cpush					;; b=dictEntry
		&IsCompilingWord readb 1+			;; length of symbol
			wordsize 3 mul add				;; code pointer, flags, next
				allot

		;; copy symbol
		&IsCompilingWord b &BufCopy call
		
		;; advance dict entry pointer past name
		b readb 
			b add 
				1+ cpush					;; c=point to CODE field

		;; write code address and advance c
		a c !
		c W+ c!

		;; write mode and advance pointer
		&IsCompilingWordMode readb c !
		c W+ c!

		;; write next pointer
		&DictionaryHead @ 
			c !

		;; update DictionaryHead
		b &DictionaryHead !

		;; switch off compile mode and clean up
		&ResetCompile call

		;; all done
		ret



(variables are memory areas pointed to by named constants)
(constants are words, stored in the code fielf of the dictionary entry)
(and recognized via the mode field = CONSTANT)

:CONSTANT (value -- dictionaryentry)
	cpush						(a=value)

	&GetNextWord call
	
	;; allocate dictionary entry
	HERE cpush					;; b=dictEntry
	&NextWord readb 1+				;; length of symbol
		wordsize 3 mul add			;; code pointer, flags, next
			allot

	;; copy symbol
	&NextWord b &BufCopy call
	
	;; write value into code pointer field
	a						(value)
		b dup readb add 1+			(target address)
			!
	
	
	;; write CONSTANT into mode
	MODE_CONSTANT
		b dup readb add 1+ wordsize add		(target address)
			!
			
	;; location of next pointer
	b dup readb add 1+ wordsize dup add add cpush		(c=next field)
	
	;; write next pointer
	&DictionaryHead @ c !

	;; update DictionaryHead
	b &DictionaryHead !

	ret
		
:immediate
	;; change the IsCompilingWordMode to immediate
	1 &IsCompilingWordMode writeb
	ret		

:Words
	&DictionaryHead @ cpush 		;; a=dictionaryFrame
	0 cpush ;; (b)
	:*next
		a 0 eq &*done jmp?
		a &Dictionary eq &*done jmp?	;; only show Forth words, not standard dictionary
		
		a b!			;; b=name
		cr
		a readb a add 1+ a!   		;; past the name
		a @ print			;; code address
		"_ .str b .str			;; name
		a W+ W+ @ a!			;; a=a.next
		&*next jmp
	:*done
	ret

	
;; Create code for access to four variables abcd from Forth, in same way as in this file (compile only)

:aGet 0 0 &EmitNumber call 51 &EmitByte call ret  		;; 51 = '3' = cget
:bGet 1 0 &EmitNumber call 51 &EmitByte call ret
:cGet 2 0 &EmitNumber call 51 &EmitByte call ret
:dGet 3 0 &EmitNumber call 51 &EmitByte call ret

:aSet 0 0 &EmitNumber call 52 &EmitByte call ret		;; 52 = '4' = cset
:bSet 1 0 &EmitNumber call 52 &EmitByte call ret
:cSet 2 0 &EmitNumber call 52 &EmitByte call ret
:dSet 3 0 &EmitNumber call 52 &EmitByte call ret
	
:DATA

;; The dictionary entry has the following format:
;;
;;  - name as string: 1 byte length, followed by characters
;;  - code reference: word pointer
;;  - flags: word
;;  - next: word
;;
;; Next=0 means terminated


;; Note that the dictionary is protected (appears before the :PROTECT tag), because it is
;; a readonly structure. It can still be extended by adding new words that point to it, in
;; effect pushing new entries on the stack that is the dictionary. And which is the 
;; Forth way.


:Dictionary


	;; # --- autogenerated content: Assembler:InlineDictionary
	;; #
			
	%'!             HEX:004A        INSTR       %NEXT        ;; J
	%'.str          HEX:0043        INSTR       %NEXT        ;; C
	%'<<            HEX:0074        INSTR       %NEXT        ;; t
	%'>>            HEX:0075        INSTR       %NEXT        ;; u
	%'@             HEX:0049        INSTR       %NEXT        ;; I
	%'HERE          HEX:0067        INSTR       %NEXT        ;; g
	%'PANIC         HEX:0030        INSTR       %NEXT        ;; 0
	%'PC            HEX:0050        INSTR       %NEXT        ;; P
	%'W+            HEX:006E        INSTR       %NEXT        ;; n
	%'add           HEX:002B        INSTR       %NEXT        ;; +
	%'allot         HEX:004B        INSTR       %NEXT        ;; K
	%'and           HEX:0026        INSTR       %NEXT        ;; &
	%'andb          HEX:0071        INSTR       %NEXT        ;; q
	%'atoi          HEX:0031        INSTR       %NEXT        ;; 1
	%'call          HEX:0051        INSTR       %NEXT        ;; Q
	%'cget          HEX:0033        INSTR       %NEXT        ;; 3
	%'clear         HEX:0077        INSTR       %NEXT        ;; w
	%'cpush         HEX:004F        INSTR       %NEXT        ;; O
	%'cr            HEX:0058        INSTR       %NEXT        ;; X
	%'cset          HEX:0034        INSTR       %NEXT        ;; 4
	%'div           HEX:002F        INSTR       %NEXT        ;; /
	%'drop          HEX:006A        INSTR       %NEXT        ;; j
	%'dump          HEX:0070        INSTR       %NEXT        ;; p
	%'dup           HEX:006C        INSTR       %NEXT        ;; l
	%'eq            HEX:003D        INSTR       %NEXT        ;; =
	%'ge            HEX:0045        INSTR       %NEXT        ;; E
	%'global        HEX:0078        INSTR       %NEXT        ;; x
	%'global!       HEX:0079        INSTR       %NEXT        ;; y
	%'gt            HEX:003E        INSTR       %NEXT        ;; >
	%'halt          HEX:005A        INSTR       %NEXT        ;; Z
	%'inv           HEX:0073        INSTR       %NEXT        ;; s
	%'jmp           HEX:0053        INSTR       %NEXT        ;; S
	%'jmp?          HEX:0054        INSTR       %NEXT        ;; T
	%'le            HEX:0046        INSTR       %NEXT        ;; F
	%'lt            HEX:003C        INSTR       %NEXT        ;; <
	%'memcpy        HEX:0044        INSTR       %NEXT        ;; D
	%'mul           HEX:002A        INSTR       %NEXT        ;; *
	%'n2code        HEX:0032        INSTR       %NEXT        ;; 2
	%'native        HEX:0061        INSTR       %NEXT        ;; a
	%'nativec       HEX:0063        INSTR       %NEXT        ;; c
	%'ne            HEX:0068        INSTR       %NEXT        ;; h
	%'not           HEX:0069        INSTR       %NEXT        ;; i
	%'null          HEX:007A        INSTR       %NEXT        ;; z
	%'or            HEX:007C        INSTR       %NEXT        ;; |
	%'orb           HEX:0072        INSTR       %NEXT        ;; r
	%'over          HEX:006F        INSTR       %NEXT        ;; o
	%'print         HEX:0057        INSTR       %NEXT        ;; W
	%'print#        HEX:0059        INSTR       %NEXT        ;; Y
	%'print#s       HEX:0062        INSTR       %NEXT        ;; b
	%'printb        HEX:004C        INSTR       %NEXT        ;; L
	%'printc        HEX:0055        INSTR       %NEXT        ;; U
	%'rback?        HEX:0037        INSTR       %NEXT        ;; 7
	%'readb         HEX:0047        INSTR       %NEXT        ;; G
	%'readc         HEX:0076        INSTR       %NEXT        ;; v
	%'ret           HEX:0052        INSTR       %NEXT        ;; R
	%'rfwd?         HEX:0036        INSTR       %NEXT        ;; 6
	%'streq         HEX:0042        INSTR       %NEXT        ;; B
	%'sub           HEX:002D        INSTR       %NEXT        ;; -
	%'swap          HEX:006D        INSTR       %NEXT        ;; m
	%'tag           HEX:0038        INSTR       %NEXT        ;; 8
	%'wordsize      HEX:006B        INSTR       %NEXT        ;; k
	%'writeb        HEX:0048        INSTR       %NEXT        ;; H




	;; ----------------------------------------------------------

	;; local variables in same style as in this file
	
	%'a		%aGet		IMMEDIATE	%NEXT
	%'b		%bGet		IMMEDIATE	%NEXT
	%'c		%cGet		IMMEDIATE	%NEXT
	%'d		%dGet		IMMEDIATE	%NEXT
	
	%'a!		%aSet		IMMEDIATE	%NEXT
	%'b!		%bSet		IMMEDIATE	%NEXT
	%'c!		%cSet		IMMEDIATE	%NEXT
	%'d!		%dSet		IMMEDIATE	%NEXT
	

	%'IF		%IF		IMMEDIATE	%NEXT
	%'THEN		%THEN		IMMEDIATE	%NEXT
	%'ELSE		%ELSE		IMMEDIATE	%NEXT
	%'DO		%DO		IMMEDIATE	%NEXT
	%'AGAIN?	%AGAIN?		IMMEDIATE		%NEXT
	%'CONSTANT	%CONSTANT	NORMAL			%NEXT
	
	%'?		%Words		NORMAL		%NEXT
	%':		%COLON		NORMAL		%NEXT
	HEX:013B	%SEMICOLON	IMMEDIATE	%NEXT
	%'IMMEDIATE	%immediate	IMMEDIATE	w0	;; <-- w0 = terminating the linked list
:DictionaryEnd

:PROTECT		;; protects data before this point against writes - reads are allowed

:DictionaryHead %Dictionary

:IsCompiling		b0
:IsCompilingWord	b w0 w0 w0 w0 w0 w0 w0 w0 w0 w0 w0 w0 w0 w0 w0 w0		;; 32 character stringbuffer
:IsCompilingWordMode	b0					;; NORMAL or IMMEDIATE

:CompileBuf		w0 w0 w0 w0 w0 w0 w0 w0 		;; up to 127 bytes, for the colon compiler
			w0 w0 w0 w0 w0 w0 w0 w0			;; first byte is length
			w0 w0 w0 w0 w0 w0 w0 w0
			w0 w0 w0 w0 w0 w0 w0 w0

			w0 w0 w0 w0 w0 w0 w0 w0
			w0 w0 w0 w0 w0 w0 w0 w0
			w0 w0 w0 w0 w0 w0 w0 w0
			w0 w0 w0 w0 w0 w0 w0 w0



:NextWord		b0 w0 w0 w0 w0 w0 w0 w0 w0 w0 w0 w0 w0 w0 w0 w0 w0	;; 32 character stringbuffer
:NextNumber		w0 							;; single word

:CompileStack		b0 w0 w0 w0 w0 w0 w0 w0 w0 		
				;; 8 words each consists of type (1 byte) and offset in CompileBuf (1 byte)
				;; see COMPS_TYPE_* defs

:MemoryEnd


