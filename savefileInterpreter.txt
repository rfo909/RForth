# README
# --
<<< EOF
This test interpreter has no limits on the stacks or the heap. 
The goal is to validate the output from the Assembler.
>>> EOF
/Readme


# The interpreter
# --
	P(1) as String => code

	# number of words
	DSTACK_WORDS = 20
	CSTACK_WORDS = 40  # callstack
	FSTACK_FRAMES = 10  # frame stack - contains dictionaries
	
	self.WORDSIZE = 2
	self.memory=HWSim:Memory(self.WORDSIZE)
	self.memory.malloc(code.length)

	# write the code into memory
	addr=0
	code.chars->c self.memory.writeChar(addr,c) addr=addr+1 |

	self.PC=0
	self.DATA_START=0 # set to actual value by code, guards against runaway writes into the base code

	self.HERE = Lambda{
		self.memory.HERE
	}
		
	# the call stack and data stacks exist in self.memory and grow upwards, storing words only,
	# for predictable address calculations.

	self.dbase=self.HERE
	self.memory.mallocWords(DSTACK_WORDS)
	self.dataStack=HWSim:MemStack(self.memory, self.dbase, DSTACK_WORDS, "data")

	self.cbase=self.HERE
	self.memory.mallocWords(CSTACK_WORDS)
	self.callStack=HWSim:MemStack(self.memory, self.cbase, CSTACK_WORDS, "calls")

	# the frame stack stores frames as two words: base and size
	self.fbase=self.HERE
	FSTACK_WORDS=FSTACK_FRAMES*2
	self.memory.mallocWords(FSTACK_WORDS)
	self.frameStack=HWSim:MemStack(self.memory, self.fbase, FSTACK_WORDS, "frames")

	# the frameStack contains dictionaries identifying the base and the top of the current
	# call frame, which lives on the call stack.
	
	self.nextInstruction=Lambda{
		self.memory.readChar(self.PC)
	}

	self.showMem=Lambda{
		P(1)=>fromAddr
		P(2,fromAddr+10) => toAddr
		result = tryCatch(self.memory.dump(fromAddr,toAddr))
		if (!result.ok) {
			println("*** FAILED: " + result.msg)
		}
	}


	# data stack
	self.push=Lambda{P(1)=>value self.dataStack.push(value)}
	self.pop=Lambda{self.dataStack.pop}


	# call stack
	self.cpush=Lambda{
		P(1) as int => value
		self.callStack.push(value)
		frameInfo=self.fpeek

		self.frameStack.pop
		self.frameStack.pop
		self.fpush(frameInfo.base, frameInfo.size+1)
	}

	# frame stack
	
	self.fpush = Lambda{
		P(1) as int => base
		P(2) as int => size
		self.frameStack.push(base)
		self.frameStack.push(size)
	}

	self.fpeek = Lambda {
		size=self.frameStack.pop
		base=self.frameStack.peek
		self.frameStack.push(size)
		SymDict(base,size)
	}

	self.fpop = Lambda{
		self.frameStack.pop
		self.frameStack.pop
	}

	# initialize frame stack - these numbers are offsets on the callStack

	self.fpush(0,0)


	self.executionCount=1
	self.executeInstruction=Lambda{
		pc=self.PC

		name="_"+self.memory.readChar(self.PC)
		if (self.has(name)) {
			closure = self.get(name)
			result = tryCatch(closure.call)
			
			if (!result.ok) {
				println("*** Execution failed:", result.msg, "PC", pc, "count", self.executionCount)
			} else {
				# executed ok, now update PC unless a jump has already moved it
				if (self.PC == pc) {
					self.PC=pc+1
				}
				self.executionCount=self.executionCount+1
			}
		} else {
			println("*** Unknown instruction member",name,"PC=" + pc,"count="+self.executionCount)
		}
	}

	self._k=Lambda{ # wordsize ( -- N )
		self.push(self.WORDSIZE)
	}
	self._K=Lambda{ # allot  ( N -- )
		byteCount=self.pop
		self.memory.malloc(byteCount)
	}
	self._G=Lambda{ # readb - read byte ( addr -- value )
		addr=self.pop
		if (addr < self.DATA_START) println("Warning: readb: reading below DATA_START: " + addr)
		self.push(self.memory.readByte(addr))
	}
	self._H=Lambda{ # writeb - write byte ( addr -- value )
		addr=self.pop
		if (addr < self.DATA_START) println("ERROR: writeb: writing below DATA_START: " + addr)
		value=self.pop
		self.memory.writeByte(addr,value)
	}

	self._x=Lambda{self.push(0)} # zero - push a zero ( -- 0 )
	self._0=Lambda{self.push(self.pop*16+0)} # ( m -- n )  n=16*m + digit value
	self._1=Lambda{self.push(self.pop*16+1)} # ( m -- n )  n=16*m + digit value
	self._2=Lambda{self.push(self.pop*16+2)} # ( m -- n )  n=16*m + digit value
	self._3=Lambda{self.push(self.pop*16+3)} # ( m -- n )  n=16*m + digit value
	self._4=Lambda{self.push(self.pop*16+4)} # ( m -- n )  n=16*m + digit value
	self._5=Lambda{self.push(self.pop*16+5)} # ( m -- n )  n=16*m + digit value
	self._6=Lambda{self.push(self.pop*16+6)} # ( m -- n )  n=16*m + digit value
	self._7=Lambda{self.push(self.pop*16+7)} # ( m -- n )  n=16*m + digit value
	self._8=Lambda{self.push(self.pop*16+8)} # ( m -- n )  n=16*m + digit value
	self._9=Lambda{self.push(self.pop*16+9)} # ( m -- n )  n=16*m + digit value
	self._A=Lambda{self.push(self.pop*16+10)} # ( m -- n )  n=16*m + digit value
	self._B=Lambda{self.push(self.pop*16+11)} # ( m -- n )  n=16*m + digit value
	self._C=Lambda{self.push(self.pop*16+12)} # ( m -- n )  n=16*m + digit value
	self._D=Lambda{self.push(self.pop*16+13)} # ( m -- n )  n=16*m + digit value
	self._E=Lambda{self.push(self.pop*16+14)} # ( m -- n )  n=16*m + digit value
	self._F=Lambda{self.push(self.pop*16+15)} # ( m -- n )  n=16*m + digit value

	## Local variable pointer instructions a-f

	self._a=Lambda{  # a - read local variable a ( -- value )
		frameInfo=self.fpeek
		base=(self.cbase + (frameInfo.base*self.WORDSIZE))
		value=self.memory.readWord(base)
		self.push(value)
	}
	self._b=Lambda{  # b - read local variable b ( -- value )
		frameInfo=self.fpeek
		base=(self.cbase + (frameInfo.base*self.WORDSIZE))
		value=self.memory.readWord(base+self.WORDSIZE)
		self.push(value)
	}
	self._c=Lambda{  #  c - read local variable c ( -- value )
		frameInfo=self.fpeek
		base=(self.cbase + (frameInfo.base*self.WORDSIZE))
		value=self.memory.readWord(base+self.WORDSIZE*2)
		self.push(value)
	}
	self._d=Lambda{  # a! - set local variable a ( value -- )
		value=self.pop
		frameInfo=self.fpeek
		base=(self.cbase + (frameInfo.base*self.WORDSIZE))
		self.memory.writeWord(base, value)
	}
	self._e=Lambda{  # b! - set local variable b ( value -- )
		value=self.pop
		frameInfo=self.fpeek
		base=(self.cbase + (frameInfo.base*self.WORDSIZE))
		self.memory.writeWord(base+self.WORDSIZE, value)
	}
	self._f=Lambda{ # c! - set local variable c ( value -- )
		value=self.pop
		frameInfo=self.fpeek
		base=(self.cbase + (frameInfo.base*self.WORDSIZE))
		self.memory.writeWord(base+self.WORDSIZE*2, value)
	}

	self.set("_+", Lambda{self.push(self.pop+self.pop)}) # add
	self.set("_-", Lambda{b=self.pop a=self.pop self.push(a-b)}) # sub
	self.set("_*", Lambda{b=self.pop a=self.pop self.push(a*b)}) # mul
	self.set("_/", Lambda{b=self.pop a=self.pop self.push((a/b).i)}) # div
	self.set("_<", Lambda{b=self.pop a=self.pop value=if(a<b,1,0) self.push(value)}) # lt
	self.set("_=", Lambda{b=self.pop a=self.pop value=if(a==b,1,0) self.push(value)}) # eq
	self.set("_>", Lambda{b=self.pop a=self.pop value=if(a>b,1,0) self.push(value)}) # gt
	self._h=Lambda{	# ne
		b=self.pop a=self.pop value=if(a!=b,1,0) self.push(value)
	}
	self._i=Lambda{ # not (boolean)
		a=self.pop value=if(a==0,1,0) self.push(value)
	}
	
	self._g=Lambda{self.push(self.memory.HERE)}   # HERE ( -- value )
	self._U=Lambda{self.push(self.PC)}		# PC ( -- value )
	
	self.set("_&", Lambda{b=self.pop a=self.pop value=if(a != 0 && b != 0, 1, 0) self.push(value)}) # and (boolean)
	self.set("_|", Lambda{b=self.pop a=self.pop value=if(a != 0 || b != 0, 1, 0) self.push(value)}) # or (boolean)
	
	self._S=Lambda{self.PC=self.pop}  # jmp ( addr -- )
	self._T=Lambda{addr=self.pop cond=self.pop if(cond != 0) self.PC=addr}  # jmp? ( cond addr -- )
	
	self._Q=Lambda{  # call ( addr -- )
		targetAddr=self.pop
		returnAddr=self.PC+1 # following call

		self.cpush(returnAddr)
		currFrame=self.fpeek

		frameInfo=Dict.set("base",currFrame.base+currFrame.size).set("size",0)
			# currFrame.size will be at least 1 after we pushed return address

		base=currFrame.base+currFrame.size
		size=0
		self.fpush(base,size)

		self.PC=targetAddr # JMP
	}
	self._R=Lambda{  # ret - return
		self.fpop

		frameInfo=self.fpeek  # previous frame

		# resetting callstack as it were before call
		self.callStack.setNext(frameInfo.base + frameInfo.size) 
	
		# popping the jump address
		targetAddr=self.callStack.pop

		# must update the frameInfo about having popped the PC from the callStack
		base=frameInfo.base
		size=frameInfo.size-1
		self.fpop
		self.fpush(base,size)

		self.PC=targetAddr # JMP
	}
	
	self._I=Lambda{  # @ = read word
		addr=self.pop
		if (addr < self.DATA_START) println("Warning: @: reading below DATA_START: " + addr)
		self.push(self.memory.readWord(addr))
	}
	
	self._J=Lambda{  # ! = write word
		addr=self.pop
		if (addr < self.DATA_START) println("ERROR: !: writing below DATA_START: " + addr)
		value=self.pop
		self.memory.writeWord(addr,value)
	}

	self._O=Lambda{  # cpush
		self.cpush(self.pop)
	}

	self._M=Lambda{ # dcopy: ( a b c 2 -- a b c a ) - argument 0 is top of stack 1 next and so on
		offset=self.pop
		value=self.dataStack.getValue(offset)
		self.push(value)
	}

	self._N=Lambda{ # dget: (a b c 0 -- a b c) and (a b c 1 -- a c)
		offset=self.pop
		value=self.dataStack.removeValue(offset)
		self.push(value)
	}

	self._j=Lambda { # drop
		self.pop
	}
	
	self._l=Lambda{ # dup
		value=self.pop
		self.push(value)
		self.push(value)
	}
	
	self._m=Lambda{ # swap
		a=self.pop
		b=self.pop
		self.push(a)
		self.push(b)
	}
	
	self._n=Lambda{ # W+
		value=self.pop
		self.push(value+self.WORDSIZE)
	}

	self._o=Lambda{ # over
		b=self.pop
		a=self.pop
		self.push(a)
		self.push(b)
		self.push(a)
	}

	self._p=Lambda{ # dump

		println("Datastack BOTTOM ---> TOP")

		values=self.dataStack.getStackValues 
		values->x
			s=("    "+x).last(5)+" "
			print(s)
		|
		println

		values->x
			s=("    x"+x.hex).last(5)+" "
			print(s)
		|

		println
	}

	self._Z=Lambda{ # SET_DATA_START
		value=self.pop
		println("DATA_START = 0x" + value.hex(4).toUpper)
		self.DATA_START = value
	}

->value
	
	self._V=Lambda{ # show
		count=self.pop  # number of symbols

		Std.Data.for(0,count,1)->i
			out(self.pop)
		| _.reverse -> symbolAddr
			self.memory.readChar(symbolAddr) => h
			self.memory.readChar(symbolAddr+1) => l
			(h+l).parseInt(16)=>length
			# read characters
			Inner{
				Std.Data.for(0,length,1)->pos
					ch=self.memory.readChar(symbolAddr+2+pos)  # +2 skip hl
					out(ch)
				| _.concat
			} => symbol
			print(symbol)
			print(" ")
	}
	self._W=Lambda{ # print
		value=self.pop
		print("0x" + value.hex(4).toUpper)
		print(" ")
	}
	self._Y=Lambda{ # print#
		value=self.pop
		print(value)
		print(" ")
	}
	self._X=Lambda{ # cr
		println
	}
		
		
/class Interpreter



# Show frame stack
# --
	P(1) as &MemStack => frameStack

	# pair two values
	count=0
	frameStack.getStackValues->value
		count=count+1
		if (count % 2 == 0) out(":") else out(" ")
		out(value)
	| _.concat
//ShowFrameStack


# Show word stack
# --
	P(1) as &MemStack => stack
	stack.getStackValues->value
		out("" + value + "/x" + value.hex.toUpper)
	| _.concat("  ")
//ShowWordStack


# Read address
# --
	Input("Enter address hex NNNN or decimal #NNNN").get =>addr
	if (addr.startsWith("#")) {
		addr.after("#").parseInt(10)
	} else if (addr.startsWith("0x") || addr.startsWith("x")) {
		addr.after("x").parseInt(16)
	} else {
		addr.parseInt(16)
	}
//ReadAddress

# Test
# --
	P(1) => code
	
	if (code==null) {
		println("Paste then . for code")
		code=readLines(".").concat
	}
	Lib:Header("Code string: " + code.length + " bytes")
	println(code)
	println
	
	x=Interpreter(code)
	iCount=0
	autoRunCount=0

	loop
		if (autoRunCount > 0) {
			x.executeInstruction
			iCount=iCount+1
			autoRunCount=autoRunCount-1
			continue
		}
			
		instr=x.nextInstruction
		instrName=instr
		instrName=Assembler:InstructionsLookup.get(instr)
		
		println
		# show dataStack
		println("dataStack  0x" + x.dbase.hex(4) + " [ " + ShowWordStack(x.dataStack) + " ] TOP")
		# show callStack
		println("callStack  0x" + x.cbase.hex(4) + " [ " + ShowWordStack(x.callStack) + " ] TOP")
		# show frameStack
		println("frameStack 0x" + x.fbase.hex(4) + " [ " + ShowFrameStack(x.frameStack) + " ] TOP")
		
		println
		println(("    "+iCount).last(4) + " PC", "0x" + ("0000"+x.PC.hex.toUpper).last(4), instr, instrName)
		
		println
		command=readLine("Command: 'q' to quit, 'i' to inspect, 'w' read word, 'r' to run, ENTER to continue").trim
		if(command=="q") {
			break
		} else if (command=="i") {
			addr=ReadAddress
			x.showMem(addr)
		} else if (command=="w") {
			addr=ReadAddress
			value=x.memory.readWord(addr)
			println("=> " + value + " x" + value.hex)
		} else if (command=="r") {
			Input("Enter number of instructions to run").get.parseInt => autoRunCount
		} else if (command.trim=="") {
			x.executeInstruction
			iCount=iCount+1
		}
		
		 
/t		
	
