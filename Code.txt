:JMP
	Ref addr = dsPopRef();
	
	Ref currCSF = getCurrCSF();   // may create if none found
	writeRef(currCSF + CSF_pc, addr);
	
:COND_JMP
	Ref addr = dsPopRef();
	Long cond = dsPopInt4();
	if (cond != null) {
		Ref currCSF = getCurrCSF();   // may create if none found
		writeRef(currCSF + CSF_pc, addr);
	}

:CALL
	Ref addr=dsPopRef();
	
	Ref currCSF = getCurrCSF();
	
	byte nextFrame = readByte(CS_NEXT_FRAME);
	writeByte(CS_NEXT_FRAME, nextFrame+1);
	
	Ref newCSF = getCurrCSF();
	byte tsNext = readByte(currCSF + CSF_tempStackNext);
	
	writeRef(newCSF + CSF_code, addr);
	writeByte(newCSF + CSF_tempStackBase, tsNext);
	writeByte(newCSF + CSF_tempStackNext, tsNext);
	writeRef(newCSF + CSF_pc, 0);
	
:RETURN
	byte x = readByte(CS_NEXT_FRAME);
	writeByte(CS_NEXT_FRAME, x-1);
	
:PANIC
	Ref word = dsPopRef();
	char *str = safeGetString(word);
	emitStr("PANIC: ");
	emitStr(str);
	emitNewline();
	setPanicFlag();
	
:HEAP_MAX
	dsPushInt2(getHeapSize());
			
:TIBs
	dsPushInt1(getTIBsChar());
		
:TIBr
	dsPushInt1(getTIBrChar());
	
:TIBr_ADD
	advanceTIBr();
	
:TIBs_ADD
	advanceTIBs();
	
:TIBr_BACK
	resetTIBr();
	
:TIBs_FWD
	confirmTIBr();
	
:TIBW
	char *str = getTIBWord();
	Ref ref=getSymRef(str);
	dsPushRef(ref);
	
:EMIT
	char c=dsPopInt1();
	emitChar(c);

:EMITWORD
	Ref ref=dsPopRef();
	char *str = safeGetStr(ref);
	emitStr(str);
	
:ADD
	Long b=dsPopInt4();
	Long a=dsPopInt4();
	dsPushInt4(a+b);
	
:SUBTRACT
	Long b=dsPopInt4();
	Long a=dsPopInt4();
	dsPushInt4(a-b);

:MUL
	Long b=dsPopInt4();
	Long a=dsPopInt4();
	dsPushInt4(a*b);
:DIV
	Long b=dsPopInt4();
	Long a=dsPopInt4();
	dsPushInt4(a/b);

:MOD
	Long b=dsPopInt4();
	Long a=dsPopInt4();
	dsPushInt4(a%b);

:RIGHTSHIFT
	Long n=dsPopInt4();
	Long val=dsPopInt4();
	dsPushInt4(val >> n);

:LEFTSHIFT
	Long n=dsPopInt4();
	Long val=dsPopInt4();
	dsPushInt4(val << n);

:AND
	Long b=dsPopInt4();
	Long a=dsPopInt4();
	if (a & b != 0) dsPushInt4(F_TRUE); else dsPushInt4(F_FALSE);

:OR
	Long b=dsPopInt4();
	Long a=dsPopInt4();
	if (a | b != 0) dsPushInt4(F_TRUE); else dsPushInt4(F_FALSE);

:NOT
	Long val=dsPopInt4();
	dsPushInt4( ~val );
	
:EQ
	Long b=dsPopInt4();
	Long a=dsPopInt4();
	if (a == b) dsPushInt4(F_TRUE); else dsPushInt4(F_FALSE);

:NE
	Long b=dsPopInt4();
	Long a=dsPopInt4();
	if (a != b) dsPushInt4(F_TRUE); else dsPushInt4(F_FALSE);
	
:GT
	Long b=dsPopInt4();
	Long a=dsPopInt4();
	if (a > b) dsPushInt4(F_TRUE); else dsPushInt4(F_FALSE);
	
:LT
	Long b=dsPopInt4();
	Long a=dsPopInt4();
	if (a < b) dsPushInt4(F_TRUE); else dsPushInt4(F_FALSE);

:GE
	Long b=dsPopInt4();
	Long a=dsPopInt4();
	if (a >= b) dsPushInt4(F_TRUE); else dsPushInt4(F_FALSE);

:LE
	Long b=dsPopInt4();
	Long a=dsPopInt4();
	if (a <= b) dsPushInt4(F_TRUE); else dsPushInt4(F_FALSE);

:DROP
	dsPopInt4();
	
:SETLOCAL
	Long value=dsPopInt4();
	Ref sym=dsPopRef();
	setLocalValue(sym,value);
	
:GETLOCAL
	Ref sym=dsPopRef();
	dsPushValue(getLocalValue(sym));
	
:WORD
	// create word from substring of existing word
	Ref ref=dsPopRef();
	char *str=safeGetString(ref);
	addSymbol(str);
		
:WRITE1
	Ref ref=dsPopRef();
	long val=dsPopInt4();
	writeByte(ref,val);
	
:WRITE2
	Ref ref=dsPopRef();
	long val=dsPopInt4();
	write2(ref,val);
	
:WRITE4
	Ref ref=dsPopRef();
	long val=dsPopInt4();
	write4(ref,val);
	
:READ1
	Ref ref=dsPopRef();
	dsPushInt1(readInt1(ref));
	
:READ2
	Ref ref=dsPopRef();
	dsPushInt2(readInt2(ref));
	
:READ4
	Ref ref=dsPopRef();
	dsPushInt4(readInt4(ref));

:READ1g
	Long addr=dsPopInt4();
	dsPushInt1(readGlobal(addr));
	
:WRITE1g
	Long addr=dsPopInt4();
	Byte value=dsPopInt1();
	writeGlobal(addr,value);
	
:LITERAL1
	dsPushInt1(nextByte());

:LITERAL2
	a=nextByte();
	b=nextByte();
	dsPushInt2(a<<8 | b)
	
:LITERAL4
	a=nextByte();
	b=nextByte();
	c=nextByte();
	d=nextByte();
	dsPushInt4(a<<24 | b<<12 | c<<8 | d)

:CHECK_PARSE
	Ref symRef=dsPopRef();
	char *str = safeGetString(symRef);
	if (checkParseInt(str)) ds.pushValue(F_TRUE); else ds.pushValue(F_FALSE);
	
:PARSE
	Ref symRef=dsPopRef();
	char *str = safeGetString(symRef);
	dsPushInt4(parseInt(str));

