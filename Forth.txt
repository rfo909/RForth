# If we let DODOES take a pointer off the stack, instead of storing stuff on the heap,
# then we can let the ptr pass through CREATE and be picked up by DODOES and push that
# on the stack (via code) before jumping to run the code after DOES>

# I simulate this by setting the CREATE-HERE value to the ptr parameter to Adder and Getter

: Adder (ptr) CREATE &CREATE-HERE ! DOES> (value [ptr]) => ptr => val ptr @ val add ptr ! ;
: Getter (ptr) CREATE &CREATE-HERE ! DOES> ([ptr]--value) @ ;

HERE 0 , 
    dup Adder CounterAdd 
    Getter CounterGet


The issue now is resisting the temptation of overdoing this, creating "libraries" like
the dictionary example below. Which would benefit from (a) the shared data and (b) of
creating words from code, like supply a base name and have it extended by "method names",
... Doing Java in Forth???





(Using buffers for string ops)

(----------------------------)
Dict Str
Str DictUse

&CompileBuf CONSTANT buf
&CompileBufEnd &CompileBuf sub CONSTANT Available

(=============================
NOTE: Using the compile
buffer is safe as long as 
inside running code. Its 
content may change when using
the REPL
=============================)

: clear (--) 0 buf writeb ;

: Length (-- n) buf readb ;

: add (str --)
  => str
  str readb => strLen
  Length => bufLen

  strLen Length add Available gt IF
    "Str:_Buffer_overflow .str 
    PANIC
  THEN
  (-- copy str into buf --)
  str 1+ (source)
    buf Length add 1+ (target)
    strLen (#bytes)
      memcpy
  (-- update buf length --)
  Length strLen add
    buf writeb
;  

(-- for debug --)
: .b buf Available ShowBuffer ;

DictClear
(172 bytes)


(----------------------------)



(----------------------------)
(TEST CODE)

: SClr () IN Str clear ;
: S+ (str) IN Str add ;
: S> (--ptr) IN Str buf ;
: S. S> .str ;

: test 
  SClr 
  "test_ S+ 
  "tust_ S+ 
  S. ;




