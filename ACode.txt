;; This file implements a state machine for the REPL and compiler.
;;
;; The data stack is already defined, as this "pretend assembly" exists on
;; a virtual stack machine. The return stack also exists, and there are
;; instructions call and ret which use it. The state machine that follows
;; only uses jumps.
;;
;; Towards the end follows the data fields. Using the following notation to
;; create placeholders and values in memory:
;;
;;  HEX:0001 
;;  %'symbol     - generates one length byte followed by the characters
;;  %tag         - inlines a tag address as a two byte word
;;  %NEXT        - generates a pointer one word ahead, then writes that value as a word
;;  b0           - generates a null byte, shortcut for HEX:00
;;  w0           - generates a null word, shortcut for HEX:0000
;;
;; Note tags must be defined earlier in the file, as the %tag references are not
;; part of the resolve scheme implemented in NumberTable

;; ------------ top of file ----------

#define DIGIT_0		48
#define DIGIT_9		57



:Init	
	0 &IsCompiling writeb
	0 &IsCompilingWord writeb	

:REPL
	&GetNextWord call
	
	cr &NextWord .str

	&IsNumber readb &ProcessNumber call?
	&IsWord readb &ProcessWord call?
	;; otherwise ignore (must have been an error)
	&IsNumber readb not 
		&IsWord readb not 
			and &ResetCompile call?	;; something went wrong
	&REPL jmp


:GetNextWord
	0 &NextWord writeb
	0 &NextNumber !
	
	1 &IsNumber writeb	; assuming number until non-digit
	0 &IsWord writeb

	0 cpush  		; using a for next char
	0 cpush			; using b to keep track of length of current word
	
	:*nextChar
		readc a!
		a 0x20 eq b 0 eq and &*nextChar jmp? 	;; ignore preceding space
		a 0x20 eq &*done jmp?			;; word identified

		a DIGIT_0 lt a DIGIT_9 gt or &*notDigit jmp?

		;; digit - update NextNumber
		&NextNumber @ 10 mul a DIGIT_0 sub add &NextNumber !
		&*doNext jmp
	:*notDigit
		0 &IsNumber writeb
		1 &IsWord writeb
		
	:*doNext
		;; update NextWord
		a &NextWord b 1 add add writeb
		b 1 add b!
		b &NextWord writeb
		&*nextChar jmp
	:*done
		b &NextWord writeb
		ret
	
	
:ProcessNumber  
	&IsCompiling readb &*compile jmp?
	
		;; not compiling
		&NextNumber @		;; push on stack
		ret
	
	:*compile
	
		&NextNumber @ 0 &EmitNumber call
		ret
		
:ProcessWord
	;; check for tag lookup
	&NextWord 1 add readb 38 ne &*notTag jmp?    ;; starts with &
		; overwrite colon with length - 1 
		&NextWord readb 1 sub
			&NextWord 1 add writeb
		; look up tag
		&NextWord 1 add
			tag cpush		;; a
		
		a 0 ne &*found jmp?
		
		cr "Invalid_tag_ .str &NextWord 1 add .str
		PANIC
	
	:*found
		a &NextNumber ! 
		&ProcessNumber call
		ret
	
	:*notTag 
	
	;; look up word in dictionary
	
	;; cr "Looking_up_ .str &NextWord .str
	
	&NextWord &DictLookup call 			;; dictionary entry pointer or null
	
	; ( dictEntryPointer )
	dup 
		null eq &*notFound jmp?
		dup readb add 1 add			;; advance past the string	
	
	; (dictEntryPointer past the string - pointing at CODE, MODE, NEXT (words)
	; ( CODE-ptr )
	dup W+ @  
		; (CODE-ptr-ptr MODE-value) 
		&ExecuteWord call
	
	ret
	
	:*notFound
		drop					;; dup'ed value before call
		cr "Unknown_word_ .str	
		&NextWord .str
		PANIC
		

;; -----------------------------------------------
;; Utility subroutines, invoked with call
;; -----------------------------------------------

:ResetCompile
	0 &IsCompiling writeb			;; set IsCompiling flag = 0 - set to 1 when compiling a word
	0 &IsCompilingWord writeb
	0 &IsCompilingWordMode writeb
	0 &CompileBuf writeb
	0 &CompileStack writeb
	ret

:EmitByte   ;; ( byte -- )
	cpush				;; a=bytevalue
	&CompileBuf readb 1 add cpush	;; b=offset 
	a b &CompileBuf add writeb
	b &CompileBuf writeb
	ret
	
:EmitNumber ;; ( value nbytes -- ) 
	swap 
	cpush			;; a=number
	cpush			;; b=nbytes
	
	;; calculate write position
	&CompileBuf readb 1 add &CompileBuf add cpush    ;; c
	
	;; generate number as code
	a 
		c 
			b
				n2code 				;; returns number of bytes generated
		
	;; update CompileBuf length
	&CompileBuf readb
		add
			&CompileBuf writeb
			
	ret


	
:EmitOp  ;; ( str -- code ) - lookup in dictionary
	&DictLookup call cpush 		;; a=dictionary entry
	a 0 eq &*notFound jmp?
	
	a readb add 1 add a!		;; skip string - points to code
	
	a wordsize add @ 
		2 eq &*ok jmp?  ;; mode==2 (LITERAL) is ok
	
	:*ok
		a @ &EmitByte call
		ret
	
	:*notFound
		cr "EmitOp_ .str
		a .str
		"_not_found .str
		PANIC
	
		
		

:DictLookup ;; ( str -- dictEntry|null )
	cpush				;; a=str
	&DictionaryHead @ cpush		;; b=current dictionary entry
	:*next
		b null eq &*notFound jmp?	;; pointer is null, not found
		b a streq &*found jmp?		;; got a match
		
		b 
			b readb add 1 add 	;; byte count past string
				W+ W+			;; past code-pointer and flags
					@			;; read next pointer
		b!						;; update b with it
		&*next jmp
	:*notFound
		null ret
	:*found
		b ret

:ExecuteWord ;; ( code-ptr-ptr mode-value -- ) ;; decide how to handle word
	swap @ cpush				; a=code-ptr  
	cpush    				; b=mode-value
	
	&IsCompiling readb not &*NotCompiling jmp?
		;; --- compiling
		b 1 eq &*callCode jmp?		;; mode==immediate: call CODE
		b 0 eq &*generateCall jmp?	;; mode==normal: generate call to CODE
		b 2 eq &*inlineCode jmp?	;; mode==inline: add single instruction to code
		ret
	:*NotCompiling
		;; --- interactive		
		b 0 eq &*callCode jmp?		;; mode==normal, call the code
		b 2 eq &*callInline jmp?	;; mode==inline, execute that instruction
		b 1 eq &*callCode jmp?		;; mode==immediate, call the code

		ret
		
	:*callCode
		;; cr "callCode_ .str a print
		a call 
		ret
	:*generateCall
		cr "generateCall_ .str a print
		a 0 &EmitNumber call

		;; add the call instruction
		0x51						;; Q = call
			&EmitByte call

		ret
	:*inlineCode
		;; when inlining, the "code pointer" is the instruction! 00nn!
		;;cr "inlineCode_ .str a print
		a &EmitByte call
		ret
	:*callInline
		;; when inlining, the "code pointer" is the instruction! 00nn!
		;; cr "callInline_ .str a print
		0 &CompileBuf writeb		;; clear CompileBuf (this is interactive mode, so buffer not in use)
		a &EmitByte call
		;; add the opcode
		;;"ret &EmitOp call
		0x52 &EmitByte call  		;; add "R" = ret
		&CompileBuf 1 add call    	;; invoke CompileBuf offset 1 (as byte 0 is the length)
		ret

; -------------------------------------------
; Compile stack functions
; -------------------------------------------
	
; Note type=0 is used to invalidate matched values from the stack

:comps! ( pos type -- )			( p=requires pos parameter )
	8 << 					(type is high byte) 
	orb                 	(pos is low byte)
		cpush				(a=data word)

	&CompileStack readb wordsize mul 1 add
		&CompileStack add 
			cpush			(b = write pos )

	a b !

	(increase stack counter)
	&CompileStack readb 1 add &CompileStack writeb
	ret
	

:comps@ ;; (type -- offset)
	cpush						(a=type)
	&CompileStack readb 0 eq &*emptyStack jmp?
	&CompileStack readb 1 sub cpush		(b=stack pos index for counting down)
	0 cpush						(make variable c available)
	:*next
		&CompileStack b 2 mul add 1 add c!	(c=actual read pos)
		;;cr "Compile_stack:_ .str "read_pos=" .str c print
		;;cr "Compile_stack:_ .str "checking_value= .str c @ print

		c @ 8 >> a eq &*found jmp?
		b 0 eq &*notFound jmp?		(can count no further down)
		b 1 sub b!
		&*next jmp
	:*emptyStack
		cr "Compile_stack:_ .str "empty .str
		PANIC
	:*notFound
		cr "Compile_stack:_ .str 
		"No_matching_type_ .str
		a print#
		PANIC
	:*found
		c @ 255 andb		( return value )
		0 c writeb			( overwrite the entry so it can't match again )
		ret

; CompileStack types
;
; IF = 1
 

:IF 
	105 &EmitByte call		( not - invert false to true for conditional jmp ) 
	&CompileBuf readb 1 &comps! call  (push compileBuf pos on stack)
	; (emit dummy offset data)
	0 &EmitByte call		(note: if not patched, crashes, since 0 is no valid instruction)
	0 &EmitByte call
	54 &EmitByte call		(rfwd? instruction)
	ret

		
:THEN 			 		( patch forward jump at back address )
	1 &comps@ call cpush   		(a=mark pos) 
	&CompileBuf readb cpush		(b=curr pos)
	b a sub 2 sub cpush   		(c=offset)
		( 2 sub for the two bytes of the address - the jump is relative to the rfwd? )

	c
		&CompileBuf 1 add a add   (write pos)
			2 n2code

	ret

:ELSE
	; (Insert jump to the THEN at end of IF block, if original condition was true)
	; (But we can not push it on the compile-stack before resolving the first IF fwd jump)
	
	&CompileBuf readb cpush  		;(a=location of forward jump to THEN)
	1 0 &EmitNumber call			;(unconditional)
	0 &EmitByte call			;(jump address)
	0 &EmitByte call
	54 &EmitByte call			;(rfwd? instruction)
	
	;(now resolve the IF-not forward jump to this position)
	&THEN call
	
	;(and push a new IF forward jump for location a)
	a 1 &comps! call
	ret


;; -----------------------------------------------
;; Implementations for initial complex words in dictionary
;; -----------------------------------------------

	
:COLON
	;; already in compile mode?
	&IsCompiling readb &*nestedError jmp?

	;; set compile mode
	1 &IsCompiling writeb

	;; next word is to be a literal
	&GetNextWord call
	
	&IsNumber readb &*numberError jmp?
	
	;; copy NextWord to IsCompilingWord buffer
	&NextWord
		&IsCompilingWord
			&NextWord readb 1 add
				memcpy
	
	;; set compile output length to 0
	0 &CompileBuf writeb

	;; that's all?
	ret

	:*nestedError
		cr "Can_not_nest_colons:_ .str "_Ignoring .str
		PANIC
	
	:*numberError
		cr "Can_not_use_number_as_word_name:_ .str
		&NextWord .str
		&ResetCompile call
		PANIC
		
:SEMICOLON
	;; verify compile mode
	&IsCompiling readb &*ok jmp?
		;; ignore it
		ret
	:*ok
		;; info
		cr "Finishing_word_ .str &IsCompilingWord .str

		;; add a ret instruction to CompileBuf
		0x52 &EmitByte call

		;; allocate permanent code buffer including length byte
		HERE cpush								;; a=codebuffer
		&CompileBuf readb 1 add				;; length
			allot

		;; copy code into codebuffer including the length
		&CompileBuf 
			a
				&CompileBuf readb 1 add
					memcpy
					
		a 1 add a!	; skip the length byte
		
		;; allocate dictionary entry
		HERE cpush							;; b=dictEntry
		&IsCompilingWord readb 1 add			;; length of symbol
			wordsize 3 mul add				;; code pointer, flags, next
				allot

		;; copy symbol
		&IsCompilingWord					;; src
			b								;; target
				&IsCompilingWord readb 1 add	;; byte count
					memcpy
		
		;; advance dict entry pointer past name
		b readb 
			b add 
				1 add cpush					;; c=point to CODE field

		;; write code address and advance c
		a c !
		c W+ c!

		;; write mode and advance pointer
		&IsCompilingWordMode readb c !
		c W+ c!

		;; write next pointer
		&DictionaryHead @ 
			c !

		;; update DictionaryHead
		b &DictionaryHead !

		;; switch off compile mode and clean up
		&ResetCompile call

		;; all done
		ret

	:*noSymbol
		"No_symbol_defined_for_word .str
		PANIC
	
:immediate
	;; change the IsCompilingWordMode to immediate
	1 &IsCompilingWordMode writeb
	ret		

:Words
	&DictionaryHead @ cpush 		;; a=dictionaryFrame
	0 cpush ;; (b)
	:*next
		a 0 eq &*done jmp?
		a &Dictionary eq &*done jmp?	;; only show Forth words, not standard dictionary
		
		a b!			;; b=name
		cr
		a readb a add 1 add a!   		;; past the name
		a @ print			;; code address
		"_ .str b .str			;; name
		a W+ W+ @ a!			;; a=a.next
		&*next jmp
	:*done
	ret
	
:DATA

;; The dictionary entry has the following format:
;;
;;  - name as string: 1 byte length, followed by characters
;;  - code reference: word pointer
;;  - flags: word
;;  - next: word
;;
;; Next=0 means terminated

;; use these in the Dictionary only, as they generate raw memory values, not code!

#define NORMAL 		HEX:0000
#define IMMEDIATE	HEX:0001
#define INLINE		HEX:0002	;; code pointer is single-byte instruction: "00xx"

;; Note that the dictionary is protected (appears before the :PROTECT tag), because it is
;; a readonly structure. It can still be extended by adding new words that point to it, in
;; effect pushing new entries on the stack that is the dictionary. And which is the 
;; Forth way.


:Dictionary
	;; # --- autogenerated content: Assembler:InlineDictionary
	;; #
		
	%'!             HEX:004A        INLINE      %NEXT        ;; J
	%'.str          HEX:0043        INLINE      %NEXT        ;; C
	%'<<            HEX:0074        INLINE      %NEXT        ;; t
	%'>>            HEX:0075        INLINE      %NEXT        ;; u
	%'@             HEX:0049        INLINE      %NEXT        ;; I
	%'HERE          HEX:0067        INLINE      %NEXT        ;; g
	%'PANIC         HEX:0030        INLINE      %NEXT        ;; 0
	%'PC            HEX:0050        INLINE      %NEXT        ;; P
	%'W+            HEX:006E        INLINE      %NEXT        ;; n
	%'a             HEX:0061        INLINE      %NEXT        ;; a
	%'a!            HEX:0064        INLINE      %NEXT        ;; d
	%'add           HEX:002B        INLINE      %NEXT        ;; +
	%'allot         HEX:004B        INLINE      %NEXT        ;; K
	%'and           HEX:0026        INLINE      %NEXT        ;; &
	%'andb          HEX:0071        INLINE      %NEXT        ;; q
	%'b             HEX:0062        INLINE      %NEXT        ;; b
	%'b!            HEX:0065        INLINE      %NEXT        ;; e
	%'c             HEX:0063        INLINE      %NEXT        ;; c
	%'c!            HEX:0066        INLINE      %NEXT        ;; f
	%'call          HEX:0051        INLINE      %NEXT        ;; Q
	%'call?         HEX:0034        INLINE      %NEXT        ;; 4
	%'clear         HEX:0077        INLINE      %NEXT        ;; w
	%'cpush         HEX:004F        INLINE      %NEXT        ;; O
	%'cr            HEX:0058        INLINE      %NEXT        ;; X
	%'dcopy         HEX:004D        INLINE      %NEXT        ;; M
	%'dget          HEX:004E        INLINE      %NEXT        ;; N
	%'div           HEX:002F        INLINE      %NEXT        ;; /
	%'drop          HEX:006A        INLINE      %NEXT        ;; j
	%'dump          HEX:0070        INLINE      %NEXT        ;; p
	%'dup           HEX:006C        INLINE      %NEXT        ;; l
	%'eq            HEX:003D        INLINE      %NEXT        ;; =
	%'ge            HEX:0045        INLINE      %NEXT        ;; E
	%'global        HEX:0078        INLINE      %NEXT        ;; x
	%'global!       HEX:0079        INLINE      %NEXT        ;; y
	%'gt            HEX:003E        INLINE      %NEXT        ;; >
	%'halt          HEX:005A        INLINE      %NEXT        ;; Z
	%'inv           HEX:0073        INLINE      %NEXT        ;; s
	%'jmp           HEX:0053        INLINE      %NEXT        ;; S
	%'jmp?          HEX:0054        INLINE      %NEXT        ;; T
	%'le            HEX:0046        INLINE      %NEXT        ;; F
	%'lt            HEX:003C        INLINE      %NEXT        ;; <
	%'memcpy        HEX:0044        INLINE      %NEXT        ;; D
	%'mul           HEX:002A        INLINE      %NEXT        ;; *
	%'n2code        HEX:0032        INLINE      %NEXT        ;; 2
	%'ne            HEX:0068        INLINE      %NEXT        ;; h
	%'not           HEX:0069        INLINE      %NEXT        ;; i
	%'null          HEX:007A        INLINE      %NEXT        ;; z
	%'or            HEX:007C        INLINE      %NEXT        ;; |
	%'orb           HEX:0072        INLINE      %NEXT        ;; r
	%'over          HEX:006F        INLINE      %NEXT        ;; o
	%'print         HEX:0057        INLINE      %NEXT        ;; W
	%'print#        HEX:0059        INLINE      %NEXT        ;; Y
	%'printb        HEX:004C        INLINE      %NEXT        ;; L
	%'printc        HEX:0055        INLINE      %NEXT        ;; U
	%'rback?        HEX:0037        INLINE      %NEXT        ;; 7
	%'readb         HEX:0047        INLINE      %NEXT        ;; G
	%'readc         HEX:0076        INLINE      %NEXT        ;; v
	%'ret           HEX:0052        INLINE      %NEXT        ;; R
	%'rfwd?         HEX:0036        INLINE      %NEXT        ;; 6
	%'show          HEX:0056        INLINE      %NEXT        ;; V
	%'streq         HEX:0042        INLINE      %NEXT        ;; B
	%'sub           HEX:002D        INLINE      %NEXT        ;; -
	%'swap          HEX:006D        INLINE      %NEXT        ;; m
	%'tag           HEX:0038        INLINE      %NEXT        ;; 8
	%'wordsize      HEX:006B        INLINE      %NEXT        ;; k
	%'writeb        HEX:0048        INLINE      %NEXT        ;; H




	;; ----------------------------------------------------------
	
	%'words		%Words		NORMAL		%NEXT
	%':		%COLON		NORMAL		%NEXT
	HEX:013B	%SEMICOLON	IMMEDIATE	%NEXT
	%'immediate	%immediate	IMMEDIATE	w0	;; <-- w0 = terminating the linked list
:DictionaryEnd

:PROTECT		;; protects data before this point against writes - reads are allowed

:DictionaryHead %Dictionary

:IsCompiling		b0
:IsCompilingWord	b w0 w0 w0 w0 w0 w0 w0 w0		;; 16 character stringbuffer
:IsCompilingWordMode	b0					;; NORMAL or IMMEDIATE

:CompileBuf		w0 w0 w0 w0 w0 w0 w0 w0 		;; up to 255 bytes, allocated when hitting a COLON
			w0 w0 w0 w0 w0 w0 w0 w0			;; first byte is length
			w0 w0 w0 w0 w0 w0 w0 w0
			w0 w0 w0 w0 w0 w0 w0 w0

			w0 w0 w0 w0 w0 w0 w0 w0
			w0 w0 w0 w0 w0 w0 w0 w0
			w0 w0 w0 w0 w0 w0 w0 w0
			w0 w0 w0 w0 w0 w0 w0 w0

			w0 w0 w0 w0 w0 w0 w0 w0
			w0 w0 w0 w0 w0 w0 w0 w0
			w0 w0 w0 w0 w0 w0 w0 w0
			w0 w0 w0 w0 w0 w0 w0 w0

			w0 w0 w0 w0 w0 w0 w0 w0
			w0 w0 w0 w0 w0 w0 w0 w0
			w0 w0 w0 w0 w0 w0 w0 w0
			w0 w0 w0 w0 w0 w0 w0 w0


:NextWord		b0 w0 w0 w0 w0 w0 w0 w0 w0		;; 16 character stringbuffer
:NextNumber		w0
:IsNumber		b0
:IsWord			b0

:CompileStack		b0 w0 w0 w0 w0 w0 w0 w0 w0 		
				;; 8 words each consists of type (1 byte) and offset in CompileBuf (1 byte)

	
:MemoryEnd


