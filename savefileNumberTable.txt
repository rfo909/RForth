# Manage tags and generating numbers as code
# Numbers in code are issued as sequences of 7 bit numbers, with
# the high bit set, together with the z instruction which puts
# a 0 on the stack. Hitting a high-bit byte, it is processed by
# stripping the high bit, and with the remaining value:  
# 
#	push(pop()*128+value)
#
# --
	self.TAG_BYTES = 2
	
	# tags are assumed 
	self.tags=Dict	# tagName, tagAddress
	self.patchList=List  # of dictionaries with tagName and patchAddress fields
	
	self.defineTag=Lambda{
		P(1) as String => tagName
		P(2) as int => tagAddress
		error(self.tags.has(tagName), "Invalid redefinition of tag " + tagName)
		self.tags.set(tagName,tagAddress)
	}
	
	self.getTagAddress=Lambda{
		P(1) as String => name
		self.tags.get(name)
	}
	
	# when patching unresolved tag lookups
	self.getTagAsCode=Lambda{
		P(1) as String => name
		NumberTable:GenerateNumberBytes(self.tags.get(name), self.TAG_BYTES)
	}
	
			
	
	self.lookupTag=Lambda{
		P(1) as String => tagName
		P(2) as int => patchAddress
		
		addr=0
		if (self.tags.has(tagName)) {
			addr=self.tags.get(tagName)
		} else {
			self.patchList.add(SymDict(tagName,patchAddress))
		}
		# return bytes
		NumberTable:GenerateNumberBytes(addr, self.TAG_BYTES)
	}
	
	self.getTagListSorted = Lambda{
		self.tags.keys->key
			out(Int(self.tags.get(key), key))
		| _.sort->x
			out(x.data)  # key
	}
	
	self.symbols=Dict
	self.symbolData=List  # list of bytes as int
	self.symbolCount=0
	
	# Symbols are stored in a separate string located somewhere at runtime,
	# and the symbols are a position in that string, which points at the length
	# in hex, followed by the characters. 
	#
	# This function returns the address in the form of a list of bytes, which are
	# valid instructions, to be added to the bytecode.
	
	self.addSymbol = Lambda {
		P(1) as String => symbol
		error(symbol.length > 255, "Symbol too long, max 255: " + symbol)
		
		# Check that no forbidden characters
		Inner{
			symbol.chars->c
				code = c.toHexString("ISO-8859-1").parseInt(16)
				error (code < 32 || code > 127, "Invalid symbol character: " + c)
		}
		
		self.symbolCount=self.symbolCount+1
		
		if (self.symbols.has(symbol)) {
			NumberTable:GenerateNumberBytes(self.symbols.get(symbol))
		} else {
			symPos=self.symbolData.length
			self.symbolData.add(symbol.length)
			Inner { 
				symbol.chars->c 
					hex=c.toHexString("ISO-8859-1")
					error(hex.length > 2, "Unexpected hex string " + hex + " for character '" + c + "'")
					self.symbolData.add(hex.parseInt(16))
			}

			# register in dict for reuse if same symbol used again
			self.symbols.set(symbol,symPos)
			NumberTable:GenerateNumberBytes(symPos)
		}
	}
	
	self.getSymbolHexString = Lambda{

		self.symbolData->x
			out(x.hex(2))
		| _.concat
	}
	
/class Numbers


# Test
# --
	tags=Tags
	tags.addTagDef("init",20)
	tags.addTagDef("MAIN",4078)

	println(tags.lookupTag("MAIN", 99).concat(" "))
	println(tags.lookupTag("Undefined", 100).concat(" "))
	
	JSON:PP(tags.patchList)
	"ok"
//tTags



# Generate number as bytes (list of int) - includes value 122 which it the "z" in front
# --
	P(1) as int => number
	P(2,0) as int => byteCount 	# 0 for lowest possible
	
	bits=number.bin(64)
	
	# consuming from the right, 7 bits at a time
	loop
		if (bits.length < 7) bits="0000000"+bits
		break(bits.parseInt(2)==0)
		x="1"+bits.last(7)
		bits=bits.sub(0,bits.length-7)
		out(x.parseInt(2))
	| _.reverse=>bytes
	
	error (byteCount>0 && bytes.length>byteCount,  
		"Value " + number + " does not fit in " + byteCount + " bytes")

	leadingZeroesMissing = 0
	if (byteCount > 0) {
		leadingZeroesMissing=byteCount-bytes.length
	}
	# return value incli
	List(122) + Std.Data.yes(leadingZeroesMissing, 128) + bytes
/GenerateNumberBytes


# Reconstruct number from bytes (for test, as the numbers are considered code, and executed
# one at a time).
# --
	P(1) as List => bytes
	value=0
	bytes->byte
		x=byte.bin(8).last(7).parseInt(2)
		value=value*128+x
	|
	value
//BackToValue



# Test
# --
	GenerateNumberBytes(7029,0) => list
	list.print
	BackToValue(list.keep(1))  # skip the 'z' instruction
//tNumbers
