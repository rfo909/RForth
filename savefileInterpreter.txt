# README
# --
<<< EOF
This test interpreter has no limits on the stacks or the heap. 
The goal is to validate the output from the Assembler.
>>> EOF
/Readme


# The interpreter
# --
	P(1) as String => code

	DSTACK_MAX = 20
	CSTACK_MAX = 40  # callstack
	FSTACK_MAX = 10  # frame stack - contains dictionaries
	
	self.memory=Std.Array(code.chars) # using array, as writes will generate non-readable data 
	self.PC=0

	self.HERE = Lambda{
		println("HERE=" + self.memory.length)
		self.memory.length
	}
	self.malloc = Lambda{
		# extends self.memory - store self.HERE first, as it is the start of the reserved memory
		P(1)=>wordCount
		Std.Data.for(0,wordCount,1)->i
			self.memory.add(0)
	}
		
	# the call stack must exist in self.memory and grow upwards, storing words only,
	# for predictable address calculations. The other two, the dataStack and the
	# frameStack just use the same implementation for practical reasons, although
	# no instructions exist for accessing their base or TOS pointers

	stackAddress=self.HERE
	self.malloc(DSTACK_MAX)
	self.dataStack=WordStack:Stack(self.memory, stackAddress, DSTACK_MAX, "data")

	stackAddress=self.HERE
	self.malloc(CSTACK_MAX)
	self.callStack=WordStack:Stack(self.memory, stackAddress, CSTACK_MAX, "calls")

	stackAddress=self.HERE
	self.malloc(FSTACK_MAX)
	self.frameStack=WordStack:Stack(self.memory, stackAddress, FSTACK_MAX, "frames")

	# the frameStack contains dictionaries identifying the base and the top of the current
	# call frame, which lives on the call stack.
	
	self.nextInstruction=Lambda{
		self.memory.get(self.PC)
	}

	self.showMem=Lambda{
		P(1)=>addr
		if (addr > self.memory.length-2) println("Invalid address")
		else {
			value=self.memory.get(addr)
			hex=""
			if (Sys.getType(value)=="int") hex="0x"+value.hex
			println("=>",value,hex)
		}
	}
	# data stack
	self.push=Lambda{P(1)=>value self.dataStack.push(value)}
	self.pop=Lambda{self.dataStack.pop}


	# call stack
	self.cpush=Lambda{
		P(1) => value
		self.callStack.push(value)
		frameInfo=self.frameStack.peek
		frameInfo.size=frameInfo.size+1
		self.frameStack.replaceTop(frameInfo)  # update data
	}

	# initialize frame stack - these numbers are offsets on the callStack
	self.frameStack.push(Dict.set("base",0).set("size",0))

	self.showFrameStack=Lambda{
		self.frameStack.getStackValues->dict
			out("(base=" + dict.base + ", size=" + dict.size+")")
		| _.concat(" ")
	}
		

	self.executeInstruction=Lambda{
		pc=self.PC
		name="_"+self.memory.get(self.PC)
		if (self.has(name)) {
			closure = self.get(name)
			result = tryCatch(closure.call)
			
			if (!result.ok) {
				println("*** Execution failed:",result.msg)
			} else {
				# executed ok, now update PC unless a jump has already moved it
				if (self.PC == pc) {
					self.PC=pc+1
				}
				println("ok")
			}
		} else {
			println("*** Unknown instruction member",name)
		}
	}
	self._x=Lambda{self.push(0)}
	self._0=Lambda{self.push(self.pop*16+0)}
	self._1=Lambda{self.push(self.pop*16+1)}
	self._2=Lambda{self.push(self.pop*16+2)}
	self._3=Lambda{self.push(self.pop*16+3)}
	self._4=Lambda{self.push(self.pop*16+4)}
	self._5=Lambda{self.push(self.pop*16+5)}
	self._6=Lambda{self.push(self.pop*16+6)}
	self._7=Lambda{self.push(self.pop*16+7)}
	self._8=Lambda{self.push(self.pop*16+8)}
	self._9=Lambda{self.push(self.pop*16+9)}
	self._A=Lambda{self.push(self.pop*16+10)}
	self._B=Lambda{self.push(self.pop*16+11)}
	self._C=Lambda{self.push(self.pop*16+12)}
	self._D=Lambda{self.push(self.pop*16+13)}
	self._E=Lambda{self.push(self.pop*16+14)}
	self._F=Lambda{self.push(self.pop*16+15)}

	self.set("_+", Lambda{self.push(self.pop+self.pop)})
	self.set("_-", Lambda{b=self.pop a=self.pop self.push(a-b)})
	self.set("_*", Lambda{b=self.pop a=self.pop self.push(a*b)})
	self.set("_/", Lambda{b=self.pop a=self.pop self.push((a/b).i)})
	self.set("_<", Lambda{b=self.pop a=self.pop value=if(a<b,1,0) self.push(value)})
	self.set("_=", Lambda{b=self.pop a=self.pop value=if(a==b,1,0) self.push(value)})
	self.set("_>", Lambda{b=self.pop a=self.pop value=if(a>b,1,0) self.push(value)})
	
	self._g=Lambda{self.push(self.memory.length)}   # HERE
	self._U=Lambda{self.push(self.PC)}		# PC
	
	self.set("_&", Lambda{b=self.pop a=self.pop value=if(a != 0 && b != 0, 1, 0) self.push(value)})
	self.set("_|", Lambda{b=self.pop a=self.pop value=if(a != 0 || b != 0, 1, 0) self.push(value)})
	
	self._S=Lambda{self.PC=self.pop}  # jmp
	self._T=Lambda{addr=self.pop cond=self.pop if(cond != 0) self.PC=addr}  # jmp?
	
	self._Q=Lambda{  # call
		targetAddr=self.pop
		returnAddr=self.PC+1 # following call

		self.cpush(returnAddr)
		currFrame=self.frameStack.peek

		frameInfo=Dict.set("base",currFrame.base+currFrame.size).set("size",0)
			# currFrame.size will be at least 1 after we pushed return address

		self.frameStack.push(frameInfo)

		self.PC=targetAddr
			# JMP
	}
	self._R=Lambda{  # ret
		self.frameStack.pop

		frameInfo=self.frameStack.peek  # previous frame

		# resetting callstack as it were before call
		self.callStack.setNext(frameInfo.base + frameInfo.size) 
	
		# popping the jump address
		targetAddr=self.callStack.pop

		# must update the frameInfo about having popped the PC
		frameInfo.size=frameInfo.size-1
		self.frameStack.replaceTop(frameInfo)

		self.PC=targetAddr # JMP
	}
	
	self._I=Lambda{  # @ = read word
		# our "memory" is word-based, which differs from the future C-impl
		addr=self.pop
		self.push(self.memory.get(addr))
	}
	
	self._J=Lambda{  # ! = write word
		addr=self.pop
		value=self.pop
		println("set","addr",addr,"value",value)
		self.memory.set(addr,value)
	}
/class Interpreter





# Test
# --
	P(1) => code
	
	if (code==null) {
		println("Paste then . for code")
		code=readLines(".").concat
	}
	Lib:Header("Code string: " + code.length + " bytes")
	println(code)
	println
	
	x=Interpreter(code)
	loop
		# show PC
		instr=x.nextInstruction
		instrName=instr
		if (!"x0123456789ABCDEF".contains(instr)) instrName=Assembler:InstructionsLookup.get(instr)
		
		# show dataStack
		println("dataStack [ " + x.dataStack.getStackValues.concat(", ") + " ] TOP")
		# show callStack
		println("callStack [ " + x.callStack.getStackValues.concat(" ") + " ] TOP")
		# show frameStack
		println("frameStack[ " + x.showFrameStack + " ] TOP")
		
		println
		println("PC",("0000"+x.PC.hex.toUpper).last(4), instr, instrName)
		
		println
		terminate=false
		Inner{
			loop
				command=readLine("Command: 'q' to quit, 'i' to inspect, ENTER to continue").trim
				if(command=="q") {
					terminate=true
					break
				} else if (command=="i") {
					addr=Input("Enter address on hex format NNNN").get.parseInt(16)
					x.showMem(addr)
				} else if (command.trim=="") {
					x.executeInstruction
					break
				}
			|
		}
		break(terminate)
		
		 
/t		
	
