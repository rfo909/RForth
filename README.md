Forth never ceases to fascinate
================================

Version 3

2025-08-11 RFO

It's been said that the best way of understanding Forth is to build one
yourself. This project aims at the Pi Pico as the run platform,
simply because the toolchain and the deploy is so easy. 

It is unlikely this Forth will ever be used for anything but testing
and development.

The initial effort consisted of making a byte code assembler, and 
developing and compiling the code in the ACode.txt file, which is 
the base code. 

The compiled byte code is kept a printable string, for copy-paste
into the interpreter. 

A major milestone was getting the "call" and "ret" quasi instructions
up and working. They are not real instructions, but instead represent
inlining a number of actual instructions (7 each). We manage our own call
stack, which is also the home for local variables inside functions,
which means that calling and returning from functions ("words") are
implemented as JMP's. This means we are not using the microcontroller's
native call and return stack (although the C implementation of the 
interpreter, naturally will).

External assembler
------------------

The plan is to compile the base code (ACode.txt) outside the Pico,
using the Assembler script (written in [CFT](https://github.com/rfo909/CFT)),
and send the bytecode string (which is kept on printable format) to
it over serial.

A CFT interpreter will also need to be created, in order to step through
the byte code, in order to verify the assembler, and as a measuring stick
for the C code interpreter.

Going Forth
----------- 

Later, we create Forth dictionaries and Forth words out of the 
low level ("assembly") functions, and the capability of defining new words,
compiling them to "assembly". At this point, after sending the base
byte code, we may pipe Forth word definitions over serial, and also
interact with it, probing and examining both memory and functionality.

If all this doesn't sound like fun, I don't know what will! 

Third attempt ...
-----------------

The previous attempts were bogged down in assembly complexities,
which I think are solved now, by introducing the xNNN number literals
as singlebyte instructions, and of course the assembler supporting
local tags within functions.

Other important features of the assembler:

	- handling of symbols on format 'xxx
	- data stack
	- call stack, which supports local variables (via inlining)

The previous attempts tried defining as much as possible within the bytecode,
and it got very complex. It also would have been quite inefficient.

Currently the number of instructions is 34 + 17 (for numeric literals), giving a total 
of 51. We have used printable characters A-Z0-9ghi. The a-f range is free, but there exist
quasi instructions for up to 6 local variables a-f. Waiting with allocating those as
byte codes. The j-z range contains 17 characters, which should be enough.

```
   0: !
   1: @
   2: HERE
   3: PC
   4: add
   5: allot
   6: and
   7: cbase
   8: cmark
   9: cpop
  10: cpush
  11: cr
  12: dcopy
  13: dget
  14: div
  15: dpop
  16: eq
  17: gt
  18: halt
  19: jmp
  20: jmp?
  21: lt
  22: memcpy
  23: mul
  24: ne
  25: not
  26: or
  27: print
  28: readb
  29: show
  30: sub
  31: tPtr
  32: tSymbol
  33: writeb
```

There will be some additional instructions dealing with serial input, either using
a TIB as in Forth, or something else.

Bytecode size
-------------
It is of course important keeping the size of the generated byte code down. The
current version of ACode.txt plus the compiler, handles call+ret and CONS cells
free-listed. 

It compiles to 165 bytes of code, which I think is quite good! It should be possible
implementing the basics of dictionaries and running a first (non-compiled) Forth
engine within an additional 100-150 bytes.

Output from Assembler:

```
Tags
----
Main               | x0000
Init               | x0016
ConsFree           | x0025
ConsAlloc          | x0027
ConsGet            | x0049
ConsGet.FreelistOk | x0064
ConsDispose        | x008A
DATA               | x00A5

Code
----
Ux7+OPSUx7+OPSUx7+OPSVx0x0025JQx2-IRSx0x2x2*Kx1Ox0025IQx2+JQx0025JQx2-
IRSx0025Ix0hx0064Tx0027Ux7+OPSx0025x2+Ix1OQx0025Jx0QJx0Qx2+JQQx2-IRSx1
Ox0025Qx2+JQx0025JQx2-IRS

165 bytes
```
