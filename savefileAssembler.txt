
# Example code
# --
	Sys.savefile.dir.file("ACode.txt").read
/ExampleCode


# Word size
# --
	2
/WORDSIZE

# Check for risky tagging such as creating tag when meaning to refer to it
# --
	num=0
	ExampleCode->line
		if (line.contains(" :") || line.contains("^t:".unEsc) || line.contains("&")) report(num,line)
		num=num+1
/ShowTagUse


# List all instructions
# --
	Instructions.keys.sort
/IShow

# Available printable non-space byte codes
# --
	"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+-*/><=.,;:$!#@%(){}[]\?_&|'`^~"+'"'
//AvailableByteCodes

# Check numeric value range for printable byte codes
# --
	min=999
	max=0
	AvailableByteCodes.chars->c 
		value=c.toHexString("ISO-8859-1").parseInt(16)
		if (value < min) min=value
		if (value > max) max=value
	|
	println("min",min,"max",max)
//BytecodeNumericRange


# Show instructions lookup sorted
# --
	available=Dict
	AvailableByteCodes.chars->c
		available.set(c,false)
	|
	
	data=InstructionsLookup
	data.keys.sort->key
		error(!available.has(key), "Not found in available keys: " + key)
		available.set(key,true)
		number=key.toHexString.first(2).parseInt(16)
		report(number, key,data.get(key))
	| _=>rows
	Lib:ShowRows(rows)

	available.keys->key assert(available.get(key)==false) out(key) | _.concat => unused
	println("Available keys:", unused.length, unused)
	print("Numeric range: ") 
	BytecodeNumericRange
	true
/IRShow


# Build inline-dictionary code
# --
	data=InstructionsLookup

	excluded=List
	
	data.keys.sort->char
		name=data.get(char)
		out(Str(name,char))
	| _.sort->x
		name=""+x
		char=x.data
		
		reject(excluded.contains(name))
		s=("%'"+name + " ".times(16)).first(16)

		hex="HEX:00"+char.toHexString("ISO-8859-1")  # code pointer is code
		s=s+(hex+" ".times(16)).first(16)
		s=s+"BIN_INSTR       "
		s=s+"%NEXT        ;; " + char
		println(s)
/InlineDictionary


# Show interpreter instructions
# --
	Sys.savefile.dir.file("savefileInterpreter.txt").read->line
		
		assert( line.contains("self._") && line.contains("=") || line.contains('self.set("_') )
		out(line.after("self").after("_").chars.first)
	| _.sort.concat => x
	
	locals=Instructions
	locals.keys->key out(locals.get(key)) | _.sort.concat => y
	
	println("Interpreter: " + x)
	println("Assembler  : " + y)
	
	"ok"
/II
	
		
		
# Check what instructions remain to be implemented in the interpreter
# --
	f=Dir.file("savefileInterpreter.txt")
	data=InstructionsLookup
	
	data.keys->key
		Grep("self._"+key).fileCount(f) + Grep('self.set("_' + key).fileCount(f) => count
		reject(count>0)
		report(key,count,data.get(key))
/CheckRemaining
		

# Generate doc for instruction set
# --
	f=Sys.savefile.dir.file("savefileInterpreter.txt")
	data=InstructionsLookup
	
	data.keys.sort->key
		{
			a=Grep("self._"+key).match("=").file(f)
			b=Grep('self.set("_' + key).file(f)
			(a+b)->line
				out(line)
		}
	| _ -> line

		desc=line.after("#").trim
		name=desc.before(" ")
		desc=desc.after(" ").trim
		if (desc.startsWith("-")) desc=desc.sub(1).trim
		out(Str(name, SymDict(name,desc)))
	| _.sort->x
		dict=x.data
		report(dict.name, dict.desc)
	| _=>rows
	Lib:ShowRows(rows,null,false)
/IDoc

# Generate numeric values for instructions
# --
	data = InstructionsLookup
	data.keys.sort->code
		name=data.get(code)
		out(Str(name,code))
	| _.sort->x
		code=x.data
		name=data.get(code)
		num=code.toHexString("ISO-8859-1").first(2).parseInt(16)
		report(name,code,num)
/NDoc

# Generate numeric values for instructions
# --
	NDoc->row
		out(Int(row.get(2),row))
	| _.sort->x
		out(x.data)  # row
	| _=>rows
	rows->row
		name=row.get(0)
		value=row.get(2)
		println("ops["+value+"]=op_" + name + ";")
/NNDoc


# Assembly instructions mapped to "machine code"
# --
<<< EOF
	;; memory and registers
	readb		:G		;; read byte
	writeb		:H		;; write byte
	@		:I		;; read cell/word
	!		:J		;; write cell/word	

	allot		:K
	HERE		:g
	wordsize	:k
	PC		:P		;; push PC word on stack
	
	W+		:n	;; wordsize add 

	;; data stack operations
	drop		:j		;; remove stack top element
	dup		:l
	swap		:m
	over		:o
	dump		:p		;; show stack content
	clear		:w		;; clear stack
	
	;; Both dStack and cstack must grow upwards in memory, containing words only, for
	;; predictable address calculations

	;; call stack: note that "marks" are separate (hidden) structure, not physical on the 
	;; visible call stack (for example separate frame stack)
	
	cpush		:O   	;; push 1 value from data stack to callstack
				;; up to 3 values accessible as local variables a@ a! b@ b! c@ c! (single instructions)

	cget		:3	;; copy value off call stack indexed from frame base (must be cpush'ed first)
	cset		:4	;; set value on call stack (must be cpush'ed first)

	
	;; compiled numbers
		
	null		:z		;; push zero on the stack
	n2code		:2		;; convert number on stack to 2-4 code bytes (constant numbers)
	
	;; math (note x0-9A-F are not included)
	add		:+
	sub		:-
	mul		:*
	div		:/
	1+		:d

	;; logical operations
	eq		:=	;; 0 or 1
	ne		:h	;; 0 or 1
	gt		:>	;; 0 or 1
	lt		:<	;; 0 or 1
	not		:i	;; logical
	and		:&	;; logical 
	or		:|	;; logical
	
	ge		:E	;; logical
	le		:F	;; logical
	
	;; bitwise operations
	andb		:q
	orb		:r
	inv		:s
	<<		:t
	>>		:u

	;; flow of control
		
	jmp		:S
	jmp?		:T   	;; conditional jump on true	
	call		:Q  
	ret		:R
	
	rfwd?		:6	;; single byte (0-64) offset jumps (inside word)
	rback?		:7
	
	;;tag		:8	;; look up address of tag

	PANIC		:0	;; clean up stacks and set PC=0
	
	native		:a	;; call native function by name
	nativec	:c	;; compile native name to address
	
	;; I/O
	print		:W   ;; print any single value in hex
	cr			:X
	print#		:Y   ;; print value in decimal
	printb		:L   ;; print value in binary
	printc		:U   ;; print value as character (if single byte)
	print#s		:b	 ;; print value as signed decimal
	
	halt		:Z   ;; halt automatic execution in interactive interpreter (hard-coded breakpoint)
				;; on a microcontroller we will just run in a tight forever loop when halted
	readc		:v   ;; ( -- byte ) - read single character (byte), blocking 
		
	;; Strings are stored as one length byte and N characters (max 255)

	.str		:C		;; print string
	streq		:B		;; compare strings ( ptr ptr -- 0/1 )  boolean
	u2spc		:_	
	memcpy		:D		;; ( ptrSrc ptrTarget count -- )
	atoi		:1		;; parse string to integer

>>> EOF
	=>list
	
	dict=Dict
	values="" 
	
	list->rawLine
		line=rawLine.before(";")
		assert(line.trim.length>0)
		line.split(":")=>parts
		
		token=parts.first.trim
		value=parts.last.trim
		error(value.length != 1, "Invalid machine instruction, must be 1 char: " + value)
		error(values.contains(value),"Duplicate machine instruction: " + value)
		
		dict.set(token,value)
		values=values+value
	|
	dict
//Instructions


# Debug mode?
# --
	Db2:Get(Sys.scriptId,"debug",false)
//IsDebug

# Flip debug mode
# --
	Db2:Set(Sys.scriptId,"debug", !IsDebug)
	IsDebug
/Debug


# Inline defs static plus defined in source as macros with '#name ...'
# --
	dict=Dict
		.set("spc",'"_ .str')
		
	self.dict=dict
	
		
	self.hasSymbol=Lambda{
		P(1) as String=>symbol 
		self.dict.has(symbol)
	}
	self.getSymbol=Lambda{
		P(1) as String => symbol
		self.dict.get(symbol)
	}
	self.addSymbol=Lambda{
		P(1) as String => symbol
		P(2) as String => code
		self.dict.set(symbol,code)
	}
/class Inlines



# Word generator for source, for handling inlines (via push)
# --
	self.words=List
	self.push = Lambda{
		P(1) as List => lines
		words=Inner{
			lines->line
				#println(line)
				line.before(";").before("(").trim.split->word
					out(word.trim)
		}
		self.words=words+self.words
	}
	self.getWord = Lambda{
		if(self.words.empty) {
			null
		} else {
			self.words.first => word
			self.words=self.words.keep(1)
			if (IsDebug) println("getWord",word)
			word
		}
	}
	self.append = Lambda{
			P(1) as List => lines
		words=Inner{
			lines->line
				#println(line)
				line.before(";").before("(").trim.split->word
					out(word.trim)
		}
		self.words=self.words+words
	}
/class Words
	

# Assemble input to "machine code" format
# --
	P(1,ExampleCode) => code
	
	inlines=Inlines
	
	# process macros in code
	code = Inner{
		code->line
			if (line.startsWith("#define ")) {
				name=line.after(" ").before(" ")
				code=line.after(" ").after(" ")
				inlines.addSymbol(name,code)
				println("MACRO:", name)
			} else {
				out(line)
		}
	}
	
	currentTag="<DEFAULT>"
	
	words=Words
	words.push(code)

	instructions=Instructions

	numberTable=NumberTable:Numbers
		# keeps track of tags and symbols, plus has code for converting
		# constants to byte code
					
	bytecode=Bytecode:Bytecode   # object
	
	STRcount=0
	
	loop
		word=words.getWord
		break(word==null)
		
		# inlines
		if (inlines.hasSymbol(word)) {
			#println("Inline",word)
			words.push(List(inlines.getSymbol(word)))
			continue
		}
		
	
		# specials
		
		bytecode.addMeta(word)
		
		# -- decimal format numbers
		if ("0123456789".indexOf(word.chars.first) >= 0 && word.?parseInt) { 
			n=word.parseInt
			bytecode.addRawBytes(NumberTable:GenerateNumberBytes(n))
			continue
		}
		
		# -- hex format number
		if ((word.startsWith("x") || word.startsWith("0x")) && word.after("x").?parseInt(16)) {
			n=word.after("x").parseInt(16)
			bytecode.addRawBytes(NumberTable:GenerateNumberBytes(n))
			continue
		}

		# -- binary format number
		if (word.startsWith("b") && word.sub(1).?parseInt(2)) {
			n=word.sub(1).parseInt(2)
			bytecode.addRawBytes(NumberTable:GenerateNumberBytes(n))
			continue
		}
		
		# -- symbols are no longer supported, must be stored at separate addresses!!
		# this means the sym2s instruction is no longer needed, as static strings are REAL string pointers
		if (word.startsWith("'") || word.startsWith('"')) {
			error("Static symbol " + word + " must be written as :Str_xxx %'xxx -- then referred as &xxx")
			
			symbol=word.sub(1)
			if (word.startsWith('"')) symbol=symbol.replace("_"," ")
			
			bytecode.addRawBytes(numberTable.addSymbol(symbol))
			# add instruction to convert symbol to string at runtime
			words.push(List("sym2s"))
			continue
		}
		
		# -- %NEXT
		if (word=="%NEXT") {
			# point to next word (for static lists)
			value=bytecode.length+WORDSIZE
			bytecode.addRawWord(value)
			continue
		}
		
		# -- inline (literal data) symbols
		if (word.startsWith("%'")) {
			symbol=word.after("'")

			words.push(List("HEX:"+symbol.length.hex(2) + symbol.toHexString("ISO-8859-1")))
			continue
		}
		
		if (word.startsWith('%"')) {
			symbol=word.after('"').replace("_"," ")
			 
			words.push(List("HEX:"+symbol.length.hex(2) + symbol.toHexString("ISO-8859-1")))
			continue
		}
		
		# -- literal tag lookup
		if (word.startsWith("%")) {
			tag=word.after("%")
			addr=numberTable.getTagAddress(tag)
			
			words.push(List("HEX:" + addr.hex(4)))
			continue
		}
			
		
		# --- the HEX:NNN.. special word
		if (word.startsWith("HEX:")) {
			hex=word.after(":")
			Inner {
				loop
					break(hex=="")
					s=hex.first(2)
					hex=hex.sub(2)
					bytecode.addRawByte(s.parseInt(16))
			}
			continue
		}		

		# -- local tag def
		if (word.startsWith(":*")) {
			tag=currentTag + "." + word.after(":*")
			pos=bytecode.length
			numberTable.defineTag(tag,pos)
			
			continue
		}
		# -- global tag def
		if (word.startsWith(":")) {
			tag=word.after(":")
			pos=bytecode.length
			numberTable.defineTag(tag,pos)

			currentTag=tag
			continue
		}

		# -- local tag reference
		if (word.startsWith("&*")) {
			tag=currentTag + "." + word.after("&*")
			bytecode.addRawBytes(numberTable.lookupTag(tag, bytecode.length))
			continue
		}
		# -- get global tag value
		if (word.startsWith("&")) {
			tag=word.after("&")
			bytecode.addRawBytes(numberTable.lookupTag(tag, bytecode.length))
			continue
		}
			
		# look up word in instructions map or fail
		if (instructions.has(word)) {
			char=instructions.get(word)
			bytecode.addChar(char)
		} else {
			error("Unknown word: '" + word + "'")
		}
	
	|
	
	# Return dict	
	SymDict(bytecode,numberTable,inlines)
/Assemble


# Create instructions lookup dictionary
# (Reverse of the Instructions dict)
# --
	dict=Dict
	instr=Instructions
	instr.keys->key
		value=instr.get(key)
		dict.set(value,key)
	|
	dict
//InstructionsLookup


# Disassembler showing what was generated
# --
	P(1) as Dict => dict
	
	bytecode=dict.bytecode
	numberTable=dict.numberTable
	
	DATA = numberTable.getTagAddress("DATA")
	END = numberTable.getTagAddress("DATA")   # the Interpreter "dump" is better for data
		
	lookup=InstructionsLookup
	
	length=bytecode.length
	Std.Data.for(0,length,1)->pos
		break(pos >= END)
		
		p1 = pos.hex(4).toUpper + " "
		p2 = bytecode.getMeta(pos)

		instr=bytecode.getValue(pos)
		
		p3=""
		p4=""
		if (Sys.getType(instr)=="String") {
			if (lookup.has(instr)) {
				p4=lookup.get(instr)
			}
			else error("Unknown instruction '" + instr + "'")
		} else if (Sys.getType(instr)=="int") {
			if (pos < DATA) {
				p4="0x"+instr.hex(2)
			} else {
				p3="DATA"
				p4="0x"+instr.hex(2)  # a byte
			}
		} else {
			error("Unknown instr type: " + instr)
		}
		report(p1,p2,p3,p4)
	| _=>rows
	Lib:ShowRows(rows)
/Disassemble
			
	

# Test by assembling ACode.txt, then disassembling it
# --
	Assemble => dict

	bytecode=dict.bytecode
	numberTable=dict.numberTable
	
	# Patch missing tag data
	Inner{
		numberTable.patchList->p
			tagName = p.tagName
			patchAddress = p.patchAddress
			#println("Patching", tagName,"at addr", patchAddress.hex(4))
			
			code = numberTable.getTagAsCode(tagName)
			bytecode.patch(patchAddress, code)
	}
	
	Disassemble(dict)
	
	metaInfo=dict.bytecode.metaInfo # indexed by ""+PC
	numberTable=dict.numberTable
	
	# Display all tags
	Lib:Header("Tags")
	
	Inner{
		dict.numberTable.getTagListSorted->tag
			report(tag,numberTable.getTagAddress(tag).hex(4), numberTable.getTagAddress(tag))
		| _=>rows
		Lib:ShowRows(rows, null, false)
	}
	
	println

	println("bytecode")
	hexBlock=bytecode.getCodeHex
	
	symbolsStart = hexBlock.length div 2
	hexBlock=hexBlock + numberTable.getSymbolHexString
	
	println
	println("symbolsStart", symbolsStart.hex(4))
	println
	#println("Hexblock length:", hexBlock.length)
	totBytes=hexBlock.length div 2
	println("Total #bytes:", totBytes, totBytes.hex(4))
	

	# Store stuff in database for interpreter to pick up automagically
	tags=numberTable.tags
	tagListSorted=numberTable.getTagListSorted
	
	Db2:Set("RForth", "data", SymDict(hexBlock, symbolsStart, tags, tagListSorted, metaInfo))
	
	println
	Lib:Header("Macros")
	Inner{
		dict.inlines.dict.keys.sort->symbol println(symbol)
	}
	
	"ok"
	
/Compile

Compile
/t


# Block format text for copy/paste
# --
	P(1) as String => s
	
	loop
		if (s.length > 70) {
			println(s.sub(0,70))
			s=s.sub(70)
			continue
		} else {
			println(s)
			break
		}
/BlockFormat
