
# The interpreter
# --
	P(1) as String => hexString
	P(2) as int => numberLookupStart
	P(3) as int => symbolLookupStart

	# number of words
	DSTACK_WORDS = 20
	CSTACK_WORDS = 40  # callstack
	FSTACK_FRAMES = 10  # frame stack contains dictionaries
	
	self.WORDSIZE = 2
	self.memory=HWSim:Memory(self.WORDSIZE)
		
	self.globalVariableCount = 4
		# global variables, read with instruction 'global' and set with 'global!'
	
	# --- write the hex string into memory
	
	bytes = Util:HexToBytes(hexString)
	addr=self.memory.HERE
	error(addr != 0, "Invalid start address: " + addr)

	self.memory.malloc(bytes.length)
	bytes->b self.memory.writeByte(addr,b) addr=addr+1 |

	# -- store information about the imported hex string
	
	self.numberLookupStart=numberLookupStart
	self.symbolLookupStart=symbolLookupStart
	self.symbolLookupEnd=bytes.length

	self.PC=0
	self.haltFlag=false
	
	self.outputLines=List("")

	self.addOutputText = Lambda{
		P(1) as String => s
		
		currOutputLine=self.outputLines.last
		index=self.outputLines.length-1
		updatedLine = currOutputLine + s
		self.outputLines.set(index,updatedLine)
	}
	self.addOutputCR = Lambda {
		self.outputLines.add("")
	}


		
	# --- create system data objects in memory
	
	# the data stack stores single words

	self.dbase=self.memory.HERE
	self.memory.mallocWords(DSTACK_WORDS)
	self.dataStack=HWSim:MemStack(self.memory, self.dbase, DSTACK_WORDS, "data")

	# the call stack stores single words
	
	self.cbase=self.memory.HERE
	self.memory.mallocWords(CSTACK_WORDS)
	self.callStack=HWSim:MemStack(self.memory, self.cbase, CSTACK_WORDS, "calls")

	# the frame stack stores frames as two words: base and size
	
	self.fbase=self.memory.HERE
	FSTACK_WORDS=FSTACK_FRAMES*2
	self.memory.mallocWords(FSTACK_WORDS)
	self.frameStack=HWSim:MemStack(self.memory, self.fbase, FSTACK_WORDS, "frames")

	# global variables
	self.globalVariablesBase=self.memory.HERE
	self.memory.mallocWords(self.globalVariableCount)
	
	# --- done with integrating code and setting up system structures on heap

	self.DATA_START=self.memory.HERE

	self.nextInstruction=Lambda{
		self.memory.readByte(self.PC)
	}


	# data stack
	self.push=Lambda{P(1)=>value self.dataStack.push(value)}
	self.pop=Lambda{self.dataStack.pop}


	# call stack
	self.cpush=Lambda{
		P(1) as int => value
		self.callStack.push(value)
		frameInfo=self.fpeek

		self.frameStack.pop
		self.frameStack.pop
		self.fpush(frameInfo.base, frameInfo.size+1)
	}

	# frame stack
	
	self.fpush = Lambda{
		P(1) as int => base
		P(2) as int => size
		self.frameStack.push(base)
		self.frameStack.push(size)
	}

	self.fpeek = Lambda {
		size=self.frameStack.pop
		base=self.frameStack.peek
		self.frameStack.push(size)
		SymDict(base,size)
	}

	self.fpop = Lambda{
		self.frameStack.pop
		self.frameStack.pop
	}

	# initialize frame stack these numbers are offsets on the callStack

	self.fpush(0,0)


	self.executionCount=0
	self.executeInstruction=Lambda{

		pc = self.PC
		
		instr=self.memory.readByte(self.PC)
		if (instr < 32) {
			# reserved
			error("Reserved instruction: " + instr)
		} else if (instr > 127) {
			# constant number lookup
			index=instr-128
			addr=self.numberLookupStart+(index*self.WORDSIZE)
			value=self.memory.readWord(addr)
			#println("[" + instr + "] push 0x" + value.hex(4))
			self.push(value)
		} else {
			instr=Sys.uchar(instr)
			lambdaName="_"+instr
			
			error(!self.has(lambdaName), "Unknown instruction lambda '" + lambdaName + "'") 

			closure = self.get(lambdaName)
			result = tryCatch(closure.call)
			
			if (!result.ok) {
				error ("Execution failed: " 
				+ " lambdaName=" + lambdaName 
				+ " msg=" + result.get("msg","(no message)")
				+ " PC=" + pc
				+ " count=" + self.executionCount)
			}
		}
		
		# Executed ok, now update PC unless a jump has already moved it
		if (self.PC == pc) {
			self.PC=pc+1
		}
		self.executionCount=self.executionCount+1
	}

	self._k=Lambda{ # wordsize ( -- N )
		self.push(self.WORDSIZE)
	}
	self._K=Lambda{ # allot  ( N -- )
		byteCount=self.pop
		self.memory.malloc(byteCount)
	}
	self._G=Lambda{ # readb read byte ( addr -- value )
		addr=self.pop
		if (addr < self.DATA_START) error("readb: reading below DATA_START: 0x" + addr.hex(4))
		self.push(self.memory.readByte(addr))
	}
	self._H=Lambda{ # writeb write byte ( addr -- value )
		addr=self.pop
		if (addr < self.DATA_START) error("writeb: writing below DATA_START: 0x" + addr.hex(4))
		value=self.pop
		self.memory.writeByte(addr,value)
	}


	## Local variable instructions a-f

	self._a=Lambda{  # a read local variable a ( -- value )
		frameInfo=self.fpeek
		base=(self.cbase + (frameInfo.base*self.WORDSIZE))
		value=self.memory.readWord(base)
		self.push(value)
	}
	self._b=Lambda{  # b read local variable b ( -- value )
		frameInfo=self.fpeek
		base=(self.cbase + (frameInfo.base*self.WORDSIZE))
		value=self.memory.readWord(base+self.WORDSIZE)
		self.push(value)
	}
	self._c=Lambda{  #  c read local variable c ( -- value )
		frameInfo=self.fpeek
		base=(self.cbase + (frameInfo.base*self.WORDSIZE))
		value=self.memory.readWord(base+self.WORDSIZE*2)
		self.push(value)
	}
	self._d=Lambda{  # a! set local variable a ( value -- )
		value=self.pop
		frameInfo=self.fpeek
		base=(self.cbase + (frameInfo.base*self.WORDSIZE))
		self.memory.writeWord(base, value)
	}
	self._e=Lambda{  # b! set local variable b ( value -- )
		value=self.pop
		frameInfo=self.fpeek
		base=(self.cbase + (frameInfo.base*self.WORDSIZE))
		self.memory.writeWord(base+self.WORDSIZE, value)
	}
	self._f=Lambda{ # c! set local variable c ( value -- )
		value=self.pop
		frameInfo=self.fpeek
		base=(self.cbase + (frameInfo.base*self.WORDSIZE))
		self.memory.writeWord(base+self.WORDSIZE*2, value)
	}

	self.set("_+", Lambda{self.push(self.pop+self.pop)}) # add ( a b -- a+b )
	self.set("_-", Lambda{b=self.pop a=self.pop self.push(a-b)}) # sub ( a b -- a-b )
	self.set("_*", Lambda{b=self.pop a=self.pop self.push(a*b)}) # mul ( a b -- a*b )
	self.set("_/", Lambda{b=self.pop a=self.pop self.push((a/b).i)}) # div ( a b -- a/b )
	self.set("_<", Lambda{b=self.pop a=self.pop value=if(a<b,1,0) self.push(value)}) # lt ( a b -- 0|1 )
	self.set("_=", Lambda{b=self.pop a=self.pop value=if(a==b,1,0) self.push(value)}) # eq ( a b -- 0|1 )
	self.set("_>", Lambda{b=self.pop a=self.pop value=if(a>b,1,0) self.push(value)}) # gt ( a b -- 0|1 )
	self._h=Lambda{	# ne boolean ( a b -- 0|1 )
		b=self.pop a=self.pop value=if(a!=b,1,0) self.push(value)
	}
	self._i=Lambda{ # not boolean ( x -- 0|1 )
		a=self.pop value=if(a==0,1,0) self.push(value)
	}
	
	self._g=Lambda{self.push(self.memory.HERE)}   # HERE ( -- value )
	
	self.set("_&", Lambda{b=self.pop a=self.pop value=if(a != 0 && b != 0, 1, 0) self.push(value)}) # and boolean ( a b -- 0|1 )
	self.set("_|", Lambda{b=self.pop a=self.pop value=if(a != 0 || b != 0, 1, 0) self.push(value)}) # or boolean ( a b -- 0|1 )
	
	self._S=Lambda{   # jmp ( addr -- ) updates PC
		self.PC=self.pop
	}
	self._T=Lambda{  # jmp? ( cond addr -- ) conditionally updates PC
		addr=self.pop 
		cond=self.pop 
		if(cond != 0) self.PC=addr  
	}  
	
	self._Q=Lambda{  # call ( addr -- )
		targetAddr=self.pop
		returnAddr=self.PC+1 # following call

		self.cpush(returnAddr)
		currFrame=self.fpeek

		frameInfo=Dict.set("base",currFrame.base+currFrame.size).set("size",0)
			# currFrame.size will be at least 1 after we pushed return address

		base=currFrame.base+currFrame.size
		size=0
		self.fpush(base,size)

		self.PC=targetAddr # JMP
	}
	self._R=Lambda{  # ret return
		self.fpop

		frameInfo=self.fpeek  # previous frame

		# resetting callstack as it were before call
		self.callStack.setNext(frameInfo.base + frameInfo.size) 
	
		# popping the jump address
		targetAddr=self.callStack.pop

		# must update the frameInfo about having popped the PC from the callStack
		base=frameInfo.base
		size=frameInfo.size-1
		self.fpop
		self.fpush(base,size)

		self.PC=targetAddr # JMP
	}
	
	self._I=Lambda{  # @ read word
		addr=self.pop
		if (addr < self.DATA_START) error("@: reading below DATA_START: 0x" + addr.hex(4))
		self.push(self.memory.readWord(addr))
	}
	
	self._J=Lambda{  # ! write word
		addr=self.pop
		if (addr < self.DATA_START) error("!: writing below DATA_START: 0x" + addr.hex(4))
		value=self.pop
		self.memory.writeWord(addr,value)
	}

	self._O=Lambda{  # cpush push value from data stack on call stack ( x -- )
		self.cpush(self.pop)
	}

	self._M=Lambda{ # dcopy: ( a b c 1 -- a b c b )
		offset=self.pop
		value=self.dataStack.getValue(offset)
		self.push(value)
	}

	self._N=Lambda{ # dget: (a b c 1 -- a c b)
		offset=self.pop
		value=self.dataStack.removeValue(offset)
		self.push(value)
	}

	self._j=Lambda { # drop  ( a -- )
		self.pop
	}
	
	self._l=Lambda{ # dup ( x -- x x )
		value=self.pop
		self.push(value)
		self.push(value)
	}
	
	self._m=Lambda{ # swap ( a b -- b a )
		a=self.pop
		b=self.pop
		self.push(a)
		self.push(b)
	}
	
	self._n=Lambda{ # W+   ( n -- n+WORDSIZE )
		value=self.pop
		self.push(value+self.WORDSIZE)
	}

	self._o=Lambda{ # over ( a b -- a b a )
		b=self.pop
		a=self.pop
		self.push(a)
		self.push(b)
		self.push(a)
	}

	self._p=Lambda{ # dump show stack contents ( -- )

		println("Datastack BOTTOM ---> TOP")

		values=self.dataStack.getStackValues 
		values->x
			s=("    "+x).last(5)+" "
			print(s)
		|
		println

		values->x
			s=("    x"+x.hex).last(5)+" "
			print(s)
		|

		println
	}
	
	self._V=Lambda{ # show ( sym sym ... count -- )
		count=self.pop  # number of symbols

		Std.Data.for(0,count,1)->i
			out(self.pop)
		| _.reverse -> symbolRelativePos
			symbolAddr=self.symbolLookupStart + symbolRelativePos
			error(symbolAddr > self.symbolLookupEnd - self.WORDSIZE, "Invalid symbol lookup address: " + symbolAddr)
			
			length=self.memory.readByte(symbolAddr)
			
			# read characters
			Inner{
				Std.Data.for(0,length,1)->pos
					ch=self.memory.readChar(symbolAddr+1+pos)  # +1 skip length byte
					out(ch)
			} _.concat => symbol
			
			self.addOutputText(""+symbol+" ")
	}
	self._W=Lambda{ # print print top value on hex format
		value=self.pop
		self.addOutputText("0x" + value.hex(4)+" ")
	}
	self._Y=Lambda{ # print# print top value on decimal format
		value=self.pop
		self.addOutputText(""+value+" ")
	}
	self._L=Lambda{ # printb print top value on binary format
		value=self.pop
		s=value.bin(self.WORDSIZE*8)
		self.addOutputText(s.sub(0,8)+"_"+s.sub(8) + " ")
	}
	self._X=Lambda{ # cr print newline
		self.addOutputCR
	}

	self._q=Lambda { # andb binary and ( a b -- c )
		b=self.pop
		a=self.pop
		self.push(HWSim:BitwiseAnd(a,b,self.WORDSIZE))	
	}

	self._r=Lambda { # orb binary or ( a b -- c )
		b=self.pop
		a=self.pop
		self.push(HWSim:BitwiseOr(a,b,self.WORDSIZE))	
	}
	self._s=Lambda{ # inv binary not  ( a -- b )
		a=self.pop
		self.push(HWSim:BitwiseNot(a, self.WORDSIZE))
	}
	self._t=Lambda { # << left shift  ( val n -- val )
		bits=self.pop
		value=self.pop
		self.push(HWSim:Leftshift(value, bits, self.WORDSIZE))
	}
	self._u=Lambda { # >> right shift  ( val n -- val )
		bits=self.pop
		value=self.pop
		self.push(HWSim:Rightshift(value, bits, self.WORDSIZE))
	}
	
	self._x=Lambda { # global - get global variable ( N -- value)
		n=self.pop
		error(n<0 || n>=self.globalVariableCount, "global: invalid reference: " + n)
		addr=self.globalVariablesBase + n*2
		self.push(self.memory.readWord(addr))
	}
	self._z=Lambda { # global! - set global variable ( value N -- )
		n=self.pop
		value=self.pop
		error(n<0 || n>=self.globalVariableCount, "global!: invalid reference: " + n)
		addr=self.globalVariablesBase + n*2
		self.memory.writeWord(addr, value)
	}
	self._Z=Lambda{  # halt - terminate execution
		self.haltFlag=true
	}

/class Interpreter



# Show frame stack
# --
	P(1) as &MemStack => frameStack

	# pair two values
	count=0
	frameStack.getStackValues->value
		count=count+1
		if (count % 2 == 0) out(":") else out(" ")
		out(value)
	| _.concat
//ShowFrameStack


# Show word stack
# --
	P(1) as &MemStack => stack
	stack.getStackValues->value
		out(value.hex(4))
	| _.concat(" ")
//ShowWordStack


# Show global variables
# --
	P(1) as &Interpreter => interpreter

	Std.Data.for(0, interpreter.globalVariableCount, 1)->index
		out(" " + interpreter.memory.readWord(interpreter.globalVariablesBase + index*interpreter.WORDSIZE).hex(4))
	| _.concat.trim

/ShowGlobals



# Show memory content
# --
	P(1) as int => startAddr
	P(2) as &Memory => memory
	
	lastAddr=startAddr + 32
	if (lastAddr >= memory.HERE) lastAddr=memory.HERE
		

	hex=""
	info=""
	dec=""
	
	Std.Data.for(startAddr, lastAddr, 1)->addr
		offset=addr-startAddr

		if (offset % 2 == 0) {
			println (hex + "  " + info + "  " + dec)
			print(("   "+addr).last(3) + "  " + addr.hex(4)+" | ")
			hex=info=dec=""
		}
		value=memory.readByte(addr)
		hex=hex+value.hex(2) + " "
		dec=dec+("   "+value).last(3)+" "

		if (value >=33 && value <=127) {
			info=info + Sys.uchar(value) + " "
		} else {
			info=info + ". "
		}
		
	|
	println (hex + "  " + info + "  " + dec)

	println
	readLine("Continue")
/ShowMemory	


# Read address
# --
	P(1) as int => dataStart
	println("DATA_START: " + dataStart.hex(4))
	Input("Enter address hex NNNN or decimal #NNNN").setCurr(dataStart.hex(4)).get =>addr
	if (addr.startsWith("#")) {
		addr.after("#").parseInt(10)
	} else if (addr.startsWith("0x") || addr.startsWith("x")) {
		addr.after("x").parseInt(16)
	} else {
		addr.parseInt(16)
	}
//ReadMemoryInspectAddress

	
	
		

# Test
# --
	# uses Curses
	Curses:Enable

	dict = Db2:Get("RForth","data")
	hexBlock=dict.hexBlock
	numbersStart=dict.numbersStart
	symbolsStart=dict.symbolsStart
	tags=dict.tags
	tagListSorted=dict.tagListSorted
	metaInfo=dict.metaInfo
	
	autoRunCount=0
	breakpoint=-1

	interpreter=Interpreter(hexBlock, numbersStart, symbolsStart)

	loop
		print(Curses:Clear)
		if (interpreter.haltFlag) {
			if (autoRunCount>0) {
				println
				Lib:Header("haltFlag set, stopping automatic execution, then resetting it")
				autoRunCount=0
				readLine("Continue")
			} else {
				println
				println("haltFlag detected, resetting it")
				println
			}
			interpreter.haltFlag=false
		}
		if (interpreter.PC==breakpoint) {
			autoRunCount=0
		}
		
		if (autoRunCount > 0) {
			interpreter.executeInstruction
			autoRunCount=autoRunCount-1
			continue
		}
		
		# show outputlines
		
		outputLines=interpreter.outputLines
		if (outputLines.length > 10) outputLines = outputLines.last(10)
		outputLines=List("Output:","-------")+outputLines
		count=outputLines.length
		Inner {
			x=60
			maxLineLength=Term.w-x-2
			
			Std.Data.for(0,count,1)->y
				line=outputLines.get(y)
				if (line.length > maxLineLength) line=line.sub(0,maxLineLength)+"+"
				println(Curses:CurGoto(x,Term.h-10-count+y)+line)
				
		}
		
		print(Curses:Home)
		
		# show context
		lines=Term.h-10
		if (!Curses:Enabled) lines=lines-5
		
		from=interpreter.PC-(lines div 3)
		if (from < 0) from=0
		to=from+lines
		if (to > numbersStart) to=numbersStart
		
		Inner {
			Std.Data.for(from,to,1)->pc
				mark=""
				if (pc==interpreter.PC) {
					if (pc==breakpoint) {
						mark="BP =>"
					} else {
						mark="====>"
					}
				} else if (pc==breakpoint) {
					mark="BP"
				}
				
				instr=interpreter.memory.readByte(pc)
				if (instr >= 33 && instr <= 127) {
					instr=Sys.uchar(instr)
					instr=Assembler:InstructionsLookup.get(instr)
				} else if (instr >= 128) {
					instr="(constant)"
				}
				
				report(mark,pc.hex(4), metaInfo.get(""+pc), instr)
		} _=>rows
		Lib:ShowRows(rows,null,false)
			
		
		
		println(Curses:CurGoto(0,Term.h-9))
		
		dmax="max=" + interpreter.dataStack.maxDepth
		cmax="max=" + interpreter.callStack.maxDepth
		fmax="max=" + interpreter.frameStack.maxDepth

		println("dataStack  0x" + interpreter.dbase.hex(4) + " [ " + ShowWordStack(interpreter.dataStack) + " ] TOP " + dmax)
		println("callStack  0x" + interpreter.cbase.hex(4) + " [ " + ShowWordStack(interpreter.callStack) + " ] TOP " + cmax)
		println("frameStack 0x" + interpreter.fbase.hex(4) + " [ " + ShowFrameStack(interpreter.frameStack) + " ] TOP " + fmax)
		print(Curses:Underline)
		println(
			"#instr=" + interpreter.executionCount,
			"DATA_START=" + interpreter.DATA_START.hex(4),
			"HERE=" + interpreter.memory.HERE.hex(4),
			"Globals=[" + ShowGlobals(interpreter) + "]"
			)
		print(Curses:Reset)
		
		localVariables=Inner{
			framesize=interpreter.frameStack.peek
			to=framesize
			if (to >= 3) to=3  
			Std.Data.for(0,to,1)->i
				value=interpreter.callStack.getValue(framesize-i-1)
				out("abc".chars.get(i)+"="+value.hex(4))
			| _.concat(" ").trim => x
			if (x != "") x=x+" "
			x
		}
		println(		
			localVariables + 
			if (breakpoint>=0, Curses:TxtRed+"bp="+breakpoint.hex(4)+Curses:Reset, "")
		)
		println

		command=readLine("==> q=quit, d=dump, b=set-bp, c=clear-bp, r=run, ENTER=step").trim
		if(command=="q") {
			break
		} else if (command=="d") {
			println
			addr=ReadMemoryInspectAddress(interpreter.DATA_START)
			ShowMemory(addr, interpreter.memory)
		} else if (command=='b') {
			println
			Input("Enter address for break point (hex)").get.parseInt(16) => breakpoint
		} else if (command=='c') {
			breakpoint=-1
		} else if (command=="r") {
			autoRunCount=100000
		} else if (command.trim=="") {
			interpreter.executeInstruction
		}	 
/Run

Run
/t		
	
