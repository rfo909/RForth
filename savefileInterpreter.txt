
# The interpreter
# --
	P(1) as String => hexString
	P(2) as Dict => tagLookup

	Term.wrap(true)			# to see full error listings
	
	# number of words
	DSTACK_WORDS = 20
	CSTACK_WORDS = 40  # callstack
	FSTACK_FRAMES = 20  # frame stack controls content on callstack
	
	self.WORDSIZE = 2
	self.memory=HWSim:Memory(self.WORDSIZE)
		
	# --- write the hex string into memory
	
	bytes = Util:HexToBytes(hexString)
	addr=self.memory.HERE
	error(addr != 0, "Invalid start address: " + addr)

	self.memory.malloc(bytes.length)
	bytes->b self.memory.writeByte(addr,b) addr=addr+1 |

	# -- store information about the imported hex string
	
	self.symbolLookupEnd=bytes.length
	
	self.tagLookup=tagLookup

	self.PC=0
	self.haltFlag=false
	
	# --- output 

	self.outputLines=List("")

	self.addOutputText = Lambda{
		P(1) as String => s
		
		currOutputLine=self.outputLines.last
		index=self.outputLines.length-1
		updatedLine = currOutputLine + s
		self.outputLines.set(index,updatedLine)
	}
	self.addOutputCR = Lambda {
		self.outputLines.add("")
	}

	self.printString = Lambda{
		P(1) as int => addr
		length=self.memory.readByte(addr)
		Std.Data.for(0,length,1)->i
			out(Sys.uchar(self.memory.readByte(addr+1+i)))
		| _.concat => str
		print(str)
		self.addOutputText(str)
	}
		
	# --- create system data objects in memory
	
	# the data stack stores single words

	self.dbase=self.memory.HERE
	self.memory.mallocWords(DSTACK_WORDS)
	self.dataStack=HWSim:MemStack(self.memory, self.dbase, DSTACK_WORDS, "data")

	# the call stack stores single words
	
	self.cbase=self.memory.HERE
	self.memory.mallocWords(CSTACK_WORDS)
	self.callStack=HWSim:MemStack(self.memory, self.cbase, CSTACK_WORDS, "calls")

	# the frame stack stores frames as two words: base and size
	
	self.fbase=self.memory.HERE
	FSTACK_WORDS=FSTACK_FRAMES*2
	self.memory.mallocWords(FSTACK_WORDS)
	self.frameStack=HWSim:MemStack(self.memory, self.fbase, FSTACK_WORDS, "frames")

	# --- done with integrating code and setting up system structures on heap

	self.DATA_START=0  	# no protection

	self.nextInstruction=Lambda{
		self.memory.readByte(self.PC)
	}


	# data stack
	self.push=Lambda{P(1)=>value self.dataStack.push(value)}
	self.pop=Lambda{self.dataStack.pop}


	# call stack
	self.cpush=Lambda{
		P(1) as int => value
		self.callStack.push(value)
		frameInfo=self.fpeek

		self.frameStack.pop
		self.frameStack.pop
		self.fpush(frameInfo.base, frameInfo.size+1)
	}

	# frame stack
	
	self.fpush = Lambda{
		P(1) as int => base
		P(2) as int => size
		self.frameStack.push(base)
		self.frameStack.push(size)
	}

	self.fpeek = Lambda {
		size=self.frameStack.pop
		base=self.frameStack.peek
		self.frameStack.push(size)
		SymDict(base,size)
	}

	self.fpop = Lambda{
		self.frameStack.pop
		self.frameStack.pop
	}
	
	# native interface functions list
	
	self.nativeFunctions=Interpreter:NativeFunctions 

	# initialize frame stack these numbers are offsets on the callStack

	self.fpush(0,0)

	self.PANIC = Lambda{
		P(1) => msg
		
		Lib:Header(msg)
		println("PC=0x" + self.PC.hex(4),"#count=" + self.executionCount)
						
		readLine("PANIC")
	}


	self.executionCount=0
	self.executeInstruction=Lambda{

		pc = self.PC
		
		instr=self.memory.readByte(self.PC)
		if (instr < 32) {
			# reserved
			error("ERROR: Reserved instruction: " + instr)
		} else if (instr > 127) {
			# encoded number literal in 6 lowest bits
			if (instr.bin(8).chars.get(1)=="1") {
				self.push(0)
			}
			value=self.pop
			value=value*64 + (instr.bin(8).last(6).parseInt(2))
			self.push(value)
		} else {
			instr=Sys.uchar(instr)
			lambdaName="_"+instr
			
			if (!self.has(lambdaName)) {
				error("Unknown instruction lambda '" + lambdaName + "'") 
			} else {

				closure = self.get(lambdaName)
				closure.call
			}
		}
		
		# Executed ok, now update PC unless a jump has already moved it
		if (self.PC == pc) {
			self.PC=pc+1
		}
		self.executionCount=self.executionCount+1
	}

	self._k=Lambda{ # wordsize ( -- N )
		self.push(self.WORDSIZE)
	}
	self._K=Lambda{ # allot  ( N -- )
		byteCount=self.pop
		self.memory.malloc(byteCount)
	}
	self._G=Lambda{ # readb read byte ( addr -- value )
		addr=self.pop
		self.push(self.memory.readByte(addr))
	}
	self._H=Lambda{ # writeb write byte ( value addr -- )
		addr=self.pop
		value=self.pop
		if (addr < self.DATA_START) {
			error("writeb: writing below DATA_START: 0x" + addr.hex(4))
		} else {
			self.memory.writeByte(addr,value)
		}
	}



	self.set("_+", Lambda{self.push(self.pop+self.pop)}) # add ( a b -- a+b )
	self.set("_-", Lambda{b=self.pop a=self.pop self.push(a-b)}) # sub ( a b -- a-b )
	self.set("_*", Lambda{b=self.pop a=self.pop self.push(a*b)}) # mul ( a b -- a*b )
	self.set("_/", Lambda{b=self.pop a=self.pop self.push((a/b).i)}) # div ( a b -- a/b )
	self.set("_<", Lambda{b=self.pop a=self.pop value=if(a<b,1,0) self.push(value)}) # lt ( a b -- 0|1 )
	self.set("_=", Lambda{b=self.pop a=self.pop value=if(a==b,1,0) self.push(value)}) # eq ( a b -- 0|1 )
	self.set("_>", Lambda{b=self.pop a=self.pop value=if(a>b,1,0) self.push(value)}) # gt ( a b -- 0|1 )
	
	self._d=Lambda{ # 1+ ( n -- n+1 )
		self.push(self.pop+1)
	}
	
	self._h=Lambda{	# ne boolean ( a b -- 0|1 )
		b=self.pop a=self.pop value=if(a!=b,1,0) self.push(value)
	}
	self._i=Lambda{ # not boolean ( x -- 0|1 )
		a=self.pop value=if(a==0,1,0) self.push(value)
	}
	self._E=Lambda{ # ge ( a b -- 0|1 )
		b=self.pop
		a=self.pop
		if (a>=b) self.push(1) else self.push(0)
	}
	self._F=Lambda{ # le ( a b -- 0|1 )
		b=self.pop
		a=self.pop
		if (a<=b) self.push(1) else self.push(0)
	}
	
	self._g=Lambda{ # HERE ( -- value )
		self.push(self.memory.HERE)
	}
	
	self.set("_&", Lambda{b=self.pop a=self.pop value=if(a != 0 && b != 0, 1, 0) self.push(value)}) # and boolean ( a b -- 0|1 )
	self.set("_|", Lambda{b=self.pop a=self.pop value=if(a != 0 || b != 0, 1, 0) self.push(value)}) # or boolean ( a b -- 0|1 )
	
	self._S=Lambda{   # jmp ( addr -- ) updates PC
		self.PC=self.pop
	}
	self._T=Lambda{  # jmp? ( cond addr -- ) conditionally updates PC
		addr=self.pop 
		cond=self.pop 
		if(cond != 0) self.PC=addr  
	}  
	
	self._Q=Lambda{  # call ( addr -- )
		targetAddr=self.pop
		returnAddr=self.PC+1 # following call

		self.cpush(returnAddr)
		currFrame=self.fpeek

		frameInfo=Dict.set("base",currFrame.base+currFrame.size).set("size",0)
			# currFrame.size will be at least 1 after we pushed return address

		base=currFrame.base+currFrame.size
		size=0
		self.fpush(base,size)

		self.PC=targetAddr # JMP
	}
		
	self._R=Lambda{  # ret return
		self.fpop

		frameInfo=self.fpeek  # previous frame

		# resetting callstack as it were before call
		self.callStack.setNext(frameInfo.base + frameInfo.size) 
	
		# popping the jump address
		targetAddr=self.callStack.pop

		# must update the frameInfo about having popped the PC from the callStack
		base=frameInfo.base
		size=frameInfo.size-1
		self.fpop
		self.fpush(base,size)

		self.PC=targetAddr # JMP
	}

	self._I=Lambda{  # @ read word
		addr=self.pop
		self.push(self.memory.readWord(addr))
	}
	
	self._J=Lambda{  # ! write word
		addr=self.pop
		if (addr < self.DATA_START) error("!: writing below DATA_START: 0x" + addr.hex(4))
		value=self.pop
		self.memory.writeWord(addr,value)
	}

	self._O=Lambda{  # cpush push value from data stack on call stack ( x -- )
		self.cpush(self.pop)
	}
	
	self._f = Lambda { # cforce modify call stack
		# not implemented here, only in Arduino
	}
	
	self._3=Lambda{ # cget ( index -- value ) get value by index from call stack, indexed from call frame base
		#println("PC=" + self.PC.hex(4))
		index=self.pop
		
		frameInfo=self.fpeek
		base=(self.cbase + (frameInfo.base*self.WORDSIZE))
		value=self.memory.readWord(base+self.WORDSIZE*index)
		self.push(value)		
	}
	self._4=Lambda{ # cset (value index -- ) set value in stack frame (must have been cpush'ed first)
		index=self.pop
		value=self.pop

		frameInfo=self.fpeek
		base=(self.cbase + (frameInfo.base*self.WORDSIZE))
		self.memory.writeWord(base+self.WORDSIZE*index, value)	
	}
	
	self._j=Lambda { # drop  ( a -- )
		self.pop
	}
	
	self._l=Lambda{ # dup ( x -- x x )
		value=self.pop
		self.push(value)
		self.push(value)
	}
	
	self._m=Lambda{ # swap ( a b -- b a )
		a=self.pop
		b=self.pop
		self.push(a)
		self.push(b)
	}
	
	self._w = Lambda{ # clear - Clear stack
		self.dataStack.reset
	}
	
	self._n=Lambda{ # W+   ( n -- n+WORDSIZE )
		value=self.pop
		self.push(value+self.WORDSIZE)
	}

	self._o=Lambda{ # over ( a b -- a b a )
		b=self.pop
		a=self.pop
		self.push(a)
		self.push(b)
		self.push(a)
	}

	self._p=Lambda{ # dump show stack contents ( -- )

		println("Datastack BOTTOM ---> TOP")

		values=self.dataStack.getStackValues 
		values->x
			s=("    "+x).last(5)+" "
			print(s)
		|
		println

		values->x
			s=("    x"+x.hex).last(5)+" "
			print(s)
		|

		println
	}
	
	self._W=Lambda{ # print print top value on hex format
		value=self.pop
		print("0x"+value.hex(4))
		self.addOutputText("0x" + value.hex(4))
	}
	self._Y=Lambda{ # print# print top value on unsigned decimal format
		value=self.pop
		print(value)
		self.addOutputText(""+value)
	}
	self._L=Lambda{ # printb print top value on binary format
		value=self.pop
		s=value.bin(self.WORDSIZE*8)
		print(s)
		self.addOutputText(s.sub(0,8)+"_"+s.sub(8))
	}
	self._b=Lambda{ # print#s print top value on signed decimal format
		value=self.pop
		if (value.bin(self.WORDSIZE*8).chars.first=="1") {
			# reverse 2nd complement
			Inner{
				(value-1).bin(self.WORDSIZE*8).chars->x
					if (x=="0") out("1") else out("0")
			} _.concat.parseInt(2) => value

			value=-value
		} 
		print(value)
		self.addOutputText(""+value)
	}	
	self._X=Lambda{ # cr print newline
		println
		self.addOutputCR
	}
	self._U=Lambda { # printc - print byte as character 
		value=self.pop
		if (value >= 32 && value < 255) {
			self.addOutputText(Sys.uchar(value))
		} else {
			error("printc: not a byte: " + value + " " + value.hex(4))
		}
	}

	self._q=Lambda { # andb binary and ( a b -- c )
		b=self.pop
		a=self.pop
		self.push(HWSim:BitwiseAnd(a,b,self.WORDSIZE))	
	}

	self._r=Lambda { # orb binary or ( a b -- c )
		b=self.pop
		a=self.pop
		self.push(HWSim:BitwiseOr(a,b,self.WORDSIZE))	
	}
	self._s=Lambda{ # inv binary not  ( a -- b )
		a=self.pop
		self.push(HWSim:BitwiseNot(a, self.WORDSIZE))
	}
	self._t=Lambda { # << left shift  ( val n -- val )
		bits=self.pop
		value=self.pop
		self.push(HWSim:Leftshift(value, bits, self.WORDSIZE))
	}
	self._u=Lambda { # >> right shift  ( val n -- val )
		bits=self.pop
		value=self.pop
		self.push(HWSim:Rightshift(value, bits, self.WORDSIZE))
	}
	
	self._Z=Lambda{  # halt - terminate execution
		self.haltFlag=true
	}

	self._C=Lambda{  # .str - print string
		addr=self.pop
		self.printString(addr)
	}
	
	self.__=Lambda{ # u2spc - convert underscore to space in string in RAM
		ptr=self.pop
		len=self.memory.readByte(ptr)
		Std.Data.for(0,len,1)->i
			pos=ptr+1+i
			if (self.memory.readChar(pos)=="_") self.memory.writeChar(pos," ")
	}

	self._B=Lambda{ # streq - compare strings, return 0 if not and 1 if equal
		a=self.pop
		b=self.pop
		len=self.memory.readByte(a)
		if (self.memory.readByte(b) != len) {
			self.push(0)
		} else {
			match=true
			Inner{Std.Data.for(0,len,1)->i
				if (self.memory.readByte(a+1+i) != self.memory.readByte(b+1+i)) {
					match=false
					break
				}
			}
			self.push(if(match,1,0))
		}
	}
	self._D=Lambda { # memcpy ( ptrSrc ptrTarget bytecount -- )
		byteCount=self.pop
		target=self.pop
		source=self.pop
		Std.Data.for(0,byteCount,1)->i
			self.memory.writeByte(target+i, self.memory.readByte(source+i))
	}

	self._1=Lambda { # atoi ( strPtr targetPtr -- bool ) decimal, 0x... hex b... binary
		targetPtr=self.pop
		strPtr=self.pop
		len=self.memory.readByte(strPtr)
		Std.Data.for(0,len,1)->i
				out(Sys.uchar(self.memory.readByte(strPtr+1+i)))
		| _.concat => str

		negative = (str.startsWith("-")) 
		if (negative) str=str.sub(1)

		value=null
		if (str.startsWith("0x") && str.sub(2).?parseInt(16)) {
			value=str.sub(2).parseInt(16)
		} else if (str.startsWith("b") && str.sub(1).?parseInt(2)) {
			value=str.sub(1).parseInt(2)
		} else if (str.?parseInt) {
			value=str.parseInt
		} 

		if (negative && value != null) value=-value

		# boolean return value to stack
		self.push(if(value != null, 1, 0))
		# write to ptrTarget
		if (value != null) self.memory.writeWord(targetPtr,value)
	}
		
		

	
	self.bufferedInput=GetInitialForthCode

	# "42 dup add " <-- 1584 instructions to process this in interactive mode
	# ": rf 2 3 add ; rf print " # <-- 7455 instructions
	
	self._v=Lambda{ # readc ( -- byte ) - read single character - blocking
		if (self.bufferedInput.length==0) {
			Lib:Header("The REPL is waiting for more input characters!")
			self.bufferedInput = readLine("Enter input") + " "  # The ENTER key
		}
		if (self.bufferedInput.length==0) {
			self.bufferedInput=" "
		}
		value=self.bufferedInput.chars.first.toHexString("ISO-8859-1").parseInt(16)
		self.push(value)
		self.bufferedInput=self.bufferedInput.sub(1)
		
	 }
	 
	 self._z = Lambda{ # null ( -- 0 ) pushes a single zero on the stack
	 	self.push(0)
	 }
	 
	
	 self._2 = Lambda { # n2code ( num addr nbytes -- N ) num to code, write to addr, nbytes=0 means variable, returns #bytes 
	 	nbytes=self.pop
	 	addr=self.pop
	 	number=self.pop
	 	bytes=NumberTable:GenerateNumberBytes(number,nbytes)
	 	bytes->b
	 		self.memory.writeByte(addr,b)
	 		addr=addr+1
	 	|
	 	self.push(bytes.length)
	 }

	 self._P = Lambda{ # PC ( -- addr )
	 	self.push(self.PC)
	 }
	
	 self._6 = Lambda { # rfwd? ( bool offset -- ) adds offset to PC - for relocatable forth word code
	 	offset=self.pop
	 	cond=self.pop
	 	if (cond != 0) {
	 		#println("self.PC",self.PC,"offset",offset)
	 		self.PC=self.PC+offset
	 		#println("self.PC",self.PC)
	 	}
	 }
	 
	 self._7 = Lambda { # rback? ( bool offset -- ) subtracts offset from PC - for relocatable forth word code
	 	offset=self.pop
	 	cond=self.pop
	 	if (cond != 0) {
	 		self.PC=self.PC-offset
	 	}
	}
	
	self._0 = Lambda { # PANIC ( -- ) Clean up stacks and set PC=0
		self.PANIC("PANIC instruction called")
	}
	
	self._a = Lambda { # native ( ... addr -- int? ) - call nativec with string to get the addr value
		pos=self.pop
		error(pos<0 || pos > self.nativeFunctions.length, "native: invalid addr " + pos)
		
		nativeFunction=self.nativeFunctions.get(pos)
		
		params=List
		Std.Data.for(0,nativeFunction.inCount,1)->i
			params.add(self.pop)
		|
		# normalize params by reversing
		params=params.reverse
		
		# in CFT since the code is a Lambda inside a Dict, it has been transformed
		# into a closure, with the dictionary becoming the persistent "self" object
		result = nativeFunction.code(params, self.memory)

		if (Sys.getType(result)=="int") {
			self.push(result) # must be int, possibly a pointer into memory
		}
	}
	
	self._c = Lambda { # nativec ( str -- addr ) - compile native reference into numeric format
		ptr=self.pop
		
		len=self.memory.readByte(ptr)
		Std.Data.for(0,len,1)->i
			pos=ptr+1+i
			out(self.memory.readChar(pos))
		| _.concat => name
		addr = Interpreter:CompileNativeCall(name)
		self.push(addr)
	}
	
		
		
	 
		
/class Interpreter

# Native function (written in interpreter implementation language, in this case CFT)
# --
	P(1) as String => name
	P(2) as int => inCount
	P(3) as Callable => code
	
	SymDict(name,inCount,code)
/NativeFunction


# Lookup native call, return index into NativeFunctions list
# --
	P(1) as String => name
	#println("CompileNativeCall, name=" + name)
	
	found=false
	pos=0
	NativeFunctions->f
		if(f.name==name) {
			found=true
			break
		}
		pos=pos+1
	|
	error(!found,"Native function '" + name + "' not found!")
	pos
/CompileNativeCall

	
# Native functions (written in C or as here, in CFT)
# --
	List(

		# convert underscore to space in string; called from REPL for "xxx_yyy strings 

		NativeFunction("calc",1,Lambda{
			P(1) as List=>params
			P(2) as &Memory => memory

			ptr=params.first
			len=memory.readByte(ptr)
			Std.Data.for(0,len,1)->i
				pos=ptr+1+i
				out(memory.readChar(pos))
			| _.concat => expr
			
			Sys.eval(expr).i
		})
	)	
/NativeFunctions

# Show frame stack
# --
	P(1) as &MemStack => frameStack

	# pair two values
	count=0
	frameStack.getStackValues->value
		count=count+1
		if (count % 2 == 0) out(":") else out(" ")
		out(value)
	| _.concat
//ShowFrameStack


# Show word stack
# --
	P(1) as &MemStack => stack
	stack.getStackValues->value
		out(value.hex(4))
	| _.concat(" ")
//ShowWordStack




# Show memory content
# --
	P(1) as int => startAddr
	P(2) as &Memory => memory

	bytesPerLine=if(Term.w > 90, 8, 4)
	
	lastAddr=startAddr + (Term.h-6)*bytesPerLine
	if (lastAddr < startAddr+10) lastAddr=startAddr+10
	if (lastAddr >= memory.HERE) lastAddr=memory.HERE
		

	hex=""
	info=""
	dec=""
	
	Std.Data.for(startAddr, lastAddr, 1)->addr
		offset=addr-startAddr

		if (offset % bytesPerLine == 0) {
			println (hex + "  " + info + "  " + dec)
			print("  " + addr.hex(4)+" | ")
			hex=info=dec=""
		}
		value=memory.readByte(addr)
		hex=hex+value.hex(2) + " "
		dec=dec+("   "+value).last(3)+" "

		if (value >=33 && value <=127) {
			info=info + Sys.uchar(value) + " "
		} else {
			info=info + ". "
		}
		
	|
	{loop break(hex.length>=bytesPerLine*3) hex=hex+" "}
	{loop break(info.length>=bytesPerLine*2) info=info+" "}
	{loop break(dec.length>=bytesPerLine*4) dec=dec+" "}

	println (hex + "  " + info + "  " + dec)

	println
/ShowMemory	




# Show disassembled code
# --
	P(1) as int => startAddr
	P(2) as &Memory => memory
	P(3) as Dict => metaInfo

	pc=startAddr
	loop
		Inner {
			loop
				break(pc>=memory.HERE)
				instr=memory.readByte(pc)
				if (instr >= 33 && instr <= 127) {
					ch=Sys.uchar(instr)
					tryCatch(x=Assembler:InstructionsLookup.get(ch))=>result
					if (result.ok) {
						instr=x
					} else {
						instr="(data: 0x" + instr.hex(2) + ")"
					}
				} else if (instr >= 128) {
					instr="0x"+instr.hex(2)
				}
				
				report(pc.hex(4), 
					(metaInfo.get(""+pc,"")+" ".times(25)).first(25), instr)
					
				pc=pc+1
				if (pc-startAddr > Term.h-5) break
				
		} _=>rows
		Lib:ShowRows(rows,null,false)
		readLine("Enter")
		break

/ShowDis	


# Read memory address
# --
	P(1) as Dict => tags
	P(2) as String => info

	Input("Enter address (" + info + ") as hex NNNN or tag or part of tag, 'q' to abort").get =>s
	if (s.trim=="-") {
		null
	} else if (s.?parseInt(16)) {
		s.parseInt(16)
	} else if (tags.has(s)) {
		tags.get(s)
	} else {
		value=null
		Inner{
			tags.keys->key
				#println(key)
				if (key.contains(s)) {
					println("Using tag " + key)
					readLine("Enter")
					value=tags.get(key) 
					break
				}
			|
		}
		value
	}  	
//ReadMemoryAddress



# Initial forth code
# --
	Sys.savefile.dir.file("Forth.txt").read->line
		break(line.trim=="#END")
		s=line.before("\")
		s=(s.before("(").trim + " " + s.after(")").trim).trim
		reject(s=="")
		out(s)
	| => lines
	#lines.print
	#readLine("Enter")
	
	
	str = lines.concat(" ") + " "  # trigger final word
	#println(str)
	#readLine("Enter")
	str
	"" 
/GetInitialForthCode

# Get initial Forth code as C array
# --
	code = GetInitialForthCode
	println
	println("// Interpreter:ForthC");
	println("const int forthCodeLength=" + code.length + ";")
	println("const byte forthCode[]={")
	comma=false
	count=0
	code.chars->c
		if (comma) print(",")
		print("0x"+c.toHexString("ISO-8859-1"))
		comma=true
		count=count+1
		if (count >= 16) {
			println()
			count=0
		}
	|
	println("};")
/ForthC
	
	

# Test
# --
	# uses Curses
	Curses:Enable

	dict = Db2:Get("RForth","data")
	hexBlock=dict.hexBlock
	tags=dict.tags
	tagListSorted=dict.tagListSorted
	metaInfo=dict.metaInfo
	
	
	
	runUntilCount=-1		# Sys.currentTimeMillis
	monitorByteAddr=-1		# monitor for changes
	breakpoint=-1
	autorun=false

	interpreter=Interpreter(hexBlock, tags)
	interpreter.DATA_START=tags.get("PROTECT")

	monitorByteValue=0

	lastReadTime=Sys.currentTimeMillis

	loop
		pc=interpreter.PC
		if (instr=interpreter.memory.readByte(pc)==118) {  # "v" is readc
			if (interpreter.bufferedInput=="") {

				elapsedTime=Sys.currentTimeMillis - lastReadTime
				println
				readLine("[" + elapsedTime + "] Ok")=>s
				if (s=="q") {
					interpreter.bufferedInput=" "
					autorun=false 
				} else {
					s=" " + s + " "
					interpreter.bufferedInput=s
				}
				lastReadTime=Sys.currentTimeMillis
			}
		}

		if (interpreter.haltFlag) {
			interpreter.haltFlag=false
			autorun=false
		}
		if (interpreter.PC==breakpoint) {
			runUntilCount=-1
			autorun=false
		}
		if (runUntilCount > 0 && interpreter.executionCount==runUntilCount) {
			runUntilCount=-1
			autorun=false
		}
		if (monitorByteAddr >= 0 && monitorByteAddr < interpreter.memory.HERE 
				&& interpreter.memory.readByte(monitorByteAddr) != monitorByteValue)
		{
			autorun=false
			monitorByteValue = interpreter.memory.readByte(monitorByteAddr)
		}
		
		if (autorun) {
			tryCatch(interpreter.executeInstruction) => result
			if (!result.ok) {
				println(result.msg)
				readLine("Enter")
				interpreter.PANIC(result.msg)
				autoRun=false
			} else {
				continue
			}
		}
		
		# show outputlines
		print(Curses:Clear)
		
		outputLines=interpreter.outputLines
		if (outputLines.length > 10) outputLines = outputLines.last(10)
		outputLines=List("Output:","-------")+outputLines
		count=outputLines.length
		Inner {
			x=60
			maxLineLength=Term.w-x-2
			
			Std.Data.for(0,count,1)->y
				line=outputLines.get(y)
				if (line.length > maxLineLength) line=line.sub(0,maxLineLength)+"+"
				println(Curses:CurGoto(x,Term.h-10-count+y)+line)
				
		}
		
		print(Curses:Home)
		
		# show context
		lines=Term.h-10
		if (!Curses:Enabled) lines=lines-5
		
		from=interpreter.PC-(lines div 3)
		if (from < 0) from=0
		to=from+lines
		if (to >= interpreter.memory.HERE) to=interpreter.memory.HERE-1
		
		
		Inner {
			Std.Data.for(from,to,1)->pc
				
				mark=""
				if (pc==interpreter.PC) {
					if (pc==breakpoint) {
						mark="BP =>"
					} else {
						mark="====>"
					}
				} else if (pc==breakpoint) {
					mark="BP"
				}
				
				instr=interpreter.memory.readByte(pc)
				if (instr >= 33 && instr <= 127) {
					ch=Sys.uchar(instr)
					tryCatch(x=Assembler:InstructionsLookup.get(ch))=>result
					if (result.ok) {
						instr=x
					} else {
						#println("pc=" + pc.hex + " ERROR: " + result.msg)
						instr="(data: 0x" + instr.hex(2) + ")"
						#println("instr=" + instr)
						#readLine("Enter")
					}
				} else if (instr >= 128) {
					instr="0x"+instr.hex(2)
				}
				
				report(mark,pc.hex(4), 
					(metaInfo.get(""+pc,"")+" ".times(25)).first(25), instr)
		} _=>rows
		Lib:ShowRows(rows,null,false)
			
		
		
		println(Curses:CurGoto(0,Term.h-9))
		
		dmax="max=" + interpreter.dataStack.maxDepth
		cmax="max=" + interpreter.callStack.maxDepth
		fmax="max=" + interpreter.frameStack.maxDepth

		println("dataStack  0x" + interpreter.dbase.hex(4) + " [ " + ShowWordStack(interpreter.dataStack) + " ] TOP " + dmax)
		println("frameStack 0x" + interpreter.fbase.hex(4) + " [ " + ShowFrameStack(interpreter.frameStack) + " ] TOP " + fmax)
		println("callStack  0x" + interpreter.cbase.hex(4) + " [ " + ShowWordStack(interpreter.callStack) + " ] TOP " + cmax)
		
		print(Prompt:GetPathColor)
		println(
			"#instr=" + interpreter.executionCount,
			"DATA_START=" + interpreter.DATA_START.hex(4),
			"HERE=" + interpreter.memory.HERE.hex(4)
			)
		print(Curses:Reset)
		
		localVariables=Inner{
			framesize=interpreter.frameStack.peek
			to=framesize
			if (to >= 3) to=3  
			Std.Data.for(0,to,1)->i
				value=interpreter.callStack.getValue(framesize-i-1)
				out("abc".chars.get(i)+"="+value.hex(4))
			| _.concat(" ").trim => x
			if (x != "") x=x+" "
			x
		}
		print(Prompt:GetColor)
		print(localVariables)
		print(Curses:Reset)
		 
		if (breakpoint>=0) print("bp="+breakpoint.hex(4), "")
		println
	
		command=readLine("==> q=quit, d=dump, D=dis, b=bp, c=clear-bp, h=hex->dec, r=run s=skip, ENTER=step").trim
		if(command=="q") {
			break
		} else if (command=="d") {
			println
			Inner{
				loop
					addr=ReadMemoryAddress(tags,"dump")
					break(addr==null)
					ShowMemory(addr, interpreter.memory)
			}
		} else if (command=="D") {
			println
			addr=ReadMemoryAddress(tags,"dis")
			ShowDis(addr, interpreter.memory, metaInfo)
		} else if (command=='b') {
			addr=ReadMemoryAddress(tags,"breakpoint")
			if (addr==null) addr=-1
			breakpoint=addr
		} else if (command=='c') {
			breakpoint=-1
		} else if (command=='h') {
			println(readLine("Hex").parseInt(16))
			readLine("Continue")
		} else if (command.startsWith("r")) {
			Input("Enter instruction count, or 'bNNNN' = hex address to monitor byte change").get => s
			if (s.startsWith("b")) {
				monitorByteAddr=s.sub(1).parseInt(16)
				monitorByteValue=-1
				runUntilCount=-1
			} else {
				instrCount=s.parseInt
				runUntilCount=instrCount
				monitorByteAddr=-1
			}
			autorun=true

		} else if (command=="s") {
			breakpoint=interpreter.PC+1
			autorun=true
		} else if (command.trim=="") {
			tryCatch(interpreter.executeInstruction) => result
			if (!result.ok) {
				error("executeInstruction failed: " + result.msg)
				# cancel autorun
				autorun=false
			}
		}	 
/Run

Run
/t		
	
