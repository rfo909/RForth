Development log
---------------
NEWEST FIRST


TODO: 
	- implement ( ... -- ...) and stack sanity checks for word execution 
	
	- create word by word parser. This only requires us to keep a buffer
	for the longest word (limit to 20 chars isn't unreasonable). 
		- This will save us 180 bytes for input buffer, and 160 bytes
		  for the max 80 token pointers.

	
LOWER PRI

	- consider changing the PUSH op to a two-bit prefix saying that either
	  there is a six-bit value integrated, or the six bits contain number of
	  bytes following, getting rid of the LSHIFT and OR. Big number literals
	  can result in 17 bytes of code, as each push op (one byte) pushes a 7-bit
	  number, and those then have to be left-shifted and OR'ed together ... 
	  
	  Pushing 1000 from code, results in five bytes ...
	  
	- extend if{ with }else{
	
	
2022-05-26 v0.2.0
-----------------
Modified the input processing so that in interactive mode we can press ENTER
without having to supply a semicolon. Tested this in both Arduino Serial Terminal
and minicom.

Updated doc.

	
2022-05-25
----------
Switching to atmega2560. 8 Kb SRAM and 4K EEPROM! 

http://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-2549-8-bit-AVR-Microcontroller-ATmega640-1280-1281-2560-2561_datasheet.pdf

	
2022-05-24 v0.1.8
-----------------
Added support for stack description on the following format:

: funcName ( :byte =a :int =b ) ... ;

The order is the same as when doing the call. The byte code run these
in the following order

	:int 
	=b
	:byte
	=a

The stack description for results is not functional, but is allowed. 

The "--" and all following up to the ")" is ignored.

: func ( :byte =a :byte =b -- :int ) ... ;

	# the "-- :int" part is ignored for now, as it needs to
	# generate code when calling return and at EOF
	
	

2022-05-23 v0.1.7
-----------------
Fixed so local variable assign includes type, and likewise, that this gets
pushed back on the stack when referring variable.

Also modified input loop, so that backspace is honoured, which makes using
minicom easier. Created readme file for minicom. It allows us to paste in
greater amounts of text. Added support for comments on format # ...

The # must not be part of a word.

Also created a Doc.md file with all functionality briefly summed up.

Type casts now strip bits, so that if converting int 0x1234 to byte,
the value becomes 0x34. Converting back to int shows that those bits
are lost: 0x0034



2022-05-22 v0.1.6
-----------------
Added :bool type and :char type. Modified type casts. After getting the
#include <Arduino.h> into Common.hh, we can Serial.print and use F("sdf") in
all source files. Simplified error logging, and introduced abort function,
which is also invoked from code with

	void setAbortCodeExecution ()
	
Error messages are better, and no more freeze whenever there are errors.
	
2022-05-21 v0.1.5
-----------------
Created keyword "null" and corresponding type NULL. Also defined types SYM, ADDR
and COMPLEX, with keywords ":sym" and ":addr" to verify value on stack is
SYM or ADDR, respectively. The COMPLEX type has no such keyword. There also is
no keyword ":null"

The idea is that SYM is a word literal, to be created by 

	' something
	
The literal words will need to be stored in the same space as word names.

	
The ADDR type will in turn be created by a target indicator, preferrably in
the form of firmware functions RAM, EEPROM, FLASH and EXTERN(n) that supply 
values understood by the C code, followed by an (uint) address inside that medium.

The idea is that EXTERN(n), supporting multiple external devices, are routed via
particular hook words, which handle details concerning off-MCU storage outside
the C code.

The last type, COMPLEX, is for defining structs and lists, which will be language
constructs

* Structs

	1 =a 2 =b { a b } :struct:xxx =myStruct
	
The meta-keyword :struct:xxx must be recognized by the parser,  and checks
or applies a subtype ("xxx") to the struct data. The :struct:xxx is a word literal
stored somewhere. 

* Lists

Something like

	[ 1 2 3 ] =x   # has type :list 
	[ 1 2 3 ] :list:whatever =x  # has type :list:whatever
	
	A value of type :list:x can be modified to :list:x:y or :list but not
	directly to :list:y ... or something. This hasn't been thought out yet.


The bottom line is that we need data structures, not just a hierarchy of words
calling each other. 
	
* (Strings)

Possibly we can adopt the Forth standard of sequences of words as strings of sorts,
letting  

	." a b c "
	
become

	[ ' a ' b ' c ] :list:words
	
At some point we will want to add a keyword that prints data to Serial from 
RForth code




2022-05-21 v0.1.4
-----------------
Created functionality for read, write and get length of on-board EEPROM.

ee:write ( value addr -- )
ee:read  ( addr -- :byte ) 
ee:length ( -- :int ) 
	(returns 1024 on the nano)
	
Also made lookupSymbol() in OpCodes.cpp use PROGMEM instead of heap strings, when
mapping built-in functions like "+" and "-" to op-codes.

Actually saved about 125 bytes!!



2022-05-21
----------
Added monitoring for max stack depth (data and callstack), presented for stats
command. 

Reduced number of local variables from 8 to 6, and reduced data stack from
20 to 15. The idea is that words pick data off the data stack, storing them
in local variables, then possibly calling other words, and finally producing
a result. 


2022-05-21 v0.1.3
-----------------
Moved op-code names into PROGMEM, and so enabled the disassembler permanently as
it consumes no heap space any more. Extended the README.md with complete example
code for "blink" and output from the disassember, with detailed description.


2022-05-20
----------

Did some heap memory use reduction, by letting ERR* and WARN* take a code which 
is ran through a switch doing Serial.println() with F(...) strings, using PROGMEM
instead of the heap. Saved some 280 bytes this way. 

2022-05-19 v0.1.2
-----------------

Adding EEPROM support, as we have 1Kb of permanent storage there. Will change
the storage model into a sequence of string + code + string + code, as each
is terminated by a single 0-byte.

Added types and extended stack to contain long values (4 bytes). Changed default 
type from int to long.

Added internal function millis for simple timing.

2022-05-19
----------

Fixed bug that prevented redef. of word.

Optimization: created lget[0-3] and lset[0-3] and using PUSH + lset / lget for
local variables beyond the first 4. This results in smaller code, which is good when
every byte of ram counts.

Created interactive commands stats and dis:xxx plus help.

Changed memory allocations for persistent string and code depending on whether
disassembler is enabled or not, as enabling it costs about 200 bytes of string 
constants on the heap.

2022-05-18 v0.1.1 Data Stack value types
----------------------------------------
Added support for types on stack. Keeping current functions
dsPush() dsPeek() dsPop() dsGet() but added checks so they can
only work on numeric data.

The WORD type is for word literals (to be introduced)

Fixed bug: names of local variables were not reset along with other Input resets

Modified OP_DUP to call func in Stacks which handles the new struct type values
on data stack.


2022-05-17 v0.1 



