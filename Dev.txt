Development log
---------------
NEWEST FIRST


TODO: 
	- enforce max length function (text / tokens),
			(as warnings, not as "halt" type errors)
			Max number of op-codes is 128, as this is the largest
			single 7-bit PUSH value, which is used by the JMP ops,
			but RAM dictates limits on input-string, and token pointers,
			when parsing. A stateful parser receiving single tokens one
			at a time, could reduce memory needs.
	- local variables must inhert type of values from stack, and push values back with type
	- numeric types conversions for arithmetic ops? 
	- enforce type where relevant (read, write, ee:read, ee:write)
	- introduce NULL value
	- implement ( ... -- ...) and stack sanity checks for word execution 
	

	

2022-05-21 v0.1.4
-----------------
Created functionality for read, write and get length of on-board EEPROM.

ee:write ( value addr -- )
ee:read  ( addr -- :byte ) 
ee:length ( -- :int ) 
	(returns 1024 on the nano)
	
Also made lookupSymbol() in OpCodes.cpp use PROGMEM instead of heap strings, when
mapping built-in functions like "+" and "-" to op-codes.

Actually saved about 125 bytes!!



2022-05-21
----------
Added monitoring for max stack depth (data and callstack), presented for stats
command. 

Reduced number of local variables from 8 to 6, and reduced data stack from
20 to 15. The idea is that words pick data off the data stack, storing them
in local variables, then possibly calling other words, and finally producing
a result. 


2022-05-21 v0.1.3
-----------------
Moved op-code names into PROGMEM, and so enabled the disassembler permanently as
it consumes no heap space any more. Extended the README.md with complete example
code for "blink" and output from the disassember, with detailed description.


2022-05-20
----------

Did some heap memory use reduction, by letting ERR* and WARN* take a code which 
is ran through a switch doing Serial.println() with F(...) strings, using PROGMEM
instead of the heap. Saved some 280 bytes this way. 

2022-05-19 v0.1.2
-----------------

Adding EEPROM support, as we have 1Kb of permanent storage there. Will change
the storage model into a sequence of string + code + string + code, as each
is terminated by a single 0-byte.

Added types and extended stack to contain long values (4 bytes). Changed default 
type from int to long.

Added internal function millis for simple timing.

2022-05-19
----------

Fixed bug that prevented redef. of word.

Optimization: created lget[0-3] and lset[0-3] and using PUSH + lset / lget for
local variables beyond the first 4. This results in smaller code, which is good when
every byte of ram counts.

Created interactive commands stats and dis:xxx plus help.

Changed memory allocations for persistent string and code depending on whether
disassembler is enabled or not, as enabling it costs about 200 bytes of string 
constants on the heap.

2022-05-18 v0.1.1 Data Stack value types
----------------------------------------
Added support for types on stack. Keeping current functions
dsPush() dsPeek() dsPop() dsGet() but added checks so they can
only work on numeric data.

The WORD type is for word literals (to be introduced)

Fixed bug: names of local variables were not reset along with other Input resets

Modified OP_DUP to call func in Stacks which handles the new struct type values
on data stack.


2022-05-17 v0.1 



