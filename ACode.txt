
:Main
	;; init
	null &ConsFree !		;; initialize ConsFree pointer to zero


	;; test
	&ConsGet call 
		&ConsDispose call
	&Halt jmp	

:Error ;; ( sym sym symCount -- )
	show
	&Halt jmp
	
:Halt
	&Halt jmp
	
	
;; Stack operations


;; Cons cells are created as a CAR+CDR tuple, each value a Word. They are allotted
;; as needed, but also freelisted when disposed off

:ConsFree 0 0 0 0	;; freelist pointer 	
	;; 0 means empty
	;; Using four instructions to generate four bytes as a placeholder.
	;; The value is nulled in :Init before use. Using 4 bytes instead
	;; of 2 to ensure compatibility with 4 byte wordsize - any more is
	;; unthinkable for embedded devices

:ConsAlloc  ; ( -- )
	&ConsFree cpush		;; a=&ConsFree
	HERE   cpush        ;; b=Ptr
	
	wordsize #2 mul allot ;; reserve space
		
	a@ b@ CDR !	;; ptr.CDR=&ConsFree
	b@ a@ !			;; &ConsFree=ptr	
	
	;; no return value
	ret

:ConsGet  ; ( -- ConsPtr) - get Cons cell from free list (call ConsAlloc first if empty)
	&ConsFree cpush   ;; a=&ConsFree
	
	a@ @ null ne &*FreelistOk jmp?
		;; freelist is empty, allocate one Cons
		&ConsAlloc call
	
	:*FreelistOk
	
	;; got data in freelist, take first cons

	a@ @  		;; (ptr to Cons)

	dup CDR a@ !   ;; &ConsFree = ptr.cons

	;; (Ptr)
	ret
	
:ConsDispose  ;; (ptr -- )
	&ConsFree cpush 	;; a=&ConsFree
	dup a@ swap		;; (ptr &ConsFree ptr)
		CDR !		;; ptr.cdr=&ConsFree
		
	;; (ptr)
	a@ !			;; &ConsFree=ptr
	;; no return value
	ret

;; ---------------------------------
;; Reserved tags, must be present
;; ---------------------------------	

:DATA		
	;; data is generated here - the tag is used by disassembler to 
	;; show bytes correctly beyond this point (not as instructions)


