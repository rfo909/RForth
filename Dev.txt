Development log
---------------
NEWEST FIRST


TODO: 
	- enforce max length function (text / tokens),
			Max number of op-codes is 128, as this is the largest
			single 7-bit PUSH value, which is used by the JMP ops,
			but RAM dictates limits on input-string, and token pointers,
			when parsing. A stateful parser receiving single tokens one
			at a time, could reduce memory needs.
			
	- local variables must inhert type of values from stack,
			and push values back with type
	
	- numeric types conversions for arithmetic ops? 
	- enforce type where relevant (read, write, ee:read, ee:write)
	- implement ( ... -- ...) and stack sanity checks for word execution 
	
LOWER PRI

	- consider changing the PUSH op to a two-bit prefix saying that either
	  there is a six-bit value integrated, or the six bits contain number of
	  bytes following, getting rid of the LSHIFT and OR. Big number literals
	  can result in 17 bytes of code ... Pushing 1000 from code, results in
	  five bytes ...
	  
	


2022-05-22 v0.1.6
-----------------
Added :bool type and :char type. Modified type casts. After getting the
#include <Arduino.h> into Common.hh, we can Serial.print and use F("sdf") in
all source files. Simplified error logging, and introduced abort function,
which is also invoked from code with

	void setAbortCodeExecution ()
	
Error messages are better, and no more freeze whenever there are errors.
	
2022-05-21 v0.1.5
-----------------
Created keyword "null" and corresponding type NULL. Also defined types SYM, ADDR
and COMPLEX, with keywords ":sym" and ":addr" to verify value on stack is
SYM or ADDR, respectively. The COMPLEX type has no such keyword. There also is
no keyword ":null"

The idea is that SYM is a word literal, to be created by 

	' something
	
The literal words will need to be stored in the same space as word names.

	
The ADDR type will in turn be created by a target indicator, preferrably in
the form of firmware functions RAM, EEPROM, FLASH and EXTERN(n) that supply 
values understood by the C code, followed by an (uint) address inside that medium.

The idea is that EXTERN(n), supporting multiple external devices, are routed via
particular hook words, which handle details concerning off-MCU storage outside
the C code.

The last type, COMPLEX, is for defining structs and lists, which will be language
constructs

* Structs

	1 =a 2 =b { a b } :struct:xxx =myStruct
	
The meta-keyword :struct:xxx must be recognized by the parser,  and checks
or applies a subtype ("xxx") to the struct data. The :struct:xxx is a word literal
stored somewhere. 

* Lists

Something like

	[ 1 2 3 ] =x   # has type :list 
	[ 1 2 3 ] :list:whatever =x  # has type :list:whatever
	
	A value of type :list:x can be modified to :list:x:y or :list but not
	directly to :list:y ... or something. This hasn't been thought out yet.


The bottom line is that we need data structures, not just a hierarchy of words
calling each other. 
	
* (Strings)

Possibly we can adopt the Forth standard of sequences of words as strings of sorts,
letting  

	." a b c "
	
become

	[ ' a ' b ' c ] :list:words
	
At some point we will want to add a keyword that prints data to Serial from 
RForth code




2022-05-21 v0.1.4
-----------------
Created functionality for read, write and get length of on-board EEPROM.

ee:write ( value addr -- )
ee:read  ( addr -- :byte ) 
ee:length ( -- :int ) 
	(returns 1024 on the nano)
	
Also made lookupSymbol() in OpCodes.cpp use PROGMEM instead of heap strings, when
mapping built-in functions like "+" and "-" to op-codes.

Actually saved about 125 bytes!!



2022-05-21
----------
Added monitoring for max stack depth (data and callstack), presented for stats
command. 

Reduced number of local variables from 8 to 6, and reduced data stack from
20 to 15. The idea is that words pick data off the data stack, storing them
in local variables, then possibly calling other words, and finally producing
a result. 


2022-05-21 v0.1.3
-----------------
Moved op-code names into PROGMEM, and so enabled the disassembler permanently as
it consumes no heap space any more. Extended the README.md with complete example
code for "blink" and output from the disassember, with detailed description.


2022-05-20
----------

Did some heap memory use reduction, by letting ERR* and WARN* take a code which 
is ran through a switch doing Serial.println() with F(...) strings, using PROGMEM
instead of the heap. Saved some 280 bytes this way. 

2022-05-19 v0.1.2
-----------------

Adding EEPROM support, as we have 1Kb of permanent storage there. Will change
the storage model into a sequence of string + code + string + code, as each
is terminated by a single 0-byte.

Added types and extended stack to contain long values (4 bytes). Changed default 
type from int to long.

Added internal function millis for simple timing.

2022-05-19
----------

Fixed bug that prevented redef. of word.

Optimization: created lget[0-3] and lset[0-3] and using PUSH + lset / lget for
local variables beyond the first 4. This results in smaller code, which is good when
every byte of ram counts.

Created interactive commands stats and dis:xxx plus help.

Changed memory allocations for persistent string and code depending on whether
disassembler is enabled or not, as enabling it costs about 200 bytes of string 
constants on the heap.

2022-05-18 v0.1.1 Data Stack value types
----------------------------------------
Added support for types on stack. Keeping current functions
dsPush() dsPeek() dsPop() dsGet() but added checks so they can
only work on numeric data.

The WORD type is for word literals (to be introduced)

Fixed bug: names of local variables were not reset along with other Input resets

Modified OP_DUP to call func in Stacks which handles the new struct type values
on data stack.


2022-05-17 v0.1 



