; This is the base system that eventually will implement some sort of a
; REPL on a microcontroller. It contains instructions, organized under
; tags at two levels, which are employed for direct jumps (jmp), conditional 
; jumps (jmp?) and calls (call), which assume a return (ret).
;
; The outer level of tags is denoted :xxx to define a tag, and &xxx to refer
; it. All tag references result in 5 bytes of code, which when run puts the
; address on the stack. Outer level tags are global.
;
; Then there are local tags. These exist only in the scope between outer 
; tags. This means common words like "again" or "exit" can be used
; in different functions, without mixing up.
;
; These are defined with :*xxx and referred via &*xxx.
;
; The assembler handles patching all forward tag references when building
; the code.
;

:Init
	;; create variables in normal r/w heap memory

	HERE 0 global!		;; ConsHead
	wordsize allot

	HERE 1 global!		;; DictHead
	wordsize allot

	HERE 2 global!		;; InputBuffer - String
	wordsize allot

	;; buffer 
	HERE &InputBufferAddr call !
	256 allot
	
	;; write a zero to InputBuffer to indicate not no content
	0 &InputBufferAddr call writeb
	
	;; register inputbuffer and event handler
	&InputBufferAddr call 0 registerPointer
	&SerialWordReceived 1 registerPointer
	
	&Main jmp

:ConsHead 0 global ret	
:DictHead 1 global ret
:InputBufferAddr 2 global ret

:SerialWordReceived 
	;;halt
	&InputBufferAddr call cpush   ;; a points to inputbuffer
	cr "Word_" .str a .str ""_received .str
	
	;; indicate word consumed
	0 a writeb 
	
	ret


:Main
 	cr "HERE_at_Main_start:_ .str HERE print 
 	
	&ConsGet call
	&ConsGet call
	&ConsGet call
	
	&ConsDispose call
	&ConsDispose call
	&ConsDispose call

 	cr "HERE_at_end_of_Main:_ .str HERE print
 	
	
:Halt 
	;;halt
	;;; Forever loop, serving events only from now on
	&Halt jmp
	




;; Generalized free list mechanism
;; -------------------------------

;; Pop an element off the freelist, or null if freelist empty

:FreePop   ; ( freeHead -- null|ptr )
	cpush			;; a=address of freelist head word
	a @ dup cpush null ne &*notEmpty jmp?  ;; b=address of first element in free list
		null ret

	:*notEmpty
	b @ a!			;; store b.next (first word) into freelist head
	b ret

;; Push an element on the freelist


:FreePush ; ( dataAddr freeHead -- )
	cpush		;; a=freeHead
	cpush		;; b=dataAddr

	a @ b !		;; store freeHead into dataAddr.next (first word)
	b a !		;; store dataAddr in freeHead
	
	ret
	
	
	
	
	
;; Global data structures depend on
;; ConsHead and DictHead, which point to words on the heap 
;; (see Init)
;; ---------------------------------------------------------	

;; Dictionary stuff
;;	
	
; (TODO)

;; CONS cells are created as a two-word CAR+CDR tuple. They are allotted
;; as needed, but also freelisted when disposed off. To calculate the CDR address
;; from the Cons pointer: W+


:ConsGet  ; ( -- ConsPtr) - get Cons cell from free list (call ConsAlloc first if empty)
	&ConsHead call cpush     ;; a=&ConsHead pointer
	a &FreePop call cpush ;; b=ptr/null
	b null ne &*ok jmp?
		HERE b!				;; a=ptr new cons
		wordsize 2 mul allot  ;; reserve the space
	:*ok
	b ret

	
:ConsDispose  ;; ( ptr -- )
	&ConsHead call &FreePush call ret



