; This is the base system that eventually will implement some sort of a
; REPL on a microcontroller. It contains instructions, organized under
; tags at two levels, which are employed for direct jumps (jmp), conditional 
; jumps (jmp?) and calls (call), which assume a return (ret).
;
; The outer level of tags is denoted :xxx to define a tag, and &xxx to refer
; it. All tag references result in 5 bytes of code, which when run puts the
; address on the stack. Outer level tags are global.
;
; Then there are local tags. These exist only in the scope between outer 
; tags. This means common words like "again" or "exit" can be used
; in different functions, without mixing up.
;
; These are defined with :*xxx and referred via &*xxx.
;
; The assembler handles patching all forward tag references when building
; the code.
;

:Init
	;; create variables in normal r/w heap memory

	HERE 0 global!		;; ConsHead
	wordsize allot

	HERE 1 global!		;; DictHead
	wordsize allot

	HERE 2 global!		;; InputBuffer - String
	wordsize allot

	HERE 3 global!		;; ScratchBuffer - String|Any
	wordsize allot

	HERE 4 global!		;; SymbolList
	wordsize allot

	;; create the buffers
	HERE &InputBuffer call !
	256 allot
	
	HERE &ScratchBuffer call !
	256 allot

	
	&Main jmp

:ConsHead
	0 global ret	
:DictHead
	1 global ret
:InputBuffer
	2 global ret
:ScratchBuffer
	3 global ret
:SymbolList
	4 global ret

:Main
 	cr "Main_start: .str HERE print 
 	
	&ConsGet call
	&ConsGet call
	&ConsGet call
	
	&ConsDispose call
	&ConsDispose call
	&ConsDispose call

 	cr "After_HERE: .str HERE print
 	
	
:Halt 
	halt
	&Halt jmp



;; Generalized free list mechanism
;; -------------------------------

;; Pop an element off the freelist, or null if freelist empty

:FreePop   ; ( freeHead -- null|ptr )
	cpush			;; a=address of freelist head word
	a @ dup cpush null ne &*notEmpty jmp?  ;; b=address of first element in free list
		null ret

	:*notEmpty
	b @ a!			;; store b.next (first word) into freelist head
	b ret

;; Push an element on the freelist


:FreePush ; ( dataAddr freeHead -- )
	cpush		;; a=freeHead
	cpush		;; b=dataAddr

	a @ b !		;; store freeHead into dataAddr.next (first word)
	b a !		;; store dataAddr in freeHead
	
	ret
	
	
	
	
	
;; Global data structures depend on
;; ConsHead and DictHead, which point to words on the heap 
;; (see Init)
;; ---------------------------------------------------------	

;; Dictionary stuff
;;	
	
; (TODO)

;; CONS cells are created as a two-word CAR+CDR tuple. They are allotted
;; as needed, but also freelisted when disposed off. To calculate the CDR address
;; from the Cons pointer: W+


:ConsGet  ; ( -- ConsPtr) - get Cons cell from free list (call ConsAlloc first if empty)
	&ConsHead call cpush     ;; a=&ConsHead pointer
	a &FreePop call cpush ;; b=ptr/null
	b null ne &*ok jmp?
		HERE b!				;; a=ptr new cons
		wordsize 2 mul allot  ;; reserve the space
	:*ok
	b ret

	
:ConsDispose  ;; ( ptr -- )
	&ConsHead call &FreePush call ret



