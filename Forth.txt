# CREATE and DOES>

I have made a CREATE non immediate word, which works, as well as the COMMA word, and now I'm pondering on DOES>. This is the logic I have come up with.

CREATE stores a copy of HERE in field CREATE_HERE.

DOES> is immediate, and sets a compiler flag USING_DOES, then generates code to call an ACTUAL_DOES> word.

The SEMICOLON, when it finds the USING_DOES flag, adds a special NOP bytecode to the compile buffer, before the return opcode, and then proceeds as before, managing state.

The ACTUAL_DOES checks that HERE > CREATE_HERE, then resets the compile buffer.
It emits the CREATE_HERE value as code into the compile buffer.

It then looks up the return address back into the code where it was called, which is the word with the NOP special bytecode at the end. It searches from the return address ahead until it finds the NOP, then appends those bytes into the compile buffer

It resets USING_DOES to false, and invokes the SEMICOLON code, which takes care of adding the final "return" op to the compile buffer, and clean up.



(----------------------------)

0 VARIABLE CREATE-HERE
0 VARIABLE USES-DOES


: CREATE
  GetNextWord

  &NextWord readb 1+ => name#
  &NextWord &IsCompilingWord name# memcpy
  
  (store HERE for DOES> to pick up)
  HERE CREATE-HERE !
;

: , (val--)
  HERE CELL allot ! ;
  
  
: DOES>
  cr "DOES>_ .str &IsCompilingWord .str

  (enable compile mode)
  1 &IsCompiling writeb
  0 &CompileBuf writeb
  0 &IsCompilingWordMode writeb (NORMAL) 

  CREATE-HERE @ => ch
  ch 0 ne ch HERE ne and IF
    cr "EmitNumber_ .str ch .
    ch 0 EmitNumber
    0 CREATE-HERE !
  ELSE
    cr "DOES>_No_data .str 
    PANIC
  THEN
;


: <DONE
  &SEMICOLON call
;

: CONST CREATE , DOES> . <DONE  ;








  
(DOES>'nt work yet)



####################################################
(Using buffers for string ops)

(----------------------------)
Dict Str
Str DictUse

&CompileBuf CONSTANT buf
&CompileBufEnd &CompileBuf sub CONSTANT Available

(=============================
NOTE: Using the compile
buffer is safe as long as 
inside running code. Its 
content may change when using
the REPL
=============================)

: clear (--) 0 buf writeb ;

: Length (-- n) buf readb ;

: add (str --)
  => str
  str readb => strLen
  Length => bufLen

  strLen Length add Available gt IF
    "Str:_Buffer_overflow .str 
    PANIC
  THEN
  (-- copy str into buf --)
  str 1+ (source)
    buf Length add 1+ (target)
    strLen (#bytes)
      memcpy
  (-- update buf length --)
  Length strLen add
    buf writeb
;  

(-- for debug --)
: .b buf Available ShowBuffer ;

DictClear
(172 bytes)


(----------------------------)



(----------------------------)
(TEST CODE)

: SClr () -> Str clear ;
: S+ (str) -> Str add ;
: S> (--ptr) -> Str buf ;
: S. S> .str ;

: test 
  SClr 
  "test_ S+ 
  "tust_ S+ 
  S. ;




