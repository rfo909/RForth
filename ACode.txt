

:Main
	;; init
	null &ConsFree !		;; initialize ConsFree pointer to zero

	;; test
	&ConsGet call 
		&ConsDispose call
	&Halt jmp

:Error ;; ( sym sym symCount -- )
	show
	&Halt jmp
	
:Halt
	&Halt jmp
	
	
;; Stack operations


;; Cons cells are created as a CAR+CDR tuple, each value a Word. They are allotted
;; as needed, but also freelisted when disposed off

:ConsFree 0 0 0 0	;; freelist pointer 	
	;; 0 means empty
	;; Using four instructions to generate four bytes as a placeholder.
	;; The value is nulled in :Init before use. Using 4 bytes instead
	;; of 2 to ensure compatibility with 4 byte wordsize - any more is
	;; unthinkable for embedded devices

:ConsAlloc  ; ( -- )
	HERE           ;; Ptr new CONS
		wordsize #2 mul allot ;; reserve space
		
	;; (Ptr)
	
	dup CDR &ConsFree swap !	;; ptr.CDR=&ConsFree
	&ConsFree !			;; &ConsFree=ptr	
	
	;; no return value
	ret

:ConsGet  ; ( -- ConsPtr) - get Cons cell from free list (call ConsAlloc first if empty)

	&ConsFree dup @ null ne &*FreelistOk jmp?
		;; freelist is empty, add one Cons
		&ConsAlloc call
	
	:*FreelistOk
	
	;; got data in freelist, take first cons

	;; (&ConsFree)
	dup @   ;; Ptr to Cons
	
	;; (&ConsFree Ptr)
	CDR @ 
	
	;; (&ConsFree Ptr.CDR)
	swap !  ;; &ConsFree = Ptr.CDR

	;; (Ptr)
	ret
	
:ConsDispose  ;; (ptr -- )
	dup &ConsFree swap	;; (ptr &ConsFree ptr)
		CDR !		;; ptr.cdr=&ConsFree
	;; (ptr)
	&ConsFree !		;; &ConsFree=ptr
	;; no return value
	ret

;; ---------------------------------
;; Reserved tags, must be present
;; ---------------------------------	

:DATA		
	;; data is generated here - the tag is used by disassembler to 
	;; show bytes correctly beyond this point (not as instructions)


