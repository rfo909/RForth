; This is the base system that eventually will implement some sort of a
; REPL on a microcontroller. It contains instructions, organized under
; tags at two levels, which are employed for direct jumps (jmp), conditional 
; jumps (jmp?) and calls (call), which assume a return (ret).
;
; The outer level of tags is denoted :xxx to define a tag, and &xxx to refer
; it. All tag references result in 5 bytes of code, which when run puts the
; address on the stack. Outer level tags are global.
;
; Then there are local tags. These exist only in the scope between outer 
; tags. This means common words like "again" or "exit" can be used
; in different functions, without mixing up.
;
; These are defined with :*xxx and referred via &*xxx.
;
; The assembler handles patching all forward tag references when building
; the code.
;

#DictHead 0 global
#InputBuffer 1 global
#SymHead 2 global


:Init
	;; create variables in normal r/w heap memory

	HERE 0 global!		;; DictHead
	wordsize allot

	HERE 1 global!		;; InputBuffer - points to input buffer
	256 allot		;; 1 global points to this buffer

	HERE 2 global!		;; SymHead - symbol list in HEAP memory
	wordsize allot 
	
	;; initialize InputBuffer length byte to 0
	0 InputBuffer writeb
		
	;; register inputbuffer and event handler
	InputBuffer 0 registerPointer
	&SerialWordReceived 1 registerPointer
	
	&Main jmp
	
:SerialWordReceived 
	;;halt
	InputBuffer cpush   ;; a points to inputbuffer
	cr "Word_" .str a .str ""_received .str
	
	;; indicate word consumed
	0 a writeb 
	ret


;; building a symbol table on the heap for both internally defined words and
;; words received over serial
;; ---

:SymLookup ; (strPtr -- newPtr) - strPtr is internal symbol or temp storage (InputBuffer)
	cpush			;; a = str
	SymHead @ cpush   	;; b=symbol table entry (2 words)
	:*next
		b null eq &*notFound jmp?
		b @ a streq &*found jmp?
		b W+ @ b!
		&*next jmp
	:*found
	b @ ret
	
	:*notFound
	a &SymAdd call  ;; returns pointer to newString
	
	; (newString)
	ret
	
	
:SymAdd ; (strPtr -- newString)
	HERE cpush			;; a=newCons
		wordsize 2 mul allot

	; (strPtr)
	dup readb cpush			;; b=length of string
	
	; (strPtr)
	HERE cpush			;; c=newString
		b 1 add allot
		
	; (strPtr)
	c 
		b 1 add
	
	; (strPtr newString totalLength) 
	memcpy

	;; put data into newCons
	c a !				;; newCons.CAR = newString
	SymHead @ a W+ !		;; newCons.CDR = *SymHead
	a SymHead !			;; SymHead=newCOns
	
	c ret				;; return newString


;; -------------------------------------------------------
;; Dictionary
;; -------------------------------------------------------

:DictAdd ;; ( strPtr codePtr -- )
	swap &SymLookup call cpush	;; a=heapString
	HERE cpush			;; b=newEntry 
	wordsize 3 mul allot		;; (strPtr, codePtr, nextPtr)
	cpush				;; c=code
	
	a b !
	c 
		b W+ !
	DictHead @ 
		b W+ W+ !
	b DictHead !
	ret

:DictLookup ;; ( strptr -- codeptr )
	&SymLookup call cpush		;; a=heapString
	DictHead @ cpush		;; b=currEntry
	:*next
		b null eq &*NotFound jmp?
		b @ a eq &*Found jmp?
		b W+ W+ @ b!
		&*next jmp
	:*Found
		b W+ @ ret
	:*NotFound
		null ret
		

:Dup
	cpush a a
	ret
	
:HelloWorld
	"Hello_world .str
	ret

:Main
	'Dup &Dup &DictAdd call
	'Hello &HelloWorld &DictAdd call
	
	'Hello &DictLookup call call

:Halt 
	halt
	;;; Forever loop, serving events only from now on
	&Halt jmp
	


