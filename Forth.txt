: pOut (pin) NATIVE Pin.ModeOut ;
: zzz (ms) NATIVE Sys.Delay ;
: pw (val pin -- ) NATIVE Pin.WriteDigital ;

: Main 13 pOut
  BEGIN
  1 13 pw
  200 zzz
  0 13 pw
  200 zzz
  key not AGAIN?
  0 13 pw
;     
  

(To make a project automatically runnable)

: save 64 0 0x50 NATIVE I2C.EE.save ;
: load 64 0 0x50 NATIVE I2C.EE.load ;

save 

(set up autorun)

"Main ?C CONSTANT MainRef

: autorun 
  64 0 0x50 NATIVE I2C.EE.load 
  MainRef (return pointer to Main - after load)
;

"autorun ?C NATIVE Sys.EE.SetAutorun 

 
#END
(
Set up code for auto run:
-------------------------
NOTE can not call dictionary words nor use strings, as those get 
compiled into heap locations unavailable when this code runs
)

save

"load ?C NATIVE Sys.EE.SetAutorun

load



#END

(Reset the device, then -automatically- run
the following - note that for uninitialized
onboard EEPROM it returns a single instruction,
"ret" - this should be followed by looking up
the word "Main", and if it exists, call it)

NATIVE Sys.EE.GetAutorun call

 
#END
Dict [input]
[input] DictUse

(
Letting #buf indicate a
static buffer that has the
length byte set to the size
of the buffer
)

: fillSpaces (#buf) 
  => buf
  buf readb 1 - => pos
  BEGIN 
    0x20 buf pos + 1+ writeb
    pos 1 - => pos
    pos AGAIN? ;

: CRLF? (ch) dup 13 == 
  swap 10 == || ;
  
: readLine (#buf)
  dup fillSpaces 
  dup readb => len
  => buf 0 => pos
  0 => c (define before loop)
  BEGIN
    readc => c
    c CRLF?
      pos buf readb >= || 
      IF ret THEN
    c buf pos + 1+ writeb
    pos 1+ => pos  
    1 AGAIN?
;

DictClear

(148 bytes)


(
Testing
=======

[input] DictUse
HERE 32 allot CONSTANT buf
31 buf writeb
buf readLine
  <enter line>
buf .str
)


#END

