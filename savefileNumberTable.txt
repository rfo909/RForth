# Manage tags and generating numbers as code
# Numbers in code are issued as sequences of 6 bit numbers, with
# the high bit set, and the second highest set to push a zero
# first, replacing the need for a separate instruction for just this.
#
# --
	self.TAG_BYTES = 3
	
	# tags are assumed 
	self.tags=Dict	# tagName, tagAddress
	self.patchList=List  # of dictionaries with tagName and patchAddress fields
	
	self.defineTag=Lambda{
		P(1) as String => tagName
		P(2) as int => tagAddress
		error(self.tags.has(tagName), "Invalid redefinition of tag " + tagName)
		self.tags.set(tagName,tagAddress)
	}
	
	self.getTagAddress=Lambda{
		P(1) as String => name
		self.tags.get(name)
	}
	
	# when patching unresolved tag lookups
	self.getTagAsCode=Lambda{
		P(1) as String => name
		NumberTable:GenerateNumberBytes(self.tags.get(name), self.TAG_BYTES)
	}
	
			
	
	self.lookupTag=Lambda{
		P(1) as String => tagName
		P(2) as int => patchAddress
		
		addr=0
		if (self.tags.has(tagName)) {
			addr=self.tags.get(tagName)
		} else {
			self.patchList.add(SymDict(tagName,patchAddress))
		}
		# return bytes
		NumberTable:GenerateNumberBytes(addr, self.TAG_BYTES)
	}
	
	self.getTagListSorted = Lambda{
		self.tags.keys->key
			out(Int(self.tags.get(key), key))
		| _.sort->x
			out(x.data)  # key
	}
	
	self.symbols=Dict
	self.symbolData=List  # list of bytes as int
	self.symbolCount=0
	
	# Symbols are stored in a separate string located somewhere at runtime,
	# and the symbols are a position in that string, which points at the length
	# in hex, followed by the characters. 
	#
	# This function returns the address in the form of a list of bytes, which are
	# valid instructions, to be added to the bytecode.
	
	self.addSymbol = Lambda {
		P(1) as String => symbol
		error(symbol.length > 255, "Symbol too long, max 255: " + symbol)
		
		# Check that no forbidden characters
		Inner{
			symbol.chars->c
				code = c.toHexString("ISO-8859-1").parseInt(16)
				error (code < 32 || code > 127, "Invalid symbol character: " + c)
		}
		
		self.symbolCount=self.symbolCount+1
		
		if (self.symbols.has(symbol)) {
			NumberTable:GenerateNumberBytes(self.symbols.get(symbol))
		} else {
			symPos=self.symbolData.length
			self.symbolData.add(symbol.length)
			Inner { 
				symbol.chars->c 
					hex=c.toHexString("ISO-8859-1")
					error(hex.length > 2, "Unexpected hex string " + hex + " for character '" + c + "'")
					self.symbolData.add(hex.parseInt(16))
			}

			# register in dict for reuse if same symbol used again
			self.symbols.set(symbol,symPos)
			NumberTable:GenerateNumberBytes(symPos)
		}
	}
	
	self.getSymbolHexString = Lambda{

		self.symbolData->x
			out(x.hex(2))
		| _.concat
	}
	
/class Numbers


# Test
# --
	tags=Tags
	tags.addTagDef("init",20)
	tags.addTagDef("MAIN",4078)

	println(tags.lookupTag("MAIN", 99).concat(" "))
	println(tags.lookupTag("Undefined", 100).concat(" "))
	
	JSON:PP(tags.patchList)
	"ok"
//tTags



# Generate number as bytes (list of int) - includes value 122 which it the "z" in front
# --
	P(1) as int => number
	P(2,0) as int => byteCount 	# 0 for lowest possible
	
	bits=number.bin(64)
	
	# consuming from the right, 6 bits at a time
	loop
		if (bits.length < 6) bits="000000"+bits
		break(bits.parseInt(2)==0)
		x="10" + bits.last(6)
		bits=bits.sub(0,bits.length-6)
		out(x.parseInt(2))
	| _.reverse=>bytes
	
	#bytes.print	
	error (byteCount>0 && bytes.length>byteCount,  
		"Value " + number + " does not fit in " + byteCount + " bytes")

	leadingZeroesMissing = 0
	if (bytes.length==0) bytes=List(128)
	
	if (byteCount > 0) {  # 0 means as many as needed
		leadingZeroesMissing=byteCount-bytes.length
	}
	bytes = Std.Data.yes(leadingZeroesMissing, 128) + bytes
	
	# modify first byte has to have the 64 bit set, which means push a zero on the stack first

	bytes.set(0,bytes.get(0)+64)
	
	# return value
	bytes
/GenerateNumberBytes


# Reconstruct number from bytes (for test, as the numbers are considered code, and executed
# one at a time).
# --
	P(1) as List => bytes
	value=999999
	bytes->byte
		if (byte.bin.chars.get(1)=="1") value=0
		x=byte.bin(8).last(6).parseInt(2)
		value=value*64+x
	|
	value
//BackToValue



# Test
# --
	GenerateNumberBytes(1,0) => list
	list->x println(x.bin) 	| 
	BackToValue(list)  # skip the 'z' instruction
//tNumbers

# Check
# --
	Input("Numbers on hex separated by space").get.split->x
		out(x.parseInt(16))
	| _=>list
	BackToValue(list).hex
/ch
